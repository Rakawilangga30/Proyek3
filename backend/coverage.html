
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">BACKEND/controllers/admin_affiliate_controller.go (0.0%)</option>
				
				<option value="file1">BACKEND/controllers/admin_org_controller.go (0.0%)</option>
				
				<option value="file2">BACKEND/controllers/admin_organization_controller.go (0.0%)</option>
				
				<option value="file3">BACKEND/controllers/ads_controller.go (0.0%)</option>
				
				<option value="file4">BACKEND/controllers/affiliate_controller.go (36.9%)</option>
				
				<option value="file5">BACKEND/controllers/affiliate_partnership_controller.go (0.0%)</option>
				
				<option value="file6">BACKEND/controllers/auth_controller.go (75.0%)</option>
				
				<option value="file7">BACKEND/controllers/cart_controller.go (71.9%)</option>
				
				<option value="file8">BACKEND/controllers/checkout_controller.go (0.0%)</option>
				
				<option value="file9">BACKEND/controllers/event_controller.go (0.0%)</option>
				
				<option value="file10">BACKEND/controllers/event_public_controller.go (0.0%)</option>
				
				<option value="file11">BACKEND/controllers/event_publish_controller.go (0.0%)</option>
				
				<option value="file12">BACKEND/controllers/featured_controller.go (0.0%)</option>
				
				<option value="file13">BACKEND/controllers/helpers.go (0.0%)</option>
				
				<option value="file14">BACKEND/controllers/notification_controller.go (75.0%)</option>
				
				<option value="file15">BACKEND/controllers/organization_controller.go (0.0%)</option>
				
				<option value="file16">BACKEND/controllers/organization_profile_controller.go (0.0%)</option>
				
				<option value="file17">BACKEND/controllers/password_reset_controller.go (0.0%)</option>
				
				<option value="file18">BACKEND/controllers/payment_controller.go (0.0%)</option>
				
				<option value="file19">BACKEND/controllers/purchase_controller.go (0.0%)</option>
				
				<option value="file20">BACKEND/controllers/quiz_controller.go (0.0%)</option>
				
				<option value="file21">BACKEND/controllers/report_controller.go (70.5%)</option>
				
				<option value="file22">BACKEND/controllers/session_controller.go (0.0%)</option>
				
				<option value="file23">BACKEND/controllers/session_media_controller.go (0.0%)</option>
				
				<option value="file24">BACKEND/controllers/session_publish_controller.go (0.0%)</option>
				
				<option value="file25">BACKEND/controllers/session_stream_controller.go (0.0%)</option>
				
				<option value="file26">BACKEND/controllers/signed_url_controller.go (0.0%)</option>
				
				<option value="file27">BACKEND/controllers/user_controller.go (45.4%)</option>
				
				<option value="file28">BACKEND/controllers/user_history_controller.go (0.0%)</option>
				
				<option value="file29">BACKEND/controllers/user_password_controller.go (0.0%)</option>
				
				<option value="file30">BACKEND/controllers/user_upload_controller.go (0.0%)</option>
				
				<option value="file31">BACKEND/controllers/video_stream_controller.go (0.0%)</option>
				
				<option value="file32">BACKEND/controllers/withdrawal_controller.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controllers

import (
        "BACKEND/config"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/gin-gonic/gin"
)

// ========================================================
// AFFILIATE APPLICATIONS MANAGEMENT
// ========================================================

// GetAllAffiliateApplications - List all affiliate applications
func GetAllAffiliateApplications(c *gin.Context) <span class="cov0" title="0">{
        status := c.Query("status")

        var apps []struct {
                ID         int64   `db:"id" json:"id"`
                UserID     int64   `db:"user_id" json:"user_id"`
                UserName   string  `db:"user_name" json:"user_name"`
                UserEmail  string  `db:"user_email" json:"user_email"`
                Motivation *string `db:"motivation" json:"motivation"`
                Status     string  `db:"status" json:"status"`
                CreatedAt  string  `db:"created_at" json:"created_at"`
        }

        query := `
                SELECT aa.id, aa.user_id, u.name as user_name, u.email as user_email,
                       aa.motivation, aa.status, aa.created_at
                FROM affiliate_applications aa
                JOIN users u ON aa.user_id = u.id
        `
        if status != "" </span><span class="cov0" title="0">{
                query += " WHERE aa.status = '" + status + "'"
        }</span>
        <span class="cov0" title="0">query += " ORDER BY aa.created_at DESC"

        if err := config.DB.Select(&amp;apps, query); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal memuat data"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"applications": apps})</span>
}

// ReviewAffiliateApplication - Approve or reject affiliate application
func ReviewAffiliateApplication(c *gin.Context) <span class="cov0" title="0">{
        adminID := c.GetInt64("user_id")
        appID := c.Param("id")

        var input struct {
                Action string `json:"action"` // APPROVE or REJECT
                Note   string `json:"note"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        // Get application
        <span class="cov0" title="0">var app struct {
                ID     int64  `db:"id"`
                UserID int64  `db:"user_id"`
                Status string `db:"status"`
        }
        err := config.DB.Get(&amp;app, `SELECT id, user_id, status FROM affiliate_applications WHERE id = ?`, appID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Permohonan tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if app.Status != "PENDING" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Permohonan sudah diproses"})
                return
        }</span>

        <span class="cov0" title="0">newStatus := "REJECTED"
        if input.Action == "APPROVE" </span><span class="cov0" title="0">{
                newStatus = "APPROVED"

                // Add AFFILIATE role to user
                config.DB.Exec(`
                        INSERT INTO user_roles (user_id, role_id)
                        SELECT ?, id FROM roles WHERE name = 'AFFILIATE'
                `, app.UserID)

                // Send notification
                config.DB.Exec(`
                        INSERT INTO notifications (user_id, title, message)
                        VALUES (?, 'Selamat! Permohonan Affiliate Disetujui', 'Sekarang Anda dapat mengajukan event dan mendapatkan penghasilan dari penjualan.')
                `, app.UserID)
        }</span> else<span class="cov0" title="0"> {
                // Send rejection notification
                config.DB.Exec(`
                        INSERT INTO notifications (user_id, title, message)
                        VALUES (?, 'Permohonan Affiliate Ditolak', ?)
                `, app.UserID, input.Note)
        }</span>

        // Update application
        <span class="cov0" title="0">config.DB.Exec(`
                UPDATE affiliate_applications 
                SET status = ?, reviewed_by = ?, reviewed_at = NOW(), review_note = ?
                WHERE id = ?
        `, newStatus, adminID, input.Note, appID)

        c.JSON(http.StatusOK, gin.H{"message": fmt.Sprintf("Permohonan berhasil di%s", map[string]string{"APPROVED": "setujui", "REJECTED": "tolak"}[newStatus])})</span>
}

// ========================================================
// AFFILIATE SUBMISSIONS MANAGEMENT
// ========================================================

// GetAllAffiliateSubmissions - List all affiliate event submissions
func GetAllAffiliateSubmissions(c *gin.Context) <span class="cov0" title="0">{
        status := c.Query("status")

        var submissions []struct {
                ID           int64   `db:"id" json:"id"`
                UserID       *int64  `db:"user_id" json:"user_id"`
                FullName     string  `db:"full_name" json:"full_name"`
                Email        string  `db:"email" json:"email"`
                EventTitle   string  `db:"event_title" json:"event_title"`
                EventPrice   int64   `db:"event_price" json:"event_price"`
                Status       string  `db:"status" json:"status"`
                HasVideo     bool    `db:"has_video" json:"has_video"`
                HasFile      bool    `db:"has_file" json:"has_file"`
                ReviewerName *string `db:"reviewer_name" json:"reviewer_name"`
                CreatedAt    string  `db:"created_at" json:"created_at"`
        }

        query := `
                SELECT asub.id, asub.user_id, asub.full_name, asub.email, asub.event_title, 
                       asub.event_price, asub.status,
                       CASE WHEN asub.video_url IS NOT NULL AND asub.video_url != '' THEN 1 ELSE 0 END as has_video,
                       CASE WHEN asub.file_url IS NOT NULL AND asub.file_url != '' THEN 1 ELSE 0 END as has_file,
                       u.name as reviewer_name, asub.created_at
                FROM affiliate_submissions asub
                LEFT JOIN users u ON asub.reviewed_by = u.id
        `
        if status != "" </span><span class="cov0" title="0">{
                query += " WHERE asub.status = '" + status + "'"
        }</span>
        <span class="cov0" title="0">query += " ORDER BY asub.created_at DESC"

        if err := config.DB.Select(&amp;submissions, query); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal memuat data"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"submissions": submissions})</span>
}

// GetAffiliateSubmissionByID - Get submission detail for admin review
func GetAffiliateSubmissionByID(c *gin.Context) <span class="cov0" title="0">{
        submissionID := c.Param("id")

        var submission struct {
                ID                int64   `db:"id" json:"id"`
                UserID            *int64  `db:"user_id" json:"user_id"`
                FullName          string  `db:"full_name" json:"full_name"`
                Email             string  `db:"email" json:"email"`
                Phone             *string `db:"phone" json:"phone"`
                EventTitle        string  `db:"event_title" json:"event_title"`
                EventDescription  *string `db:"event_description" json:"event_description"`
                EventPrice        int64   `db:"event_price" json:"event_price"`
                PosterURL         *string `db:"poster_url" json:"poster_url"`
                VideoURL          *string `db:"video_url" json:"video_url"`
                VideoTitle        *string `db:"video_title" json:"video_title"`
                FileURL           *string `db:"file_url" json:"file_url"`
                FileTitle         *string `db:"file_title" json:"file_title"`
                BankName          *string `db:"bank_name" json:"bank_name"`
                BankAccountNumber *string `db:"bank_account_number" json:"bank_account_number"`
                BankAccountHolder *string `db:"bank_account_holder" json:"bank_account_holder"`
                Status            string  `db:"status" json:"status"`
                ReviewerName      *string `db:"reviewer_name" json:"reviewer_name"`
                ReviewedAt        *string `db:"reviewed_at" json:"reviewed_at"`
                ReviewNote        *string `db:"review_note" json:"review_note"`
                CreatedAt         string  `db:"created_at" json:"created_at"`
        }

        err := config.DB.Get(&amp;submission, `
                SELECT asub.id, asub.user_id, asub.full_name, asub.email, asub.phone,
                       asub.event_title, asub.event_description, asub.event_price,
                       asub.poster_url, asub.video_url, asub.video_title, asub.file_url, asub.file_title,
                       asub.bank_name, asub.bank_account_number, asub.bank_account_holder,
                       asub.status, asub.reviewed_at, asub.review_note, asub.created_at,
                       u.name as reviewer_name
                FROM affiliate_submissions asub
                LEFT JOIN users u ON asub.reviewed_by = u.id
                WHERE asub.id = ?
        `, submissionID)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error loading affiliate submission %s: %v\n", submissionID, err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Pengajuan tidak ditemukan"})
                return
        }</span>

        // Fetch videos from affiliate_submission_videos table
        <span class="cov0" title="0">var videos []struct {
                ID    int64  `db:"id" json:"id"`
                Title string `db:"title" json:"title"`
                URL   string `db:"url" json:"url"`
        }
        config.DB.Select(&amp;videos, `
                SELECT id, COALESCE(title, '') as title, url 
                FROM affiliate_submission_videos 
                WHERE submission_id = ? 
                ORDER BY id ASC
        `, submissionID)

        // Fetch files from affiliate_submission_files table
        var files []struct {
                ID    int64  `db:"id" json:"id"`
                Title string `db:"title" json:"title"`
                URL   string `db:"url" json:"url"`
        }
        config.DB.Select(&amp;files, `
                SELECT id, COALESCE(title, '') as title, url
                FROM affiliate_submission_files 
                WHERE submission_id = ? 
                ORDER BY id ASC
        `, submissionID)

        c.JSON(http.StatusOK, gin.H{
                "submission": submission,
                "videos":     videos,
                "files":      files,
        })</span>
}

// ReviewAffiliateSubmission - Approve or reject affiliate event submission
// APPROVE: Create event + session + transfer materials to session_videos/files
func ReviewAffiliateSubmission(c *gin.Context) <span class="cov0" title="0">{
        adminID := c.GetInt64("user_id")
        submissionID := c.Param("id")

        var input struct {
                Action string `json:"action"` // APPROVE or REJECT
                Note   string `json:"note"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        // Get full submission data
        <span class="cov0" title="0">var submission struct {
                ID               int64   `db:"id"`
                UserID           *int64  `db:"user_id"`
                FullName         string  `db:"full_name"`
                Email            string  `db:"email"`
                EventTitle       string  `db:"event_title"`
                EventDescription *string `db:"event_description"`
                EventPrice       int64   `db:"event_price"`
                EventCategory    string  `db:"event_category"`
                PosterURL        *string `db:"poster_url"`
                VideoURL         *string `db:"video_url"`
                VideoTitle       *string `db:"video_title"`
                FileURL          *string `db:"file_url"`
                FileTitle        *string `db:"file_title"`
                Status           string  `db:"status"`
        }
        err := config.DB.Get(&amp;submission, `
                SELECT id, user_id, full_name, email, event_title, event_description, 
                       event_price, COALESCE(event_category, 'Teknologi') as event_category,
                       poster_url, video_url, video_title, file_url, file_title, status 
                FROM affiliate_submissions 
                WHERE id = ?
        `, submissionID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error loading submission %s: %v\n", submissionID, err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Pengajuan tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if submission.Status != "PENDING" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Pengajuan sudah diproses"})
                return
        }</span>

        <span class="cov0" title="0">if input.Action == "APPROVE" </span><span class="cov0" title="0">{
                // Get Official organization
                var officialOrgID int64
                err := config.DB.Get(&amp;officialOrgID, `SELECT id FROM organizations WHERE is_official = 1 LIMIT 1`)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Organisasi Official belum dibuat"})
                        return
                }</span>

                // Create event under Official org
                <span class="cov0" title="0">description := ""
                if submission.EventDescription != nil </span><span class="cov0" title="0">{
                        description = *submission.EventDescription
                }</span>

                <span class="cov0" title="0">eventResult, err := config.DB.Exec(`
                        INSERT INTO events (organization_id, title, description, category, thumbnail_url, 
                                            publish_status, affiliate_submission_id)
                        VALUES (?, ?, ?, ?, ?, 'DRAFT', ?)
                `, officialOrgID, submission.EventTitle, description, submission.EventCategory, submission.PosterURL, submission.ID)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[APPROVE] Error creating event: %v\n", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal membuat event"})
                        return
                }</span>

                <span class="cov0" title="0">eventID, _ := eventResult.LastInsertId()

                // Create session
                sessionResult, err := config.DB.Exec(`
                        INSERT INTO sessions (event_id, title, description, price, publish_status)
                        VALUES (?, ?, ?, ?, 'DRAFT')
                `, eventID, submission.EventTitle, description, submission.EventPrice)

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[APPROVE] Error creating session: %v\n", err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal membuat session"})
                        return
                }</span>

                <span class="cov0" title="0">sessionID, _ := sessionResult.LastInsertId()

                // ============================================
                // TRANSFER MATERIALS - FIX: Use video_url and file_url columns
                // ============================================
                os.MkdirAll("uploads/videos", os.ModePerm)
                os.MkdirAll("uploads/files", os.ModePerm)

                // --- VIDEOS ---
                var videos []struct {
                        Title string `db:"title"`
                        URL   string `db:"url"`
                }
                config.DB.Select(&amp;videos, `
                        SELECT COALESCE(title, 'Video Materi') as title, url 
                        FROM affiliate_submission_videos 
                        WHERE submission_id = ?
                `, submissionID)

                fmt.Printf("[APPROVE] Found %d videos in affiliate_submission_videos\n", len(videos))

                // Fallback to legacy video_url if no videos in new table
                if len(videos) == 0 &amp;&amp; submission.VideoURL != nil &amp;&amp; *submission.VideoURL != "" </span><span class="cov0" title="0">{
                        fmt.Printf("[APPROVE] Using legacy video_url: %s\n", *submission.VideoURL)
                        title := "Video Materi"
                        if submission.VideoTitle != nil &amp;&amp; *submission.VideoTitle != "" </span><span class="cov0" title="0">{
                                title = *submission.VideoTitle
                        }</span>
                        <span class="cov0" title="0">videos = append(videos, struct {
                                Title string `db:"title"`
                                URL   string `db:"url"`
                        }{Title: title, URL: *submission.VideoURL})</span>
                }

                // Insert all videos to session_videos - FIX: use video_url column
                <span class="cov0" title="0">for i, video := range videos </span><span class="cov0" title="0">{
                        videoFilename := filepath.Base(video.URL)
                        srcPath := video.URL
                        dstPath := filepath.Join("uploads/videos", videoFilename)

                        // Copy file
                        if _, err := os.Stat(srcPath); err == nil </span><span class="cov0" title="0">{
                                copyFile(srcPath, dstPath)
                        }</span>

                        // FIX: Insert dengan kolom video_url, bukan filename
                        <span class="cov0" title="0">_, insertErr := config.DB.Exec(`
                                INSERT INTO session_videos (session_id, title, video_url, order_index)
                                VALUES (?, ?, ?, ?)
                        `, sessionID, video.Title, dstPath, i+1)
                        if insertErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[APPROVE] Error inserting video %d: %v\n", i+1, insertErr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[APPROVE] ✅ Video %d inserted: %s\n", i+1, dstPath)
                        }</span>
                }

                // --- FILES ---
                <span class="cov0" title="0">var files []struct {
                        Title string `db:"title"`
                        URL   string `db:"url"`
                }
                config.DB.Select(&amp;files, `
                        SELECT COALESCE(title, 'Modul Materi') as title, url 
                        FROM affiliate_submission_files 
                        WHERE submission_id = ?
                `, submissionID)

                fmt.Printf("[APPROVE] Found %d files in affiliate_submission_files\n", len(files))

                // Fallback to legacy file_url if no files in new table
                if len(files) == 0 &amp;&amp; submission.FileURL != nil &amp;&amp; *submission.FileURL != "" </span><span class="cov0" title="0">{
                        fmt.Printf("[APPROVE] Using legacy file_url: %s\n", *submission.FileURL)
                        title := "Modul Materi"
                        if submission.FileTitle != nil &amp;&amp; *submission.FileTitle != "" </span><span class="cov0" title="0">{
                                title = *submission.FileTitle
                        }</span>
                        <span class="cov0" title="0">files = append(files, struct {
                                Title string `db:"title"`
                                URL   string `db:"url"`
                        }{Title: title, URL: *submission.FileURL})</span>
                }

                // Insert all files to session_files - FIX: use file_url column
                <span class="cov0" title="0">for i, file := range files </span><span class="cov0" title="0">{
                        fileFilename := filepath.Base(file.URL)
                        srcPath := file.URL
                        dstPath := filepath.Join("uploads/files", fileFilename)

                        // Copy file
                        if _, err := os.Stat(srcPath); err == nil </span><span class="cov0" title="0">{
                                copyFile(srcPath, dstPath)
                        }</span>

                        // FIX: Insert dengan kolom file_url, bukan filename
                        <span class="cov0" title="0">_, insertErr := config.DB.Exec(`
                                INSERT INTO session_files (session_id, title, file_url, order_index)
                                VALUES (?, ?, ?, ?)
                        `, sessionID, file.Title, dstPath, i+1)
                        if insertErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[APPROVE] Error inserting file %d: %v\n", i+1, insertErr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[APPROVE] ✅ File %d inserted: %s\n", i+1, dstPath)
                        }</span>
                }

                // Update submission status
                <span class="cov0" title="0">config.DB.Exec(`
                        UPDATE affiliate_submissions 
                        SET status = 'APPROVED', reviewed_by = ?, reviewed_at = NOW(), review_note = ?
                        WHERE id = ?
                `, adminID, input.Note, submissionID)

                // Add AFFILIATE role to user if not already has it
                if submission.UserID != nil </span><span class="cov0" title="0">{
                        var hasRole int
                        config.DB.Get(&amp;hasRole, `
                                SELECT COUNT(*) FROM user_roles ur
                                JOIN roles r ON ur.role_id = r.id
                                WHERE ur.user_id = ? AND r.name = 'AFFILIATE'
                        `, *submission.UserID)

                        if hasRole == 0 </span><span class="cov0" title="0">{
                                config.DB.Exec(`
                                        INSERT INTO user_roles (user_id, role_id)
                                        SELECT ?, id FROM roles WHERE name = 'AFFILIATE'
                                `, *submission.UserID)
                        }</span>

                        // Send notification
                        <span class="cov0" title="0">config.DB.Exec(`
                                INSERT INTO notifications (user_id, title, message)
                                VALUES (?, 'Event Anda Disetujui!', ?)
                        `, *submission.UserID, fmt.Sprintf("Event '%s' telah disetujui dan masuk ke draft. Admin akan mempublikasikan segera.", submission.EventTitle))</span>
                }

                <span class="cov0" title="0">fmt.Printf("[APPROVE] ✅ Created event=%d, session=%d with %d videos and %d files\n", eventID, sessionID, len(videos), len(files))

                c.JSON(http.StatusOK, gin.H{
                        "message":  "Event berhasil disetujui dan masuk ke draft",
                        "event_id": eventID,
                })</span>

        } else<span class="cov0" title="0"> {
                // Reject - just update status
                config.DB.Exec(`
                        UPDATE affiliate_submissions 
                        SET status = 'REJECTED', reviewed_by = ?, reviewed_at = NOW(), review_note = ?
                        WHERE id = ?
                `, adminID, input.Note, submissionID)

                if submission.UserID != nil </span><span class="cov0" title="0">{
                        config.DB.Exec(`
                                INSERT INTO notifications (user_id, title, message)
                                VALUES (?, 'Event Anda Ditolak', ?)
                        `, *submission.UserID, input.Note)
                }</span>

                <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Pengajuan ditolak"})</span>
        }
}

// Helper function to copy file
func copyFile(src, dst string) error <span class="cov0" title="0">{
        input, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(dst, input, 0644)</span>
}

// ========================================================
// AFFILIATE LEDGERS
// ========================================================

// GetAffiliateLedgers - List all affiliate ledger entries
func GetAffiliateLedgers(c *gin.Context) <span class="cov0" title="0">{
        isPaidOut := c.Query("is_paid_out")

        var ledgers []struct {
                ID                int64   `db:"id" json:"id"`
                OrderID           string  `db:"order_id" json:"order_id"`
                TransactionAmount float64 `db:"transaction_amount" json:"transaction_amount"`
                PlatformFee       float64 `db:"platform_fee" json:"platform_fee"`
                AffiliateAmount   float64 `db:"affiliate_amount" json:"affiliate_amount"`
                IsPaidOut         bool    `db:"is_paid_out" json:"is_paid_out"`
                PaidOutAt         *string `db:"paid_out_at" json:"paid_out_at"`
                AffiliateFullName string  `db:"affiliate_full_name" json:"affiliate_full_name"`
                AffiliateEmail    string  `db:"affiliate_email" json:"affiliate_email"`
                EventTitle        string  `db:"event_title" json:"event_title"`
                CreatedAt         string  `db:"created_at" json:"created_at"`
        }

        query := `
                SELECT al.id, al.order_id, al.transaction_amount, al.platform_fee, 
                       al.affiliate_amount, al.is_paid_out, al.paid_out_at,
                       asub.full_name as affiliate_full_name, asub.email as affiliate_email,
                       asub.event_title, al.created_at
                FROM affiliate_ledgers al
                JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
        `
        if isPaidOut != "" </span><span class="cov0" title="0">{
                query += " WHERE al.is_paid_out = " + isPaidOut
        }</span>
        <span class="cov0" title="0">query += " ORDER BY al.created_at DESC"

        config.DB.Select(&amp;ledgers, query)

        c.JSON(http.StatusOK, gin.H{"ledgers": ledgers})</span>
}

// MarkAffiliatePaidOut - Mark ledger entry as paid
func MarkAffiliatePaidOut(c *gin.Context) <span class="cov0" title="0">{
        ledgerID := c.Param("id")

        // Get ledger and affiliate info
        var ledger struct {
                ID                    int64 `db:"id"`
                AffiliateSubmissionID int64 `db:"affiliate_submission_id"`
                IsPaidOut             bool  `db:"is_paid_out"`
        }
        err := config.DB.Get(&amp;ledger, `SELECT id, affiliate_submission_id, is_paid_out FROM affiliate_ledgers WHERE id = ?`, ledgerID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Ledger tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if ledger.IsPaidOut </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Sudah dibayar sebelumnya"})
                return
        }</span>

        // Mark as paid
        <span class="cov0" title="0">config.DB.Exec(`UPDATE affiliate_ledgers SET is_paid_out = 1, paid_out_at = NOW() WHERE id = ?`, ledgerID)

        // Notify affiliate
        var userID *int64
        config.DB.Get(&amp;userID, `SELECT user_id FROM affiliate_submissions WHERE id = ?`, ledger.AffiliateSubmissionID)
        if userID != nil </span><span class="cov0" title="0">{
                config.DB.Exec(`
                        INSERT INTO notifications (user_id, title, message)
                        VALUES (?, 'Pembayaran Diterima', 'Pembayaran affiliate Anda telah ditransfer.')
                `, *userID)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Berhasil ditandai sebagai sudah dibayar"})</span>
}

// GetAffiliateLedgerStats - Get statistics
func GetAffiliateLedgerStats(c *gin.Context) <span class="cov0" title="0">{
        var stats struct {
                TotalSubmissions    int     `db:"total_submissions" json:"total_submissions"`
                PendingSubmissions  int     `db:"pending_submissions" json:"pending_submissions"`
                ApprovedSubmissions int     `db:"approved_submissions" json:"approved_submissions"`
                RejectedSubmissions int     `db:"rejected_submissions" json:"rejected_submissions"`
                TotalRevenue        float64 `db:"total_revenue" json:"total_revenue"`
                TotalPlatformFee    float64 `db:"total_platform_fee" json:"total_platform_fee"`
                PendingPayout       float64 `db:"pending_payout" json:"pending_payout"`
                CompletedPayout     float64 `db:"completed_payout" json:"completed_payout"`
                TotalAffiliates     int     `db:"total_affiliates" json:"total_affiliates"`
        }

        config.DB.Get(&amp;stats.TotalSubmissions, `SELECT COUNT(*) FROM affiliate_submissions`)
        config.DB.Get(&amp;stats.PendingSubmissions, `SELECT COUNT(*) FROM affiliate_submissions WHERE status = 'PENDING'`)
        config.DB.Get(&amp;stats.ApprovedSubmissions, `SELECT COUNT(*) FROM affiliate_submissions WHERE status = 'APPROVED'`)
        config.DB.Get(&amp;stats.RejectedSubmissions, `SELECT COUNT(*) FROM affiliate_submissions WHERE status = 'REJECTED'`)
        config.DB.Get(&amp;stats.TotalRevenue, `SELECT COALESCE(SUM(transaction_amount), 0) FROM affiliate_ledgers`)
        config.DB.Get(&amp;stats.TotalPlatformFee, `SELECT COALESCE(SUM(platform_fee), 0) FROM affiliate_ledgers`)
        config.DB.Get(&amp;stats.PendingPayout, `SELECT COALESCE(SUM(affiliate_amount), 0) FROM affiliate_ledgers WHERE is_paid_out = 0`)
        config.DB.Get(&amp;stats.CompletedPayout, `SELECT COALESCE(SUM(affiliate_amount), 0) FROM affiliate_ledgers WHERE is_paid_out = 1`)
        config.DB.Get(&amp;stats.TotalAffiliates, `SELECT COUNT(DISTINCT ur.user_id) FROM user_roles ur JOIN roles r ON ur.role_id = r.id WHERE r.name = 'AFFILIATE'`)

        c.JSON(http.StatusOK, gin.H{"stats": stats})
}</span>

// ========================================================
// OFFICIAL ORGANIZATION MANAGEMENT
// ========================================================

// GetOfficialOrganization - Get Official org details
func GetOfficialOrganization(c *gin.Context) <span class="cov0" title="0">{
        var org struct {
                ID          int64   `db:"id" json:"id"`
                Name        string  `db:"name" json:"name"`
                Description *string `db:"description" json:"description"`
                Category    *string `db:"category" json:"category"`
                Email       *string `db:"email" json:"email"`
                LogoURL     *string `db:"logo_url" json:"logo_url"`
                TotalEvents int     `db:"total_events" json:"total_events"`
        }

        err := config.DB.Get(&amp;org, `
                SELECT o.id, o.name, o.description, o.category, o.email, o.logo_url,
                       (SELECT COUNT(*) FROM events WHERE organization_id = o.id) as total_events
                FROM organizations o
                WHERE o.is_official = 1
                LIMIT 1
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organisasi Official belum dibuat"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"organization": org})</span>
}

// UpdateOfficialOrganization - Update Official org by admin
func UpdateOfficialOrganization(c *gin.Context) <span class="cov0" title="0">{
        // First get the current org ID
        var orgID int64
        err := config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE is_official = 1 LIMIT 1`)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organisasi Official tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                Name        string `json:"name"`
                Description string `json:"description"`
                Category    string `json:"category"`
                Email       string `json:"email"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        // If name is empty, keep the old name
        <span class="cov0" title="0">if input.Name == "" </span><span class="cov0" title="0">{
                input.Name = "Official"
        }</span>

        <span class="cov0" title="0">_, err = config.DB.Exec(`
                UPDATE organizations 
                SET name = ?, description = ?, category = ?, email = ?
                WHERE id = ?
        `, input.Name, input.Description, input.Category, input.Email, orgID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mengupdate"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Organisasi berhasil diupdate"})</span>
}

// UploadOfficialOrgLogo - Upload logo for Official org
func UploadOfficialOrgLogo(c *gin.Context) <span class="cov0" title="0">{
        file, err := c.FormFile("logo")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">os.MkdirAll("uploads/logos", os.ModePerm)
        filename := fmt.Sprintf("official_%d%s", time.Now().UnixNano(), filepath.Ext(file.Filename))
        path := filepath.Join("uploads/logos", filename)

        if err := c.SaveUploadedFile(file, path); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan file"})
                return
        }</span>

        <span class="cov0" title="0">config.DB.Exec(`UPDATE organizations SET logo_url = ? WHERE is_official = 1`, path)

        c.JSON(http.StatusOK, gin.H{"message": "Logo berhasil diupload", "logo_url": path})</span>
}

// GetOfficialOrgEvents - Get all events under Official organization
func GetOfficialOrgEvents(c *gin.Context) <span class="cov0" title="0">{
        // Get Official org ID first
        var officialOrgID int64
        err := config.DB.Get(&amp;officialOrgID, `SELECT id FROM organizations WHERE is_official = 1 LIMIT 1`)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organisasi Official belum dibuat"})
                return
        }</span>

        <span class="cov0" title="0">var events []struct {
                ID                    int64   `db:"id" json:"id"`
                Title                 string  `db:"title" json:"title"`
                Description           *string `db:"description" json:"description"`
                Category              *string `db:"category" json:"category"`
                ThumbnailURL          *string `db:"thumbnail_url" json:"thumbnail_url"`
                PublishStatus         string  `db:"publish_status" json:"publish_status"`
                AffiliateSubmissionID *int64  `db:"affiliate_submission_id" json:"affiliate_submission_id"`
                SessionsCount         int     `db:"sessions_count" json:"sessions_count"`
                TotalSales            int     `db:"total_sales" json:"total_sales"`
                CreatedAt             string  `db:"created_at" json:"created_at"`
        }

        err = config.DB.Select(&amp;events, `
                SELECT 
                        e.id, e.title, e.description, e.category, e.thumbnail_url, 
                        e.publish_status, e.affiliate_submission_id, e.created_at,
                        (SELECT COUNT(*) FROM sessions WHERE event_id = e.id) as sessions_count,
                        COALESCE((SELECT COUNT(*) FROM affiliate_ledgers al 
                                  JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                                  JOIN events ev ON ev.affiliate_submission_id = asub.id
                                  WHERE ev.id = e.id), 0) as total_sales
                FROM events e
                WHERE e.organization_id = ?
                ORDER BY e.created_at DESC
        `, officialOrgID)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error fetching official events: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal memuat data"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"events": events, "organization_id": officialOrgID})</span>
}

// GetOfficialOrgEventDetail - Get single event detail with sessions
func GetOfficialOrgEventDetail(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        var event struct {
                ID                    int64   `db:"id" json:"id"`
                Title                 string  `db:"title" json:"title"`
                Description           *string `db:"description" json:"description"`
                Category              *string `db:"category" json:"category"`
                ThumbnailURL          *string `db:"thumbnail_url" json:"thumbnail_url"`
                PublishStatus         string  `db:"publish_status" json:"publish_status"`
                AffiliateSubmissionID *int64  `db:"affiliate_submission_id" json:"affiliate_submission_id"`
                CreatedAt             string  `db:"created_at" json:"created_at"`
        }

        err := config.DB.Get(&amp;event, `
                SELECT id, title, description, category, thumbnail_url, publish_status, 
                       affiliate_submission_id, created_at
                FROM events 
                WHERE id = ?
        `, eventID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan"})
                return
        }</span>

        // Get sessions
        <span class="cov0" title="0">var sessions []struct {
                ID            int64   `db:"id" json:"id"`
                Title         string  `db:"title" json:"title"`
                Description   *string `db:"description" json:"description"`
                Price         int64   `db:"price" json:"price"`
                PublishStatus string  `db:"publish_status" json:"publish_status"`
                VideosCount   int     `db:"videos_count" json:"videos_count"`
                FilesCount    int     `db:"files_count" json:"files_count"`
        }
        config.DB.Select(&amp;sessions, `
                SELECT s.id, s.title, s.description, s.price, s.publish_status,
                       (SELECT COUNT(*) FROM session_videos WHERE session_id = s.id) as videos_count,
                       (SELECT COUNT(*) FROM session_files WHERE session_id = s.id) as files_count
                FROM sessions s
                WHERE s.event_id = ?
                ORDER BY s.id ASC
        `, eventID)

        c.JSON(http.StatusOK, gin.H{"event": event, "sessions": sessions})</span>
}

// DeleteOfficialOrgEvent - Delete event from Official org
func DeleteOfficialOrgEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        // Delete sessions first
        var sessionIDs []int64
        config.DB.Select(&amp;sessionIDs, `SELECT id FROM sessions WHERE event_id = ?`, eventID)

        for _, sessionID := range sessionIDs </span><span class="cov0" title="0">{
                config.DB.Exec(`DELETE FROM session_videos WHERE session_id = ?`, sessionID)
                config.DB.Exec(`DELETE FROM session_files WHERE session_id = ?`, sessionID)
        }</span>
        <span class="cov0" title="0">config.DB.Exec(`DELETE FROM sessions WHERE event_id = ?`, eventID)

        // Delete the event
        _, err := config.DB.Exec(`DELETE FROM events WHERE id = ?`, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus event"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event berhasil dihapus"})</span>
}

// ========================================================
// OFFICIAL ORG CRUD - EDIT FUNCTIONALITY
// ========================================================

// UpdateOfficialOrgEvent - Update event title, description, category
func UpdateOfficialOrgEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        var input struct {
                Title       string `json:"title"`
                Description string `json:"description"`
                Category    string `json:"category"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                UPDATE events 
                SET title = ?, description = ?, category = ?
                WHERE id = ?
        `, input.Title, input.Description, input.Category, eventID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update event"})
                return
        }</span>

        // Also update session title if event title changed
        <span class="cov0" title="0">config.DB.Exec(`UPDATE sessions SET title = ? WHERE event_id = ?`, input.Title, eventID)

        c.JSON(http.StatusOK, gin.H{"message": "Event berhasil diupdate"})</span>
}

// UploadOfficialOrgEventThumbnail - Upload/replace event thumbnail
func UploadOfficialOrgEventThumbnail(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        file, err := c.FormFile("thumbnail")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File thumbnail diperlukan"})
                return
        }</span>

        <span class="cov0" title="0">os.MkdirAll("uploads/posters", os.ModePerm)
        filename := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), eventID, filepath.Ext(file.Filename))
        uploadPath := filepath.Join("uploads/posters", filename)

        if err := c.SaveUploadedFile(file, uploadPath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal upload thumbnail"})
                return
        }</span>

        <span class="cov0" title="0">_, err = config.DB.Exec(`UPDATE events SET thumbnail_url = ? WHERE id = ?`, uploadPath, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update thumbnail"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Thumbnail berhasil diupdate", "thumbnail_url": uploadPath})</span>
}

// UpdateOfficialOrgSession - Update session title, description, price
func UpdateOfficialOrgSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        var input struct {
                Title       string `json:"title"`
                Description string `json:"description"`
                Price       int64  `json:"price"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                UPDATE sessions 
                SET title = ?, description = ?, price = ?
                WHERE id = ?
        `, input.Title, input.Description, input.Price, sessionID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update session"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session berhasil diupdate"})</span>
}

// UpdateOfficialOrgVideo - Update video title
func UpdateOfficialOrgVideo(c *gin.Context) <span class="cov0" title="0">{
        videoID := c.Param("videoId")

        var input struct {
                Title       string `json:"title"`
                Description string `json:"description"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                UPDATE session_videos 
                SET title = ?, description = ?
                WHERE id = ?
        `, input.Title, input.Description, videoID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update video"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Video berhasil diupdate"})</span>
}

// DeleteOfficialOrgVideo - Delete a video
func DeleteOfficialOrgVideo(c *gin.Context) <span class="cov0" title="0">{
        videoID := c.Param("videoId")

        _, err := config.DB.Exec(`DELETE FROM session_videos WHERE id = ?`, videoID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal hapus video"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Video berhasil dihapus"})</span>
}

// UpdateOfficialOrgFile - Update file title
func UpdateOfficialOrgFile(c *gin.Context) <span class="cov0" title="0">{
        fileID := c.Param("fileId")

        var input struct {
                Title       string `json:"title"`
                Description string `json:"description"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                UPDATE session_files 
                SET title = ?, description = ?
                WHERE id = ?
        `, input.Title, input.Description, fileID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update file"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "File berhasil diupdate"})</span>
}

// DeleteOfficialOrgFile - Delete a file
func DeleteOfficialOrgFile(c *gin.Context) <span class="cov0" title="0">{
        fileID := c.Param("fileId")

        _, err := config.DB.Exec(`DELETE FROM session_files WHERE id = ?`, fileID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal hapus file"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "File berhasil dihapus"})</span>
}

// ========================================================
// OFFICIAL ORGANIZATION - CREATE EVENT &amp; SESSION
// ========================================================

// CreateOfficialOrgEvent - Create new event under Official org
func CreateOfficialOrgEvent(c *gin.Context) <span class="cov0" title="0">{
        var input struct {
                Title       string `json:"title" binding:"required"`
                Description string `json:"description"`
                Category    string `json:"category"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Judul wajib diisi"})
                return
        }</span>

        // Get Official org ID
        <span class="cov0" title="0">var officialOrgID int64
        err := config.DB.Get(&amp;officialOrgID, `SELECT id FROM organizations WHERE is_official = 1 LIMIT 1`)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Organisasi Official belum dibuat"})
                return
        }</span>

        // Default category
        <span class="cov0" title="0">if input.Category == "" </span><span class="cov0" title="0">{
                input.Category = "Teknologi"
        }</span>

        <span class="cov0" title="0">result, err := config.DB.Exec(`
                INSERT INTO events (organization_id, title, description, category, publish_status, created_at, updated_at)
                VALUES (?, ?, ?, ?, 'DRAFT', NOW(), NOW())
        `, officialOrgID, input.Title, input.Description, input.Category)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal membuat event"})
                return
        }</span>

        <span class="cov0" title="0">eventID, _ := result.LastInsertId()
        c.JSON(http.StatusCreated, gin.H{"message": "Event berhasil dibuat", "event_id": eventID})</span>
}

// CreateOfficialOrgSession - Create new session under Official org event
func CreateOfficialOrgSession(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        var input struct {
                Title       string `json:"title" binding:"required"`
                Description string `json:"description"`
                Price       int64  `json:"price"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Judul wajib diisi"})
                return
        }</span>

        // Get max order index
        <span class="cov0" title="0">var maxOrder int
        config.DB.Get(&amp;maxOrder, "SELECT COALESCE(MAX(order_index), 0) FROM sessions WHERE event_id = ?", eventID)

        result, err := config.DB.Exec(`
                INSERT INTO sessions (event_id, title, description, price, order_index, publish_status, created_at)
                VALUES (?, ?, ?, ?, ?, 'DRAFT', NOW())
        `, eventID, input.Title, input.Description, input.Price, maxOrder+1)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal membuat session"})
                return
        }</span>

        <span class="cov0" title="0">sessionID, _ := result.LastInsertId()
        c.JSON(http.StatusCreated, gin.H{"message": "Session berhasil dibuat", "session_id": sessionID})</span>
}

// DeleteOfficialOrgSession - Delete a session
func DeleteOfficialOrgSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        // Delete videos and files first
        config.DB.Exec(`DELETE FROM session_videos WHERE session_id = ?`, sessionID)
        config.DB.Exec(`DELETE FROM session_files WHERE session_id = ?`, sessionID)
        config.DB.Exec(`DELETE FROM purchases WHERE session_id = ?`, sessionID)

        _, err := config.DB.Exec(`DELETE FROM sessions WHERE id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal hapus session"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session berhasil dihapus"})</span>
}

// ========================================================
// OFFICIAL ORGANIZATION - PUBLISH/UNPUBLISH/SCHEDULE
// ========================================================

// PublishOfficialOrgEvent - Publish event
func PublishOfficialOrgEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        _, err := config.DB.Exec(`UPDATE events SET publish_status = 'PUBLISHED', publish_at = NULL WHERE id = ?`, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal publish event"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event berhasil dipublish", "status": "PUBLISHED"})</span>
}

// UnpublishOfficialOrgEvent - Unpublish event to draft
func UnpublishOfficialOrgEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        _, err := config.DB.Exec(`UPDATE events SET publish_status = 'DRAFT', publish_at = NULL WHERE id = ?`, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal unpublish event"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event berhasil di-draft", "status": "DRAFT"})</span>
}

// ScheduleOfficialOrgEvent - Schedule event publish
func ScheduleOfficialOrgEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        var input struct {
                PublishAt string `json:"publish_at" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Tanggal publish wajib diisi"})
                return
        }</span>

        // Parse datetime
        <span class="cov0" title="0">parsedTime, err := time.Parse("2006-01-02T15:04", input.PublishAt)
        if err != nil </span><span class="cov0" title="0">{
                parsedTime, err = time.Parse(time.RFC3339, input.PublishAt)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Format tanggal tidak valid"})
                        return
                }</span>
        }

        <span class="cov0" title="0">sqlTimeStr := parsedTime.Format("2006-01-02 15:04:05")
        _, err = config.DB.Exec(`UPDATE events SET publish_status = 'SCHEDULED', publish_at = ? WHERE id = ?`, sqlTimeStr, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal schedule event"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event berhasil dijadwalkan", "status": "SCHEDULED", "publish_at": input.PublishAt})</span>
}

// PublishOfficialOrgSession - Publish session
func PublishOfficialOrgSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        _, err := config.DB.Exec(`UPDATE sessions SET publish_status = 'PUBLISHED', publish_at = NULL WHERE id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal publish session"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session berhasil dipublish", "status": "PUBLISHED"})</span>
}

// UnpublishOfficialOrgSession - Unpublish session to draft
func UnpublishOfficialOrgSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        _, err := config.DB.Exec(`UPDATE sessions SET publish_status = 'DRAFT', publish_at = NULL WHERE id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal unpublish session"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session berhasil di-draft", "status": "DRAFT"})</span>
}

// ScheduleOfficialOrgSession - Schedule session publish
func ScheduleOfficialOrgSession(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        var input struct {
                PublishAt string `json:"publish_at" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Tanggal publish wajib diisi"})
                return
        }</span>

        <span class="cov0" title="0">parsedTime, err := time.Parse("2006-01-02T15:04", input.PublishAt)
        if err != nil </span><span class="cov0" title="0">{
                parsedTime, err = time.Parse(time.RFC3339, input.PublishAt)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Format tanggal tidak valid"})
                        return
                }</span>
        }

        <span class="cov0" title="0">sqlTimeStr := parsedTime.Format("2006-01-02 15:04:05")
        _, err = config.DB.Exec(`UPDATE sessions SET publish_status = 'SCHEDULED', publish_at = ? WHERE id = ?`, sqlTimeStr, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal schedule session"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session berhasil dijadwalkan", "status": "SCHEDULED", "publish_at": input.PublishAt})</span>
}

// ========================================================
// OFFICIAL ORGANIZATION - UPLOAD VIDEO &amp; FILE
// ========================================================

// UploadOfficialOrgSessionVideo - Upload video to session
func UploadOfficialOrgSessionVideo(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        title := c.PostForm("title")
        if title == "" </span><span class="cov0" title="0">{
                title = "Video Materi"
        }</span>
        <span class="cov0" title="0">description := c.PostForm("description")

        file, err := c.FormFile("video")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File video wajib diupload"})
                return
        }</span>

        <span class="cov0" title="0">os.MkdirAll("uploads/videos", os.ModePerm)
        filename := fmt.Sprintf("official_%d_%s%s", time.Now().UnixNano(), sessionID, filepath.Ext(file.Filename))
        filePath := filepath.Join("uploads/videos", filename)

        if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan video"})
                return
        }</span>

        // Get max order index
        <span class="cov0" title="0">var maxOrder int
        config.DB.Get(&amp;maxOrder, "SELECT COALESCE(MAX(order_index), 0) FROM session_videos WHERE session_id = ?", sessionID)

        result, err := config.DB.Exec(`
                INSERT INTO session_videos (session_id, title, description, video_url, order_index)
                VALUES (?, ?, ?, ?, ?)
        `, sessionID, title, description, filePath, maxOrder+1)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal simpan ke database"})
                return
        }</span>

        <span class="cov0" title="0">videoID, _ := result.LastInsertId()
        c.JSON(http.StatusCreated, gin.H{"message": "Video berhasil diupload", "video_id": videoID, "video_url": filePath})</span>
}

// UploadOfficialOrgSessionFile - Upload file/module to session
func UploadOfficialOrgSessionFile(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        title := c.PostForm("title")
        if title == "" </span><span class="cov0" title="0">{
                title = "Modul Materi"
        }</span>
        <span class="cov0" title="0">description := c.PostForm("description")

        file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File wajib diupload"})
                return
        }</span>

        <span class="cov0" title="0">os.MkdirAll("uploads/files", os.ModePerm)
        filename := fmt.Sprintf("official_%d_%s%s", time.Now().UnixNano(), sessionID, filepath.Ext(file.Filename))
        filePath := filepath.Join("uploads/files", filename)

        if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan file"})
                return
        }</span>

        // Get max order index
        <span class="cov0" title="0">var maxOrder int
        config.DB.Get(&amp;maxOrder, "SELECT COALESCE(MAX(order_index), 0) FROM session_files WHERE session_id = ?", sessionID)

        result, err := config.DB.Exec(`
                INSERT INTO session_files (session_id, title, description, file_url, order_index)
                VALUES (?, ?, ?, ?, ?)
        `, sessionID, title, description, filePath, maxOrder+1)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal simpan ke database"})
                return
        }</span>

        <span class="cov0" title="0">fileID, _ := result.LastInsertId()
        c.JSON(http.StatusCreated, gin.H{"message": "File berhasil diupload", "file_id": fileID, "file_url": filePath})</span>
}

// ========================================================
// OFFICIAL ORGANIZATION - QUIZ &amp; CERTIFICATE
// ========================================================

// GetOfficialOrgCertificateSettings - Get certificate settings for Official org event
func GetOfficialOrgCertificateSettings(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        var settings struct {
                ID              int64   `db:"id" json:"id"`
                EventID         int64   `db:"event_id" json:"event_id"`
                IsEnabled       bool    `db:"is_enabled" json:"is_enabled"`
                MinScorePercent int     `db:"min_score_percent" json:"min_score_percent"`
                CertTitle       *string `db:"certificate_title" json:"certificate_title"`
        }

        err := config.DB.Get(&amp;settings, `
                SELECT id, event_id, is_enabled, min_score_percent, certificate_title
                FROM event_certificates WHERE event_id = ?
        `, eventID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "settings": gin.H{
                                "event_id":          eventID,
                                "is_enabled":        false,
                                "min_score_percent": 80,
                                "certificate_title": nil,
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"settings": settings})</span>
}

// UpdateOfficialOrgCertificateSettings - Update certificate settings
func UpdateOfficialOrgCertificateSettings(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventId")

        var input struct {
                IsEnabled       bool    `json:"is_enabled"`
                MinScorePercent int     `json:"min_score_percent"`
                CertTitle       *string `json:"certificate_title"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">if input.MinScorePercent &lt; 1 || input.MinScorePercent &gt; 100 </span><span class="cov0" title="0">{
                input.MinScorePercent = 80
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                INSERT INTO event_certificates (event_id, is_enabled, min_score_percent, certificate_title)
                VALUES (?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE is_enabled = VALUES(is_enabled), 
                                        min_score_percent = VALUES(min_score_percent),
                                        certificate_title = VALUES(certificate_title)
        `, eventID, input.IsEnabled, input.MinScorePercent, input.CertTitle)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Pengaturan sertifikat berhasil disimpan"})</span>
}

// GetOfficialOrgSessionQuiz - Get quiz for Official org session
func GetOfficialOrgSessionQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        var quiz struct {
                ID        int64  `db:"id" json:"id"`
                SessionID int64  `db:"session_id" json:"session_id"`
                Title     string `db:"title" json:"title"`
                IsEnabled bool   `db:"is_enabled" json:"is_enabled"`
        }

        err := config.DB.Get(&amp;quiz, `SELECT id, session_id, title, is_enabled FROM session_quizzes WHERE session_id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"quiz": nil, "questions": []interface{}{}})
                return
        }</span>

        <span class="cov0" title="0">var questions []struct {
                ID            int64   `db:"id" json:"id"`
                QuestionText  string  `db:"question_text" json:"question_text"`
                OptionA       string  `db:"option_a" json:"option_a"`
                OptionB       string  `db:"option_b" json:"option_b"`
                OptionC       *string `db:"option_c" json:"option_c"`
                OptionD       *string `db:"option_d" json:"option_d"`
                CorrectOption string  `db:"correct_option" json:"correct_option"`
                OrderIndex    int     `db:"order_index" json:"order_index"`
        }
        config.DB.Select(&amp;questions, `SELECT id, question_text, option_a, option_b, option_c, option_d, correct_option, order_index FROM quiz_questions WHERE quiz_id = ? ORDER BY order_index`, quiz.ID)

        c.JSON(http.StatusOK, gin.H{"quiz": quiz, "questions": questions})</span>
}

// SaveOfficialOrgSessionQuiz - Save quiz for Official org session
func SaveOfficialOrgSessionQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        var input struct {
                Title     string `json:"title"`
                IsEnabled bool   `json:"is_enabled"`
                Questions []struct {
                        QuestionText  string  `json:"question_text"`
                        OptionA       string  `json:"option_a"`
                        OptionB       string  `json:"option_b"`
                        OptionC       *string `json:"option_c"`
                        OptionD       *string `json:"option_d"`
                        CorrectOption string  `json:"correct_option"`
                } `json:"questions"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">if len(input.Questions) &gt; 10 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Maksimal 10 pertanyaan"})
                return
        }</span>

        // Upsert quiz
        <span class="cov0" title="0">result, err := config.DB.Exec(`
                INSERT INTO session_quizzes (session_id, title, is_enabled)
                VALUES (?, ?, ?)
                ON DUPLICATE KEY UPDATE title = VALUES(title), is_enabled = VALUES(is_enabled)
        `, sessionID, input.Title, input.IsEnabled)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan kuis"})
                return
        }</span>

        <span class="cov0" title="0">var quizID int64
        config.DB.Get(&amp;quizID, "SELECT id FROM session_quizzes WHERE session_id = ?", sessionID)
        if quizID == 0 </span><span class="cov0" title="0">{
                quizID, _ = result.LastInsertId()
        }</span>

        // Delete old questions and insert new
        <span class="cov0" title="0">config.DB.Exec("DELETE FROM quiz_questions WHERE quiz_id = ?", quizID)

        for i, q := range input.Questions </span><span class="cov0" title="0">{
                config.DB.Exec(`
                        INSERT INTO quiz_questions (quiz_id, question_text, option_a, option_b, option_c, option_d, correct_option, order_index)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                `, quizID, q.QuestionText, q.OptionA, q.OptionB, q.OptionC, q.OptionD, q.CorrectOption, i+1)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Kuis berhasil disimpan", "quiz_id": quizID})</span>
}

// DeleteOfficialOrgSessionQuiz - Delete quiz
func DeleteOfficialOrgSessionQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        config.DB.Exec("DELETE FROM session_quizzes WHERE session_id = ?", sessionID)
        c.JSON(http.StatusOK, gin.H{"message": "Kuis berhasil dihapus"})
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
)

// ================================
// ADMIN: GET ALL ORGANIZATIONS
// ================================
func GetAllOrganizations(c *gin.Context) <span class="cov0" title="0">{
        type OrgWithOwner struct {
                ID          int64  `db:"id" json:"id"`
                Name        string `db:"name" json:"name"`
                Category    string `db:"category" json:"category"`
                Description string `db:"description" json:"description"`
                LogoURL     string `db:"logo_url" json:"logo_url"`
                Email       string `db:"email" json:"email"`
                Phone       string `db:"phone" json:"phone"`
                Website     string `db:"website" json:"website"`
                OwnerID     int64  `db:"owner_id" json:"owner_id"`
                OwnerName   string `db:"owner_name" json:"owner_name"`
                OwnerEmail  string `db:"owner_email" json:"owner_email"`
                EventCount  int    `db:"event_count" json:"event_count"`
        }

        var organizations []OrgWithOwner
        err := config.DB.Select(&amp;organizations, `
                SELECT 
                        o.id, o.name, 
                        COALESCE(o.category, '') as category,
                        COALESCE(o.description, '') as description,
                        COALESCE(o.logo_url, '') as logo_url,
                        COALESCE(o.email, '') as email,
                        COALESCE(o.phone, '') as phone,
                        COALESCE(o.website, '') as website,
                        o.owner_user_id as owner_id,
                        u.name as owner_name,
                        u.email as owner_email,
                        (SELECT COUNT(*) FROM events WHERE organization_id = o.id) as event_count
                FROM organizations o
                JOIN users u ON o.owner_user_id = u.id
                ORDER BY o.id DESC
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch organizations"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"organizations": organizations})</span>
}

// ================================
// ADMIN: GET ORGANIZATION DETAIL
// ================================
func GetOrganizationDetailAdmin(c *gin.Context) <span class="cov0" title="0">{
        orgID := c.Param("id")

        // 1. Get organization info
        type OrgInfo struct {
                ID          int64  `db:"id" json:"id"`
                Name        string `db:"name" json:"name"`
                Category    string `db:"category" json:"category"`
                Description string `db:"description" json:"description"`
                LogoURL     string `db:"logo_url" json:"logo_url"`
                Email       string `db:"email" json:"email"`
                Phone       string `db:"phone" json:"phone"`
                Website     string `db:"website" json:"website"`
                OwnerID     int64  `db:"owner_id" json:"owner_id"`
                OwnerName   string `db:"owner_name" json:"owner_name"`
                OwnerEmail  string `db:"owner_email" json:"owner_email"`
        }

        var org OrgInfo
        err := config.DB.Get(&amp;org, `
                SELECT 
                        o.id, o.name, 
                        COALESCE(o.category, '') as category,
                        COALESCE(o.description, '') as description,
                        COALESCE(o.logo_url, '') as logo_url,
                        COALESCE(o.email, '') as email,
                        COALESCE(o.phone, '') as phone,
                        COALESCE(o.website, '') as website,
                        o.owner_user_id as owner_id,
                        u.name as owner_name,
                        u.email as owner_email
                FROM organizations o
                JOIN users u ON o.owner_user_id = u.id
                WHERE o.id = ?
        `, orgID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organization not found"})
                return
        }</span>

        // 2. Get events
        <span class="cov0" title="0">type EventInfo struct {
                ID            int64  `db:"id" json:"id"`
                Title         string `db:"title" json:"title"`
                ThumbnailURL  string `db:"thumbnail_url" json:"thumbnail_url"`
                PublishStatus string `db:"publish_status" json:"publish_status"`
        }

        var events []EventInfo
        config.DB.Select(&amp;events, `
                SELECT id, title, COALESCE(thumbnail_url, '') as thumbnail_url, 
                       COALESCE(publish_status, 'DRAFT') as publish_status
                FROM events 
                WHERE organization_id = ?
                ORDER BY id DESC
        `, orgID)

        // 3. Get sessions for each event
        type SessionInfo struct {
                ID            int64  `db:"id" json:"id"`
                EventID       int64  `db:"event_id" json:"event_id"`
                Title         string `db:"title" json:"title"`
                Price         int64  `db:"price" json:"price"`
                PublishStatus string `db:"publish_status" json:"publish_status"`
        }

        var sessions []SessionInfo
        config.DB.Select(&amp;sessions, `
                SELECT s.id, s.event_id, s.title, COALESCE(s.price, 0) as price,
                       COALESCE(s.publish_status, 'DRAFT') as publish_status
                FROM sessions s
                JOIN events e ON s.event_id = e.id
                WHERE e.organization_id = ?
                ORDER BY s.event_id, s.order_index
        `, orgID)

        c.JSON(http.StatusOK, gin.H{
                "organization": org,
                "events":       events,
                "sessions":     sessions,
        })</span>
}

// ================================
// ADMIN: GET SESSION MEDIA (Bypass purchase)
// ================================
func GetSessionMediaAdmin(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionId")

        // Get videos
        type VideoInfo struct {
                ID       int64  `db:"id" json:"id"`
                VideoURL string `db:"video_url" json:"video_url"`
                Title    string `db:"title" json:"title"`
        }

        var videos []VideoInfo
        config.DB.Select(&amp;videos, `
                SELECT id, video_url, COALESCE(title, video_url) as title
                FROM session_videos
                WHERE session_id = ?
                ORDER BY order_index, id
        `, sessionID)

        // Get files
        type FileInfo struct {
                ID      int64  `db:"id" json:"id"`
                FileURL string `db:"file_url" json:"file_url"`
                Title   string `db:"title" json:"title"`
        }

        var files []FileInfo
        config.DB.Select(&amp;files, `
                SELECT id, file_url, COALESCE(title, file_url) as title
                FROM session_files
                WHERE session_id = ?
                ORDER BY order_index, id
        `, sessionID)

        c.JSON(http.StatusOK, gin.H{
                "videos": videos,
                "files":  files,
        })
}</span>

// ================================
// ADMIN: UPDATE ORGANIZATION
// ================================
type UpdateOrgRequest struct {
        Name        string `json:"name"`
        Description string `json:"description"`
        Category    string `json:"category"`
        Email       string `json:"email"`
        Phone       string `json:"phone"`
        Website     string `json:"website"`
        Reason      string `json:"reason"` // Alasan perubahan
}

func UpdateOrganizationByAdmin(c *gin.Context) <span class="cov0" title="0">{
        orgID := c.Param("id")

        var req UpdateOrgRequest
        if c.ShouldBindJSON(&amp;req) != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                UPDATE organizations 
                SET name=?, description=?, category=?, email=?, phone=?, website=?
                WHERE id=?
        `, req.Name, req.Description, req.Category, req.Email, req.Phone, req.Website, orgID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update organization"})
                return
        }</span>

        // Notify owner about update
        <span class="cov0" title="0">var ownerID int64
        config.DB.Get(&amp;ownerID, "SELECT owner_user_id FROM organizations WHERE id = ?", orgID)
        if ownerID &gt; 0 </span><span class="cov0" title="0">{
                message := "Admin telah memperbarui informasi organisasi \"" + req.Name + "\"."
                if req.Reason != "" </span><span class="cov0" title="0">{
                        message += " Alasan: " + req.Reason
                }</span>
                <span class="cov0" title="0">CreateNotification(
                        ownerID,
                        "organization_updated",
                        "🏢 Organisasi Diperbarui",
                        message,
                )</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Organization updated successfully"})</span>
}

// ================================
// ADMIN: DELETE ORGANIZATION
// ================================
type DeleteOrgRequest struct {
        Reason string `json:"reason"` // Alasan penghapusan
}

func DeleteOrganization(c *gin.Context) <span class="cov0" title="0">{
        orgID := c.Param("id")

        var req DeleteOrgRequest
        c.ShouldBindJSON(&amp;req)

        // Get org info for notification
        var orgInfo struct {
                Name    string `db:"name"`
                OwnerID int64  `db:"owner_user_id"`
        }
        config.DB.Get(&amp;orgInfo, "SELECT name, owner_user_id FROM organizations WHERE id = ?", orgID)

        // Notify owner BEFORE deletion
        if orgInfo.OwnerID &gt; 0 </span><span class="cov0" title="0">{
                message := "Organisasi \"" + orgInfo.Name + "\" telah dihapus oleh admin."
                if req.Reason != "" </span><span class="cov0" title="0">{
                        message += " Alasan: " + req.Reason
                }</span>
                <span class="cov0" title="0">CreateNotification(
                        orgInfo.OwnerID,
                        "organization_deleted",
                        "🗑️ Organisasi Dihapus",
                        message,
                )</span>
        }

        // Delete organization (cascade will handle events, sessions, etc.)
        <span class="cov0" title="0">_, err := config.DB.Exec("DELETE FROM organizations WHERE id = ?", orgID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete organization"})
                return
        }</span>

        // Remove ORGANIZATION role from owner
        <span class="cov0" title="0">config.DB.Exec(`
                DELETE FROM user_roles 
                WHERE user_id = ? AND role_id = (SELECT id FROM roles WHERE name = 'ORGANIZATION')
        `, orgInfo.OwnerID)

        // Add back USER role
        config.DB.Exec(`
                INSERT INTO user_roles (user_id, role_id) 
                SELECT ?, id FROM roles WHERE name = 'USER'
        `, orgInfo.OwnerID)

        c.JSON(http.StatusOK, gin.H{"message": "Organization deleted successfully"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
        "BACKEND/models"
)

// ================================
// ADMIN: REVIEW APPLICATION
// ================================

type ReviewOrganizationRequest struct {
        Status string `json:"status" binding:"required"` // APPROVED / REJECTED
        Note   string `json:"note"`
}

func ReviewOrganizationApplication(c *gin.Context) <span class="cov0" title="0">{

        appID := c.Param("id")
        adminID := c.GetInt64("user_id")

        var req ReviewOrganizationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        // Ambil data application
        <span class="cov0" title="0">var application models.OrganizationApplication
        err := config.DB.Get(&amp;application,
                `SELECT id, user_id, org_name, 
                 COALESCE(org_description, '') AS org_description, 
                 COALESCE(org_category, '') AS org_category, 
                 COALESCE(org_logo_url, '') AS org_logo_url, 
                 COALESCE(org_email, '') AS org_email, 
                 COALESCE(org_phone, '') AS org_phone, 
                 COALESCE(org_website, '') AS org_website,
                 COALESCE(reason, '') AS reason, 
                 COALESCE(social_media, '') AS social_media, 
                 status, reviewed_by, reviewed_at, 
                 COALESCE(review_note, '') AS review_note, 
                 submitted_at
                 FROM organization_applications WHERE id = ?`,
                appID,
        )

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Application not found"})
                return
        }</span>

        // Jika APPROVED → buat ORGANIZATION &amp; update role user
        <span class="cov0" title="0">if req.Status == "APPROVED" </span><span class="cov0" title="0">{

                // Insert ke tabel organizations
                _, err := config.DB.Exec(`
                        INSERT INTO organizations 
                        (owner_user_id, name, description, category, logo_url, email, phone, website, social_link)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                `,
                        application.UserID,
                        application.OrgName,
                        application.OrgDescription,
                        application.OrgCategory,
                        application.OrgLogoURL,
                        application.OrgEmail,
                        application.OrgPhone,
                        application.OrgWebsite,
                        application.SocialMedia,
                )

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create organization"})
                        return
                }</span>

                // Update role → ORGANIZATION (role_id = 2)
                <span class="cov0" title="0">_, err = config.DB.Exec(`
                        UPDATE user_roles SET role_id = 2 WHERE user_id = ?
                `, application.UserID)

                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user role"})
                        return
                }</span>
        }

        // Update status pengajuan
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                UPDATE organization_applications
                SET status = ?, reviewed_by = ?, reviewed_at = ?, review_note = ?
                WHERE id = ?
        `,
                req.Status,
                adminID,
                time.Now(),
                req.Note,
                appID,
        )

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update application"})
                return
        }</span>

        // Create notification for user
        <span class="cov0" title="0">if req.Status == "APPROVED" </span><span class="cov0" title="0">{
                CreateNotification(
                        application.UserID,
                        "application_approved",
                        "🎉 Pengajuan Disetujui!",
                        "Selamat! Pengajuan organisasi \""+application.OrgName+"\" telah disetujui. Anda sekarang dapat membuat event.",
                )
        }</span> else<span class="cov0" title="0"> if req.Status == "REJECTED" </span><span class="cov0" title="0">{
                message := "Pengajuan organisasi \"" + application.OrgName + "\" ditolak."
                if req.Note != "" </span><span class="cov0" title="0">{
                        message += " Alasan: " + req.Note
                }</span>
                <span class="cov0" title="0">CreateNotification(
                        application.UserID,
                        "application_rejected",
                        "❌ Pengajuan Ditolak",
                        message,
                )</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Application reviewed successfully",
                "status":  req.Status,
        })</span>
}

// =======================================
// ADMIN: GET ALL ORGANIZATION APPLICATIONS
// =======================================

type ApplicationWithUser struct {
        models.OrganizationApplication
        UserName       string  `db:"user_name" json:"user_name"`
        UserEmail      string  `db:"user_email" json:"user_email"`
        UserProfileImg *string `db:"user_profile_img" json:"user_profile_img"`
}

func GetAllOrganizationApplications(c *gin.Context) <span class="cov0" title="0">{

        var applications []ApplicationWithUser

        err := config.DB.Select(&amp;applications, `
                SELECT 
                        oa.id, oa.user_id, oa.org_name, 
                        COALESCE(oa.org_description, '') AS org_description, 
                        COALESCE(oa.org_category, '') AS org_category, 
                        COALESCE(oa.org_logo_url, '') AS org_logo_url, 
                        COALESCE(oa.org_email, '') AS org_email, 
                        COALESCE(oa.org_phone, '') AS org_phone, 
                        COALESCE(oa.org_website, '') AS org_website,
                        COALESCE(oa.reason, '') AS reason, 
                        COALESCE(oa.social_media, '') AS social_media, 
                        COALESCE(oa.bank_name, '') AS bank_name, 
                        COALESCE(oa.bank_account, '') AS bank_account, 
                        COALESCE(oa.bank_account_name, '') AS bank_account_name,
                        oa.status, oa.reviewed_by, oa.reviewed_at, 
                        COALESCE(oa.review_note, '') AS review_note, 
                        oa.submitted_at,
                        COALESCE(u.name, '') AS user_name,
                        COALESCE(u.email, '') AS user_email,
                        u.profile_img AS user_profile_img
                FROM organization_applications oa
                LEFT JOIN users u ON oa.user_id = u.id
                ORDER BY oa.submitted_at DESC
        `)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error fetching applications:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch applications: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"applications": applications})</span>
}

// =======================================
// ADMIN: GET SINGLE APPLICATION DETAIL
// =======================================
func GetOrganizationApplicationByID(c *gin.Context) <span class="cov0" title="0">{

        id := c.Param("id")

        var application ApplicationWithUser

        err := config.DB.Get(&amp;application, `
                SELECT 
                        oa.*,
                        u.name AS user_name,
                        u.email AS user_email,
                        u.profile_img AS user_profile_img
                FROM organization_applications oa
                LEFT JOIN users u ON oa.user_id = u.id
                WHERE oa.id = ?
        `, id)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Application not found"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"application": application})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "time"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ===============================================
// AD BANNERS MANAGEMENT (Admin)
// ===============================================

// GetAllAds - List all ad banners (Admin)
// GET /admin/ads
func GetAllAds(c *gin.Context) <span class="cov0" title="0">{
        var ads []struct {
                ID         int64      `db:"id" json:"id"`
                Title      string     `db:"title" json:"title"`
                ImageURL   string     `db:"image_url" json:"image_url"`
                TargetURL  *string    `db:"target_url" json:"target_url"`
                Placement  string     `db:"placement" json:"placement"`
                StartDate  *time.Time `db:"start_date" json:"start_date"`
                EndDate    *time.Time `db:"end_date" json:"end_date"`
                IsActive   bool       `db:"is_active" json:"is_active"`
                OrderIndex int        `db:"order_index" json:"order_index"`
                CreatedAt  time.Time  `db:"created_at" json:"created_at"`
        }

        err := config.DB.Select(&amp;ads, `
                SELECT id, title, image_url, target_url, placement, 
                        start_date, end_date, is_active, order_index, created_at
                FROM ad_banners
                ORDER BY placement, order_index, created_at DESC
        `)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get ads"})
                return
        }</span>

        <span class="cov0" title="0">if ads == nil </span><span class="cov0" title="0">{
                ads = []struct {
                        ID         int64      `db:"id" json:"id"`
                        Title      string     `db:"title" json:"title"`
                        ImageURL   string     `db:"image_url" json:"image_url"`
                        TargetURL  *string    `db:"target_url" json:"target_url"`
                        Placement  string     `db:"placement" json:"placement"`
                        StartDate  *time.Time `db:"start_date" json:"start_date"`
                        EndDate    *time.Time `db:"end_date" json:"end_date"`
                        IsActive   bool       `db:"is_active" json:"is_active"`
                        OrderIndex int        `db:"order_index" json:"order_index"`
                        CreatedAt  time.Time  `db:"created_at" json:"created_at"`
                }{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, ads)</span>
}

// CreateAdBanner - Create new ad banner
// POST /admin/ads
func CreateAdBanner(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        title := c.PostForm("title")
        targetURL := c.PostForm("target_url")
        placement := c.PostForm("placement")
        startDate := c.PostForm("start_date")
        endDate := c.PostForm("end_date")

        if title == "" || placement == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "title dan placement diperlukan"})
                return
        }</span>

        // Validate placement
        <span class="cov0" title="0">validPlacements := map[string]bool{
                "BANNER_SLIDER": true,
                "SIDEBAR_LEFT":  true,
                "SIDEBAR_RIGHT": true,
                "HERO_SECTION":  true,
        }
        if !validPlacements[placement] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "placement harus BANNER_SLIDER, SIDEBAR_LEFT, SIDEBAR_RIGHT, atau HERO_SECTION"})
                return
        }</span>

        // Handle image upload
        <span class="cov0" title="0">file, err := c.FormFile("image")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Image file diperlukan"})
                return
        }</span>

        // Save image
        <span class="cov0" title="0">ext := filepath.Ext(file.Filename)
        filename := fmt.Sprintf("ad_%d_%s%s", time.Now().UnixNano(), uuid.New().String()[:8], ext)
        savePath := filepath.Join("uploads", "ads", filename)
        os.MkdirAll(filepath.Dir(savePath), 0755)

        if err := c.SaveUploadedFile(file, savePath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal upload gambar"})
                return
        }</span>

        // Insert to DB
        <span class="cov0" title="0">var startDateSQL, endDateSQL interface{}
        if startDate != "" </span><span class="cov0" title="0">{
                startDateSQL = startDate
        }</span>
        <span class="cov0" title="0">if endDate != "" </span><span class="cov0" title="0">{
                endDateSQL = endDate
        }</span>

        <span class="cov0" title="0">result, err := config.DB.Exec(`
                INSERT INTO ad_banners (title, image_url, target_url, placement, start_date, end_date, created_by)
                VALUES (?, ?, ?, ?, ?, ?, ?)
        `, title, savePath, targetURL, placement, startDateSQL, endDateSQL, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal membuat banner: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">adID, _ := result.LastInsertId()
        c.JSON(http.StatusOK, gin.H{
                "message": "Banner berhasil dibuat",
                "id":      adID,
        })</span>
}

// UpdateAdBanner - Update ad banner
// PUT /admin/ads/:id
func UpdateAdBanner(c *gin.Context) <span class="cov0" title="0">{
        adID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        title := c.PostForm("title")
        targetURL := c.PostForm("target_url")
        placement := c.PostForm("placement")
        startDate := c.PostForm("start_date")
        endDate := c.PostForm("end_date")
        isActive := c.PostForm("is_active")
        orderIndex := c.PostForm("order_index")

        // Check if exists
        var exists int
        config.DB.Get(&amp;exists, "SELECT COUNT(*) FROM ad_banners WHERE id = ?", adID)
        if exists == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Banner tidak ditemukan"})
                return
        }</span>

        // Handle image update if provided
        <span class="cov0" title="0">file, err := c.FormFile("image")
        if err == nil &amp;&amp; file != nil </span><span class="cov0" title="0">{
                ext := filepath.Ext(file.Filename)
                filename := fmt.Sprintf("ad_%d_%s%s", time.Now().UnixNano(), uuid.New().String()[:8], ext)
                savePath := filepath.Join("uploads", "ads", filename)
                os.MkdirAll(filepath.Dir(savePath), 0755)

                if err := c.SaveUploadedFile(file, savePath); err == nil </span><span class="cov0" title="0">{
                        config.DB.Exec("UPDATE ad_banners SET image_url = ? WHERE id = ?", savePath, adID)
                }</span>
        }

        // Update other fields
        <span class="cov0" title="0">if title != "" </span><span class="cov0" title="0">{
                config.DB.Exec("UPDATE ad_banners SET title = ? WHERE id = ?", title, adID)
        }</span>
        <span class="cov0" title="0">if targetURL != "" </span><span class="cov0" title="0">{
                config.DB.Exec("UPDATE ad_banners SET target_url = ? WHERE id = ?", targetURL, adID)
        }</span>
        <span class="cov0" title="0">if placement != "" </span><span class="cov0" title="0">{
                config.DB.Exec("UPDATE ad_banners SET placement = ? WHERE id = ?", placement, adID)
        }</span>
        <span class="cov0" title="0">if startDate != "" </span><span class="cov0" title="0">{
                config.DB.Exec("UPDATE ad_banners SET start_date = ? WHERE id = ?", startDate, adID)
        }</span>
        <span class="cov0" title="0">if endDate != "" </span><span class="cov0" title="0">{
                config.DB.Exec("UPDATE ad_banners SET end_date = ? WHERE id = ?", endDate, adID)
        }</span>
        <span class="cov0" title="0">if isActive != "" </span><span class="cov0" title="0">{
                active := isActive == "true" || isActive == "1"
                config.DB.Exec("UPDATE ad_banners SET is_active = ? WHERE id = ?", active, adID)
        }</span>
        <span class="cov0" title="0">if orderIndex != "" </span><span class="cov0" title="0">{
                order, _ := strconv.Atoi(orderIndex)
                config.DB.Exec("UPDATE ad_banners SET order_index = ? WHERE id = ?", order, adID)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Banner berhasil diupdate"})</span>
}

// DeleteAdBanner - Delete ad banner
// DELETE /admin/ads/:id
func DeleteAdBanner(c *gin.Context) <span class="cov0" title="0">{
        adID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        // Get image path for cleanup
        var imagePath string
        config.DB.Get(&amp;imagePath, "SELECT image_url FROM ad_banners WHERE id = ?", adID)

        result, _ := config.DB.Exec("DELETE FROM ad_banners WHERE id = ?", adID)
        affected, _ := result.RowsAffected()
        if affected == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Banner tidak ditemukan"})
                return
        }</span>

        // Remove image file
        <span class="cov0" title="0">if imagePath != "" </span><span class="cov0" title="0">{
                os.Remove(imagePath)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Banner berhasil dihapus"})</span>
}

// ===============================================
// PUBLIC ADS API
// ===============================================

// GetPublicAds - Get active ads by placement
// GET /api/ads?placement=HOME_SLIDER
func GetPublicAds(c *gin.Context) <span class="cov0" title="0">{
        placement := c.Query("placement")

        query := `
                SELECT id, title, image_url, target_url, placement, order_index
                FROM ad_banners
                WHERE is_active = 1
                AND (start_date IS NULL OR start_date &lt;= CURDATE())
                AND (end_date IS NULL OR end_date &gt;= CURDATE())
        `
        args := []interface{}{}

        if placement != "" </span><span class="cov0" title="0">{
                query += " AND placement = ?"
                args = append(args, placement)
        }</span>

        <span class="cov0" title="0">query += " ORDER BY order_index, created_at DESC"

        var ads []struct {
                ID         int64   `db:"id" json:"id"`
                Title      string  `db:"title" json:"title"`
                ImageURL   string  `db:"image_url" json:"image_url"`
                TargetURL  *string `db:"target_url" json:"target_url"`
                Placement  string  `db:"placement" json:"placement"`
                OrderIndex int     `db:"order_index" json:"order_index"`
        }

        err := config.DB.Select(&amp;ads, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get ads"})
                return
        }</span>

        <span class="cov0" title="0">if ads == nil </span><span class="cov0" title="0">{
                ads = []struct {
                        ID         int64   `db:"id" json:"id"`
                        Title      string  `db:"title" json:"title"`
                        ImageURL   string  `db:"image_url" json:"image_url"`
                        TargetURL  *string `db:"target_url" json:"target_url"`
                        Placement  string  `db:"placement" json:"placement"`
                        OrderIndex int     `db:"order_index" json:"order_index"`
                }{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, ads)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "BACKEND/config"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ApplyAffiliate - User applies to become an affiliate
func ApplyAffiliate(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var input struct {
                Motivation string `json:"motivation"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        // Check if user already has AFFILIATE role
        <span class="cov8" title="1">var hasRole int
        config.DB.Get(&amp;hasRole, `
                SELECT COUNT(*) FROM user_roles ur
                JOIN roles r ON ur.role_id = r.id
                WHERE ur.user_id = ? AND r.name = 'AFFILIATE'
        `, userID)
        if hasRole &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah menjadi affiliate"})
                return
        }</span>

        // Check if already applied
        <span class="cov8" title="1">var existingApp int
        config.DB.Get(&amp;existingApp, `SELECT COUNT(*) FROM affiliate_applications WHERE user_id = ?`, userID)
        if existingApp &gt; 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah mengajukan permohonan affiliate"})
                return
        }</span>

        // Insert application
        <span class="cov8" title="1">_, err := config.DB.Exec(`
                INSERT INTO affiliate_applications (user_id, motivation, status)
                VALUES (?, ?, 'PENDING')
        `, userID, input.Motivation)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan permohonan"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{"message": "Permohonan affiliate berhasil dikirim"})</span>
}

// GetMyAffiliateApplication - Check user's affiliate application status
func GetMyAffiliateApplication(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var app struct {
                ID         int64   `db:"id" json:"id"`
                Status     string  `db:"status" json:"status"`
                Motivation *string `db:"motivation" json:"motivation"`
                ReviewNote *string `db:"review_note" json:"review_note"`
                CreatedAt  string  `db:"created_at" json:"created_at"`
        }

        err := config.DB.Get(&amp;app, `
                SELECT id, status, motivation, review_note, created_at
                FROM affiliate_applications WHERE user_id = ?
        `, userID)

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Belum ada permohonan"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"application": app})</span>
}

// GetAffiliateDashboard - Dashboard stats for affiliate
func GetAffiliateDashboard(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var stats struct {
                TotalEvents     int     `db:"total_events" json:"total_events"`
                ApprovedEvents  int     `db:"approved_events" json:"approved_events"`
                PendingEvents   int     `db:"pending_events" json:"pending_events"`
                TotalEarnings   float64 `db:"total_earnings" json:"total_earnings"`
                PendingEarnings float64 `db:"pending_earnings" json:"pending_earnings"`
                TotalSales      int     `db:"total_sales" json:"total_sales"`
        }

        // Get submission stats
        config.DB.Get(&amp;stats.TotalEvents, `
                SELECT COUNT(*) FROM affiliate_submissions WHERE user_id = ?
        `, userID)
        config.DB.Get(&amp;stats.ApprovedEvents, `
                SELECT COUNT(*) FROM affiliate_submissions WHERE user_id = ? AND status = 'APPROVED'
        `, userID)
        config.DB.Get(&amp;stats.PendingEvents, `
                SELECT COUNT(*) FROM affiliate_submissions WHERE user_id = ? AND status = 'PENDING'
        `, userID)

        // Get earnings stats
        config.DB.Get(&amp;stats.TotalEarnings, `
                SELECT COALESCE(SUM(al.affiliate_amount), 0)
                FROM affiliate_ledgers al
                JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                WHERE asub.user_id = ? AND al.is_paid_out = 1
        `, userID)
        config.DB.Get(&amp;stats.PendingEarnings, `
                SELECT COALESCE(SUM(al.affiliate_amount), 0)
                FROM affiliate_ledgers al
                JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                WHERE asub.user_id = ? AND al.is_paid_out = 0
        `, userID)
        config.DB.Get(&amp;stats.TotalSales, `
                SELECT COUNT(*)
                FROM affiliate_ledgers al
                JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                WHERE asub.user_id = ?
        `, userID)

        c.JSON(http.StatusOK, gin.H{"stats": stats})
}</span>

// GetAffiliateEvents - List affiliate's submitted events with earnings
func GetAffiliateEvents(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var events []struct {
                ID              int64   `db:"id" json:"id"`
                EventTitle      string  `db:"event_title" json:"event_title"`
                EventPrice      int64   `db:"event_price" json:"event_price"`
                Status          string  `db:"status" json:"status"`
                PosterURL       *string `db:"poster_url" json:"poster_url"`
                CreatedAt       string  `db:"created_at" json:"created_at"`
                TotalSales      int     `db:"total_sales" json:"total_sales"`
                TotalEarnings   float64 `db:"total_earnings" json:"total_earnings"`
                PendingEarnings float64 `db:"pending_earnings" json:"pending_earnings"`
        }

        err := config.DB.Select(&amp;events, `
                SELECT 
                        asub.id,
                        asub.event_title,
                        asub.event_price,
                        asub.status,
                        asub.poster_url,
                        asub.created_at,
                        COALESCE((SELECT COUNT(*) FROM affiliate_ledgers al WHERE al.affiliate_submission_id = asub.id), 0) as total_sales,
                        COALESCE((SELECT SUM(al.affiliate_amount) FROM affiliate_ledgers al WHERE al.affiliate_submission_id = asub.id AND al.is_paid_out = 1), 0) as total_earnings,
                        COALESCE((SELECT SUM(al.affiliate_amount) FROM affiliate_ledgers al WHERE al.affiliate_submission_id = asub.id AND al.is_paid_out = 0), 0) as pending_earnings
                FROM affiliate_submissions asub
                WHERE asub.user_id = ?
                ORDER BY asub.created_at DESC
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal memuat data"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"events": events})</span>
}

// SubmitAffiliateEvent - Affiliate submits new event for review
// FLOW: Insert ke affiliate_submissions dulu, admin yang create event saat approve
func SubmitAffiliateEvent(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        fmt.Printf("[SubmitAffiliate] ========== START SUBMIT ==========\n")
        fmt.Printf("[SubmitAffiliate] User ID: %d\n", userID)

        // Parse form data
        eventTitle := c.PostForm("event_title")
        eventDescription := c.PostForm("event_description")
        eventPriceStr := c.PostForm("event_price")
        eventCategory := c.PostForm("event_category")
        if eventCategory == "" </span><span class="cov0" title="0">{
                eventCategory = "Teknologi"
        }</span>

        <span class="cov0" title="0">fmt.Printf("[SubmitAffiliate] Event: %s, Price: %s, Category: %s\n", eventTitle, eventPriceStr, eventCategory)

        if eventTitle == "" </span><span class="cov0" title="0">{
                fmt.Printf("[SubmitAffiliate] ERROR: event_title is empty\n")
                c.JSON(http.StatusBadRequest, gin.H{"error": "Judul event wajib diisi"})
                return
        }</span>

        <span class="cov0" title="0">eventPrice, _ := strconv.ParseInt(eventPriceStr, 10, 64)

        // Handle poster upload
        var posterURL string
        posterFile, err := c.FormFile("poster")
        if err == nil </span><span class="cov0" title="0">{
                os.MkdirAll("uploads/posters", os.ModePerm)
                posterFilename := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), uuid.New().String()[:8], filepath.Ext(posterFile.Filename))
                posterPath := filepath.Join("uploads/posters", posterFilename)
                if err := c.SaveUploadedFile(posterFile, posterPath); err == nil </span><span class="cov0" title="0">{
                        posterURL = posterPath
                }</span>
        }

        // Handle multiple video uploads (max 3)
        <span class="cov0" title="0">type uploadedMaterial struct {
                Title       string
                Description string
                URL         string
        }
        var uploadedVideos []uploadedMaterial
        form, _ := c.MultipartForm()
        os.MkdirAll("uploads/affiliate_videos", os.ModePerm)
        os.MkdirAll("uploads/affiliate_files", os.ModePerm)

        if form != nil </span><span class="cov0" title="0">{
                videoFiles := form.File["videos"]
                videoTitles := c.PostFormArray("video_titles")
                videoDescriptions := c.PostFormArray("video_descriptions")

                for i, videoFile := range videoFiles </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                break</span> // Max 3 videos
                        }
                        <span class="cov0" title="0">videoFilename := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), uuid.New().String()[:8], filepath.Ext(videoFile.Filename))
                        videoPath := filepath.Join("uploads/affiliate_videos", videoFilename)
                        if err := c.SaveUploadedFile(videoFile, videoPath); err == nil </span><span class="cov0" title="0">{
                                title := ""
                                if i &lt; len(videoTitles) </span><span class="cov0" title="0">{
                                        title = videoTitles[i]
                                }</span>
                                <span class="cov0" title="0">if title == "" </span><span class="cov0" title="0">{
                                        title = fmt.Sprintf("Video %d", i+1)
                                }</span>
                                <span class="cov0" title="0">description := ""
                                if i &lt; len(videoDescriptions) </span><span class="cov0" title="0">{
                                        description = videoDescriptions[i]
                                }</span>
                                <span class="cov0" title="0">uploadedVideos = append(uploadedVideos, uploadedMaterial{Title: title, Description: description, URL: videoPath})</span>
                        }
                }
        }

        // Handle multiple file uploads (max 3)
        <span class="cov0" title="0">var uploadedFiles []uploadedMaterial
        if form != nil </span><span class="cov0" title="0">{
                moduleFiles := form.File["files"]
                fileTitles := c.PostFormArray("file_titles")
                fileDescriptions := c.PostFormArray("file_descriptions")

                for i, moduleFile := range moduleFiles </span><span class="cov0" title="0">{
                        if i &gt;= 3 </span><span class="cov0" title="0">{
                                break</span> // Max 3 files
                        }
                        <span class="cov0" title="0">moduleFilename := fmt.Sprintf("%d_%s%s", time.Now().UnixNano(), uuid.New().String()[:8], filepath.Ext(moduleFile.Filename))
                        modulePath := filepath.Join("uploads/affiliate_files", moduleFilename)
                        if err := c.SaveUploadedFile(moduleFile, modulePath); err == nil </span><span class="cov0" title="0">{
                                title := ""
                                if i &lt; len(fileTitles) </span><span class="cov0" title="0">{
                                        title = fileTitles[i]
                                }</span>
                                <span class="cov0" title="0">if title == "" </span><span class="cov0" title="0">{
                                        title = fmt.Sprintf("Modul %d", i+1)
                                }</span>
                                <span class="cov0" title="0">description := ""
                                if i &lt; len(fileDescriptions) </span><span class="cov0" title="0">{
                                        description = fileDescriptions[i]
                                }</span>
                                <span class="cov0" title="0">uploadedFiles = append(uploadedFiles, uploadedMaterial{Title: title, Description: description, URL: modulePath})</span>
                        }
                }
        }

        // Validate: at least one material required
        <span class="cov0" title="0">if len(uploadedVideos) == 0 &amp;&amp; len(uploadedFiles) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Upload minimal 1 materi (video atau file)"})
                return
        }</span>

        // Get additional form fields
        <span class="cov0" title="0">phone := c.PostForm("phone")
        bankName := c.PostForm("bank_name")
        bankAccountNumber := c.PostForm("bank_account_number")
        bankAccountHolder := c.PostForm("bank_account_holder")

        // Validate required contact and bank info
        if phone == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No. Telepon wajib diisi"})
                return
        }</span>
        <span class="cov0" title="0">if bankName == "" || bankAccountNumber == "" || bankAccountHolder == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Informasi rekening bank wajib diisi lengkap"})
                return
        }</span>

        // Get user info
        <span class="cov0" title="0">var user struct {
                Name  string `db:"name"`
                Email string `db:"email"`
        }
        config.DB.Get(&amp;user, `SELECT name, email FROM users WHERE id = ?`, userID)

        // First video/file for backward compatibility with main table
        var firstVideoURL, firstVideoTitle, firstFileURL, firstFileTitle string
        if len(uploadedVideos) &gt; 0 </span><span class="cov0" title="0">{
                firstVideoURL = uploadedVideos[0].URL
                firstVideoTitle = uploadedVideos[0].Title
        }</span>
        <span class="cov0" title="0">if len(uploadedFiles) &gt; 0 </span><span class="cov0" title="0">{
                firstFileURL = uploadedFiles[0].URL
                firstFileTitle = uploadedFiles[0].Title
        }</span>

        // ============================================
        // INSERT INTO affiliate_submissions (PENDING)
        // ============================================
        <span class="cov0" title="0">result, err := config.DB.Exec(`
                INSERT INTO affiliate_submissions 
                (user_id, full_name, email, phone, event_title, event_description, event_price, event_category,
                 poster_url, video_url, video_title, file_url, file_title, 
                 bank_name, bank_account_number, bank_account_holder, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'PENDING')
        `, userID, user.Name, user.Email, phone, eventTitle, eventDescription, eventPrice, eventCategory,
                posterURL, firstVideoURL, firstVideoTitle, firstFileURL, firstFileTitle,
                bankName, bankAccountNumber, bankAccountHolder)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[SubmitAffiliate] Error creating submission: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan pengajuan"})
                return
        }</span>

        <span class="cov0" title="0">submissionID, _ := result.LastInsertId()

        // Insert all videos into affiliate_submission_videos table
        for _, video := range uploadedVideos </span><span class="cov0" title="0">{
                _, err := config.DB.Exec(`
                        INSERT INTO affiliate_submission_videos (submission_id, title, url)
                        VALUES (?, ?, ?)
                `, submissionID, video.Title, video.URL)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[SubmitAffiliate] Error inserting video: %v\n", err)
                }</span>
        }

        // Insert all files into affiliate_submission_files table
        <span class="cov0" title="0">for _, file := range uploadedFiles </span><span class="cov0" title="0">{
                _, err := config.DB.Exec(`
                        INSERT INTO affiliate_submission_files (submission_id, title, url)
                        VALUES (?, ?, ?)
                `, submissionID, file.Title, file.URL)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[SubmitAffiliate] Error inserting file: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">fmt.Printf("[SubmitAffiliate] ✅ Created submission=%d with %d videos and %d files\n",
                submissionID, len(uploadedVideos), len(uploadedFiles))

        c.JSON(http.StatusCreated, gin.H{
                "message":       "Event berhasil diajukan untuk review",
                "submission_id": submissionID,
        })</span>
}

// GetAffiliateSubmissionDetail - Get detail of a specific submission
func GetAffiliateSubmissionDetail(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        submissionID := c.Param("id")

        var submission struct {
                ID               int64   `db:"id" json:"id"`
                EventTitle       string  `db:"event_title" json:"event_title"`
                EventDescription *string `db:"event_description" json:"event_description"`
                EventPrice       int64   `db:"event_price" json:"event_price"`
                Status           string  `db:"status" json:"status"`
                PosterURL        *string `db:"poster_url" json:"poster_url"`
                VideoURL         *string `db:"video_url" json:"video_url"`
                VideoTitle       *string `db:"video_title" json:"video_title"`
                FileURL          *string `db:"file_url" json:"file_url"`
                FileTitle        *string `db:"file_title" json:"file_title"`
                ReviewNote       *string `db:"review_note" json:"review_note"`
                CreatedAt        string  `db:"created_at" json:"created_at"`
        }

        err := config.DB.Get(&amp;submission, `
                SELECT id, event_title, event_description, event_price, status,
                       poster_url, video_url, video_title, file_url, file_title,
                       review_note, created_at
                FROM affiliate_submissions 
                WHERE id = ? AND user_id = ?
        `, submissionID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Pengajuan tidak ditemukan"})
                return
        }</span>

        // Get sales data
        <span class="cov0" title="0">var sales []struct {
                OrderID           string  `db:"order_id" json:"order_id"`
                TransactionAmount float64 `db:"transaction_amount" json:"transaction_amount"`
                AffiliateAmount   float64 `db:"affiliate_amount" json:"affiliate_amount"`
                IsPaidOut         bool    `db:"is_paid_out" json:"is_paid_out"`
                CreatedAt         string  `db:"created_at" json:"created_at"`
        }
        config.DB.Select(&amp;sales, `
                SELECT order_id, transaction_amount, affiliate_amount, is_paid_out, created_at
                FROM affiliate_ledgers
                WHERE affiliate_submission_id = ?
                ORDER BY created_at DESC
        `, submissionID)

        c.JSON(http.StatusOK, gin.H{
                "submission": submission,
                "sales":      sales,
        })</span>
}

// ===============================================
// AFFILIATE BALANCE &amp; WITHDRAWAL
// ===============================================

// GetAffiliateBalance - Get balance summary for affiliate
func GetAffiliateBalance(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var balance struct {
                TotalEarned      float64 `db:"total_earned" json:"total_earned"`
                TotalWithdrawn   float64 `db:"total_withdrawn" json:"total_withdrawn"`
                AvailableBalance float64 `json:"available_balance"`
        }

        // Get from affiliate_balances table
        err := config.DB.Get(&amp;balance, `
                SELECT COALESCE(total_earned, 0) as total_earned, 
                       COALESCE(total_withdrawn, 0) as total_withdrawn
                FROM affiliate_balances WHERE user_id = ?
        `, userID)

        if err != nil </span><span class="cov8" title="1">{
                // No balance record yet - calculate from ledger
                config.DB.Get(&amp;balance.TotalEarned, `
                        SELECT COALESCE(SUM(al.affiliate_amount), 0)
                        FROM affiliate_ledgers al
                        JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                        WHERE asub.user_id = ?
                `, userID)
                balance.TotalWithdrawn = 0
        }</span>

        <span class="cov8" title="1">balance.AvailableBalance = balance.TotalEarned - balance.TotalWithdrawn

        c.JSON(http.StatusOK, gin.H{"balance": balance})</span>
}

// SimulateWithdraw - Simulate instant withdrawal (no admin approval)
func SimulateWithdraw(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var input struct {
                Amount        float64 `json:"amount" binding:"required"`
                PaymentMethod string  `json:"payment_method" binding:"required"` // BANK, DANA, GOPAY, OVO, SHOPEEPAY
                AccountName   string  `json:"account_name" binding:"required"`
                AccountNumber string  `json:"account_number" binding:"required"`
                BankName      string  `json:"bank_name"` // Only for BANK
        }

        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak lengkap"})
                return
        }</span>

        // Minimum withdrawal Rp 50,000
        <span class="cov8" title="1">if input.Amount &lt; 50000 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Minimal penarikan Rp 50.000"})
                return
        }</span>

        // Get current balance
        <span class="cov8" title="1">var balance struct {
                TotalEarned    float64 `db:"total_earned"`
                TotalWithdrawn float64 `db:"total_withdrawn"`
        }
        err := config.DB.Get(&amp;balance, `
                SELECT COALESCE(total_earned, 0) as total_earned, 
                       COALESCE(total_withdrawn, 0) as total_withdrawn
                FROM affiliate_balances WHERE user_id = ?
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                // No balance record - check ledger
                config.DB.Get(&amp;balance.TotalEarned, `
                        SELECT COALESCE(SUM(al.affiliate_amount), 0)
                        FROM affiliate_ledgers al
                        JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                        WHERE asub.user_id = ?
                `, userID)
        }</span>

        <span class="cov8" title="1">availableBalance := balance.TotalEarned - balance.TotalWithdrawn

        if input.Amount &gt; availableBalance </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Saldo tidak cukup. Saldo tersedia: Rp %.0f", availableBalance)})
                return
        }</span>

        // Update balance - simulate instant withdrawal
        <span class="cov8" title="1">_, err = config.DB.Exec(`
                INSERT INTO affiliate_balances (user_id, total_earned, total_withdrawn, balance)
                VALUES (?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE 
                        total_withdrawn = total_withdrawn + ?,
                        balance = total_earned - (total_withdrawn + ?)
        `, userID, balance.TotalEarned, input.Amount, balance.TotalEarned-input.Amount, input.Amount, input.Amount)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[WITHDRAW] Error updating balance: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal memproses penarikan"})
                return
        }</span>

        // Record transaction
        <span class="cov8" title="1">withdrawRef := fmt.Sprintf("WD-%d-%d", time.Now().Unix(), userID)
        description := fmt.Sprintf("Penarikan ke %s - %s (%s)", input.PaymentMethod, input.AccountName, input.AccountNumber)
        if input.PaymentMethod == "BANK" &amp;&amp; input.BankName != "" </span><span class="cov8" title="1">{
                description = fmt.Sprintf("Penarikan ke %s %s - %s (%s)", input.BankName, input.PaymentMethod, input.AccountName, input.AccountNumber)
        }</span>

        <span class="cov8" title="1">config.DB.Exec(`
                INSERT INTO financial_transactions (transaction_type, entity_type, entity_id, amount, description, reference_id)
                VALUES ('WITHDRAWAL', 'AFFILIATE', ?, ?, ?, ?)
        `, userID, input.Amount, description, withdrawRef)

        fmt.Printf("[WITHDRAW] ✅ User %d withdrew Rp %.0f to %s\n", userID, input.Amount, input.PaymentMethod)

        c.JSON(http.StatusOK, gin.H{
                "message":     "Penarikan berhasil diproses",
                "amount":      input.Amount,
                "reference":   withdrawRef,
                "new_balance": availableBalance - input.Amount,
        })</span>
}

// GetWithdrawalHistory - Get withdrawal transaction history
func GetWithdrawalHistory(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var transactions []struct {
                ID          int64   `db:"id" json:"id"`
                Amount      float64 `db:"amount" json:"amount"`
                Description string  `db:"description" json:"description"`
                ReferenceID string  `db:"reference_id" json:"reference_id"`
                CreatedAt   string  `db:"created_at" json:"created_at"`
        }

        config.DB.Select(&amp;transactions, `
                SELECT id, amount, description, reference_id, created_at
                FROM financial_transactions
                WHERE entity_type = 'AFFILIATE' AND entity_id = ? AND transaction_type = 'WITHDRAWAL'
                ORDER BY created_at DESC
                LIMIT 50
        `, userID)

        c.JSON(http.StatusOK, gin.H{"transactions": transactions})
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
)

// ===============================================
// AFFILIATE PARTNERSHIP - NEW FLOW
// User joins to promote organization's event
// ===============================================

// JoinAffiliateEvent - User requests to join as affiliate for an event
// POST /affiliate/join/:eventId
func JoinAffiliateEvent(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        eventID, err := strconv.ParseInt(c.Param("eventId"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid event ID"})
                return
        }</span>

        // Check profile completeness - user must complete profile first
        <span class="cov0" title="0">var profile struct {
                Name      string  `db:"name"`
                Phone     *string `db:"phone"`
                Address   *string `db:"address"`
                Gender    *string `db:"gender"`
                Birthdate *string `db:"birthdate"`
        }
        config.DB.Get(&amp;profile, "SELECT name, phone, address, gender, birthdate FROM users WHERE id = ?", userID)

        var missingFields []string
        if profile.Name == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "nama")
        }</span>
        <span class="cov0" title="0">if profile.Phone == nil || *profile.Phone == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "nomor telepon")
        }</span>
        <span class="cov0" title="0">if profile.Address == nil || *profile.Address == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "alamat")
        }</span>
        <span class="cov0" title="0">if profile.Gender == nil || *profile.Gender == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "jenis kelamin")
        }</span>
        <span class="cov0" title="0">if profile.Birthdate == nil || *profile.Birthdate == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "tanggal lahir")
        }</span>

        <span class="cov0" title="0">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":              "Lengkapi profil Anda terlebih dahulu sebelum menjadi affiliate",
                        "missing_fields":     missingFields,
                        "profile_incomplete": true,
                })
                return
        }</span>

        // Parse input
        <span class="cov0" title="0">var input struct {
                BankName        string `json:"bank_name" binding:"required"`
                BankAccount     string `json:"bank_account" binding:"required"`
                BankAccountName string `json:"bank_account_name" binding:"required"`
                SocialMedia     string `json:"social_media" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Lengkapi semua data: nama bank, nomor rekening, atas nama, dan media sosial"})
                return
        }</span>

        // Check if event exists and get org info
        <span class="cov0" title="0">var eventInfo struct {
                ID             int64  `db:"id"`
                Title          string `db:"title"`
                OrganizationID int64  `db:"organization_id"`
                IsOfficial     bool   `db:"is_official"`
        }
        err = config.DB.Get(&amp;eventInfo, `
                SELECT e.id, e.title, e.organization_id, COALESCE(o.is_official, 0) as is_official
                FROM events e
                JOIN organizations o ON e.organization_id = o.id
                WHERE e.id = ? AND e.publish_status = 'PUBLISHED'
        `, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan atau belum dipublish"})
                return
        }</span>

        // Official org events cannot have affiliates
        <span class="cov0" title="0">if eventInfo.IsOfficial </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Event official tidak bisa dipromosikan affiliate"})
                return
        }</span>

        // Anti-spam: Check if user sent any request in last 24 hours
        <span class="cov0" title="0">var lastRequestTime *time.Time
        config.DB.Get(&amp;lastRequestTime, `
                SELECT created_at FROM affiliate_partnerships 
                WHERE user_id = ? 
                ORDER BY created_at DESC LIMIT 1
        `, userID)
        if lastRequestTime != nil &amp;&amp; time.Since(*lastRequestTime) &lt; 24*time.Hour </span><span class="cov0" title="0">{
                c.JSON(http.StatusTooManyRequests, gin.H{"error": "Anda hanya bisa mengirim 1 permintaan per 24 jam. Coba lagi besok."})
                return
        }</span>

        // Check if user already joined this event
        <span class="cov0" title="0">var existingCount int
        config.DB.Get(&amp;existingCount, `
                SELECT COUNT(*) FROM affiliate_partnerships 
                WHERE user_id = ? AND event_id = ?
        `, userID, eventID)
        if existingCount &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah mendaftar sebagai affiliate untuk event ini"})
                return
        }</span>

        // Check if user is the org owner (cannot be affiliate of own event)
        <span class="cov0" title="0">var orgOwnerID int64
        config.DB.Get(&amp;orgOwnerID, "SELECT owner_user_id FROM organizations WHERE id = ?", eventInfo.OrganizationID)
        if orgOwnerID == userID </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda tidak bisa menjadi affiliate untuk event sendiri"})
                return
        }</span>

        // Get user phone from profile
        <span class="cov0" title="0">var userPhone string
        config.DB.Get(&amp;userPhone, "SELECT COALESCE(phone, '') FROM users WHERE id = ?", userID)

        // Generate temporary unique code (will be finalized on approval)
        tempCode := generateAffiliateCode(eventInfo.Title, userID)

        // Insert partnership request with all data
        _, err = config.DB.Exec(`
                INSERT INTO affiliate_partnerships (user_id, event_id, organization_id, unique_code, phone, bank_name, bank_account, bank_account_name, social_media, status)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'PENDING')
        `, userID, eventID, eventInfo.OrganizationID, tempCode, userPhone, input.BankName, input.BankAccount, input.BankAccountName, input.SocialMedia)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mendaftar affiliate: " + err.Error()})
                return
        }</span>

        // Notify org owner
        <span class="cov0" title="0">CreateNotification(
                orgOwnerID,
                "affiliate_request",
                "👥 Permintaan Affiliate Baru",
                fmt.Sprintf("Ada user baru yang ingin menjadi affiliate untuk event \"%s\"", eventInfo.Title),
        )

        c.JSON(http.StatusOK, gin.H{
                "message": "Permintaan affiliate berhasil dikirim. Menunggu persetujuan organisasi.",
        })</span>
}

// GetMyPartnerships - Get all affiliate partnerships for current user
// GET /affiliate/partnerships
func GetMyPartnerships(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        var partnerships []struct {
                ID                   int64      `db:"id" json:"id"`
                EventID              int64      `db:"event_id" json:"event_id"`
                EventTitle           string     `db:"event_title" json:"event_title"`
                OrganizationName     string     `db:"organization_name" json:"organization_name"`
                UniqueCode           string     `db:"unique_code" json:"unique_code"`
                CommissionPercentage float64    `db:"commission_percentage" json:"commission_percentage"`
                Status               string     `db:"status" json:"status"`
                CreatedAt            time.Time  `db:"created_at" json:"created_at"`
                ApprovedAt           *time.Time `db:"approved_at" json:"approved_at"`
        }

        err := config.DB.Select(&amp;partnerships, `
                SELECT ap.id, ap.event_id, e.title as event_title, 
                        o.name as organization_name, ap.unique_code,
                        ap.commission_percentage, ap.status, ap.created_at, ap.approved_at
                FROM affiliate_partnerships ap
                JOIN events e ON ap.event_id = e.id
                JOIN organizations o ON ap.organization_id = o.id
                WHERE ap.user_id = ?
                ORDER BY ap.created_at DESC
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get partnerships"})
                return
        }</span>

        <span class="cov0" title="0">if partnerships == nil </span><span class="cov0" title="0">{
                partnerships = []struct {
                        ID                   int64      `db:"id" json:"id"`
                        EventID              int64      `db:"event_id" json:"event_id"`
                        EventTitle           string     `db:"event_title" json:"event_title"`
                        OrganizationName     string     `db:"organization_name" json:"organization_name"`
                        UniqueCode           string     `db:"unique_code" json:"unique_code"`
                        CommissionPercentage float64    `db:"commission_percentage" json:"commission_percentage"`
                        Status               string     `db:"status" json:"status"`
                        CreatedAt            time.Time  `db:"created_at" json:"created_at"`
                        ApprovedAt           *time.Time `db:"approved_at" json:"approved_at"`
                }{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, partnerships)</span>
}

// ===============================================
// ORGANIZATION - MANAGE AFFILIATE REQUESTS
// ===============================================

// GetAffiliateRequests - Get pending affiliate requests for org's events
// GET /organization/affiliate-requests
func GetAffiliateRequests(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get org ID owned by user
        var orgID int64
        err := config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organisasi tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">var requests []struct {
                ID                   int64     `db:"id" json:"id"`
                UserID               int64     `db:"user_id" json:"user_id"`
                UserName             string    `db:"user_name" json:"user_name"`
                UserEmail            string    `db:"user_email" json:"user_email"`
                UserPhone            *string   `db:"user_phone" json:"user_phone"`
                EventID              int64     `db:"event_id" json:"event_id"`
                EventTitle           string    `db:"event_title" json:"event_title"`
                UniqueCode           string    `db:"unique_code" json:"unique_code"`
                CommissionPercentage float64   `db:"commission_percentage" json:"commission_percentage"`
                Phone                *string   `db:"phone" json:"phone"`
                BankName             *string   `db:"bank_name" json:"bank_name"`
                BankAccount          *string   `db:"bank_account" json:"bank_account"`
                BankAccountName      *string   `db:"bank_account_name" json:"bank_account_name"`
                SocialMedia          *string   `db:"social_media" json:"social_media"`
                Status               string    `db:"status" json:"status"`
                CreatedAt            time.Time `db:"created_at" json:"created_at"`
        }

        err = config.DB.Select(&amp;requests, `
                SELECT ap.id, ap.user_id, u.name as user_name, u.email as user_email, u.phone as user_phone,
                        ap.event_id, e.title as event_title, ap.unique_code, ap.commission_percentage,
                        ap.phone, ap.bank_name, ap.bank_account, ap.bank_account_name, ap.social_media,
                        ap.status, ap.created_at
                FROM affiliate_partnerships ap
                JOIN users u ON ap.user_id = u.id
                JOIN events e ON ap.event_id = e.id
                WHERE ap.organization_id = ?
                ORDER BY ap.status = 'PENDING' DESC, ap.created_at DESC
        `, orgID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get requests: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if requests == nil </span><span class="cov0" title="0">{
                requests = make([]struct {
                        ID                   int64     `db:"id" json:"id"`
                        UserID               int64     `db:"user_id" json:"user_id"`
                        UserName             string    `db:"user_name" json:"user_name"`
                        UserEmail            string    `db:"user_email" json:"user_email"`
                        UserPhone            *string   `db:"user_phone" json:"user_phone"`
                        EventID              int64     `db:"event_id" json:"event_id"`
                        EventTitle           string    `db:"event_title" json:"event_title"`
                        UniqueCode           string    `db:"unique_code" json:"unique_code"`
                        CommissionPercentage float64   `db:"commission_percentage" json:"commission_percentage"`
                        Phone                *string   `db:"phone" json:"phone"`
                        BankName             *string   `db:"bank_name" json:"bank_name"`
                        BankAccount          *string   `db:"bank_account" json:"bank_account"`
                        BankAccountName      *string   `db:"bank_account_name" json:"bank_account_name"`
                        SocialMedia          *string   `db:"social_media" json:"social_media"`
                        Status               string    `db:"status" json:"status"`
                        CreatedAt            time.Time `db:"created_at" json:"created_at"`
                }, 0)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, requests)</span>
}

// ApproveAffiliateRequest - Approve affiliate and set commission
// PUT /organization/affiliate-requests/:id/approve
func ApproveAffiliateRequest(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        requestID, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request ID"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                CommissionPercentage float64 `json:"commission_percentage"`
                UniqueCode           string  `json:"unique_code"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                // Default 10% if not specified
                input.CommissionPercentage = 10.0
        }</span>
        <span class="cov0" title="0">if input.CommissionPercentage &lt; 1 || input.CommissionPercentage &gt; 50 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Komisi harus antara 1% - 50%"})
                return
        }</span>

        // Check ownership
        <span class="cov0" title="0">var orgID int64
        config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)

        // Get partnership info
        var partnership struct {
                ID             int64  `db:"id"`
                UserID         int64  `db:"user_id"`
                EventID        int64  `db:"event_id"`
                OrganizationID int64  `db:"organization_id"`
                Status         string `db:"status"`
        }
        err = config.DB.Get(&amp;partnership, "SELECT id, user_id, event_id, organization_id, status FROM affiliate_partnerships WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Request tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if partnership.OrganizationID != orgID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Anda tidak memiliki akses ke request ini"})
                return
        }</span>

        <span class="cov0" title="0">if partnership.Status != "PENDING" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Request sudah diproses sebelumnya"})
                return
        }</span>

        // Get event title for code generation
        <span class="cov0" title="0">var eventTitle string
        config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", partnership.EventID)

        // Use custom code or generate one
        finalCode := strings.TrimSpace(input.UniqueCode)
        if finalCode == "" </span><span class="cov0" title="0">{
                finalCode = generateAffiliateCode(eventTitle, partnership.UserID)
        }</span> else<span class="cov0" title="0"> {
                // Check if custom code already exists
                var existingCount int
                config.DB.Get(&amp;existingCount, "SELECT COUNT(*) FROM affiliate_partnerships WHERE unique_code = ? AND id != ?", finalCode, requestID)
                if existingCount &gt; 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Kode unik sudah digunakan, pilih kode lain"})
                        return
                }</span>
        }

        // Update partnership
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                UPDATE affiliate_partnerships 
                SET status = 'APPROVED', 
                        commission_percentage = ?,
                        unique_code = ?,
                        approved_at = NOW(),
                        approved_by = ?
                WHERE id = ?
        `, input.CommissionPercentage, finalCode, userID, requestID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal approve: " + err.Error()})
                return
        }</span>

        // Ensure user has AFFILIATE role
        <span class="cov0" title="0">config.DB.Exec(`
                INSERT IGNORE INTO user_roles (user_id, role_id)
                SELECT ?, id FROM roles WHERE name = 'AFFILIATE'
        `, partnership.UserID)

        // Notify affiliate
        CreateNotification(
                partnership.UserID,
                "affiliate_approved",
                "✅ Permintaan Affiliate Disetujui!",
                fmt.Sprintf("Anda sekarang affiliate untuk event \"%s\". Kode promo Anda: %s (Komisi: %.0f%%)", eventTitle, finalCode, input.CommissionPercentage),
        )

        c.JSON(http.StatusOK, gin.H{
                "message":     "Affiliate berhasil disetujui",
                "unique_code": finalCode,
                "commission":  input.CommissionPercentage,
        })</span>
}

// RejectAffiliateRequest - Reject affiliate request
// PUT /organization/affiliate-requests/:id/reject
func RejectAffiliateRequest(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        requestID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        var orgID int64
        config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)

        var partnership struct {
                UserID         int64 `db:"user_id"`
                OrganizationID int64 `db:"organization_id"`
                EventID        int64 `db:"event_id"`
        }
        config.DB.Get(&amp;partnership, "SELECT user_id, organization_id, event_id FROM affiliate_partnerships WHERE id = ?", requestID)

        if partnership.OrganizationID != orgID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        <span class="cov0" title="0">config.DB.Exec("UPDATE affiliate_partnerships SET status = 'REJECTED' WHERE id = ?", requestID)

        var eventTitle string
        config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", partnership.EventID)

        CreateNotification(
                partnership.UserID,
                "affiliate_rejected",
                "❌ Permintaan Affiliate Ditolak",
                fmt.Sprintf("Permintaan affiliate untuk event \"%s\" ditolak", eventTitle),
        )

        c.JSON(http.StatusOK, gin.H{"message": "Request ditolak"})</span>
}

// UpdateAffiliatePartnership - Update affiliate code, commission, and expiry
// PUT /organization/affiliate-requests/:id/update
func UpdateAffiliatePartnership(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        requestID, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request ID"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                UniqueCode           string  `json:"unique_code"`
                CommissionPercentage float64 `json:"commission_percentage"`
                ExpiresAt            string  `json:"expires_at"` // Format: "2026-01-31" or empty
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        // Get org ID
        <span class="cov0" title="0">var orgID int64
        config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)

        // Get partnership
        var partnership struct {
                ID             int64 `db:"id"`
                UserID         int64 `db:"user_id"`
                OrganizationID int64 `db:"organization_id"`
                EventID        int64 `db:"event_id"`
        }
        err = config.DB.Get(&amp;partnership, "SELECT id, user_id, organization_id, event_id FROM affiliate_partnerships WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Affiliate tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if partnership.OrganizationID != orgID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        // Validate commission
        <span class="cov0" title="0">if input.CommissionPercentage &lt; 1 || input.CommissionPercentage &gt; 50 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Komisi harus antara 1% - 50%"})
                return
        }</span>

        // Check unique code uniqueness
        <span class="cov0" title="0">if input.UniqueCode != "" </span><span class="cov0" title="0">{
                var existingCount int
                config.DB.Get(&amp;existingCount, "SELECT COUNT(*) FROM affiliate_partnerships WHERE unique_code = ? AND id != ?", input.UniqueCode, requestID)
                if existingCount &gt; 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Kode unik sudah digunakan"})
                        return
                }</span>
        }

        // Update
        <span class="cov0" title="0">if input.ExpiresAt != "" </span><span class="cov0" title="0">{
                _, err = config.DB.Exec(`
                        UPDATE affiliate_partnerships 
                        SET unique_code = ?, commission_percentage = ?, expires_at = ?
                        WHERE id = ?
                `, input.UniqueCode, input.CommissionPercentage, input.ExpiresAt, requestID)
        }</span> else<span class="cov0" title="0"> {
                _, err = config.DB.Exec(`
                        UPDATE affiliate_partnerships 
                        SET unique_code = ?, commission_percentage = ?, expires_at = NULL
                        WHERE id = ?
                `, input.UniqueCode, input.CommissionPercentage, requestID)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update: " + err.Error()})
                return
        }</span>

        // Notify affiliate
        <span class="cov0" title="0">var eventTitle string
        config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", partnership.EventID)
        CreateNotification(
                partnership.UserID,
                "affiliate_updated",
                "📝 Kode Affiliate Diperbarui",
                fmt.Sprintf("Kode affiliate untuk event \"%s\" telah diperbarui menjadi: %s", eventTitle, input.UniqueCode),
        )

        c.JSON(http.StatusOK, gin.H{"message": "Affiliate berhasil diupdate"})</span>
}

// ToggleAffiliateActive - Activate or deactivate affiliate
// PUT /organization/affiliate-requests/:id/toggle-active
func ToggleAffiliateActive(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        requestID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        var orgID int64
        config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)

        var partnership struct {
                UserID         int64 `db:"user_id"`
                OrganizationID int64 `db:"organization_id"`
                EventID        int64 `db:"event_id"`
                IsActive       bool  `db:"is_active"`
        }
        err := config.DB.Get(&amp;partnership, "SELECT user_id, organization_id, event_id, COALESCE(is_active, 1) as is_active FROM affiliate_partnerships WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Affiliate tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if partnership.OrganizationID != orgID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        <span class="cov0" title="0">newStatus := !partnership.IsActive
        config.DB.Exec("UPDATE affiliate_partnerships SET is_active = ? WHERE id = ?", newStatus, requestID)

        var eventTitle string
        config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", partnership.EventID)

        statusText := "sudah tidak aktif"
        if newStatus </span><span class="cov0" title="0">{
                statusText = "aktif kembali"
        }</span>

        <span class="cov0" title="0">CreateNotification(
                partnership.UserID,
                "affiliate_status_changed",
                "🔔 Status Affiliate Berubah",
                fmt.Sprintf("Kode affiliate untuk event \"%s\" telah %s", eventTitle, statusText),
        )

        c.JSON(http.StatusOK, gin.H{
                "message":   fmt.Sprintf("Affiliate berhasil %s", statusText),
                "is_active": newStatus,
        })</span>
}

// DeleteAffiliatePartnership - Remove affiliate partnership
// DELETE /organization/affiliate-requests/:id
func DeleteAffiliatePartnership(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        requestID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        var orgID int64
        config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)

        var partnership struct {
                UserID         int64 `db:"user_id"`
                OrganizationID int64 `db:"organization_id"`
                EventID        int64 `db:"event_id"`
        }
        err := config.DB.Get(&amp;partnership, "SELECT user_id, organization_id, event_id FROM affiliate_partnerships WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Affiliate tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if partnership.OrganizationID != orgID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        <span class="cov0" title="0">_, err = config.DB.Exec("DELETE FROM affiliate_partnerships WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var eventTitle string
        config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", partnership.EventID)

        CreateNotification(
                partnership.UserID,
                "affiliate_removed",
                "🚫 Kemitraan Affiliate Dihentikan",
                fmt.Sprintf("Kemitraan affiliate untuk event \"%s\" telah dihentikan oleh organisasi", eventTitle),
        )

        c.JSON(http.StatusOK, gin.H{"message": "Affiliate berhasil dihapus"})</span>
}

// ===============================================
// HELPER FUNCTIONS
// ===============================================

// GetOrgAffiliateStats - Organization sees affiliate performance stats
// GET /organization/affiliate-stats
func GetOrgAffiliateStats(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get org ID
        var orgID int64
        err := config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organisasi tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">var stats []struct {
                ID                   int64      `db:"id" json:"id"`
                UserID               int64      `db:"user_id" json:"user_id"`
                UserName             string     `db:"user_name" json:"user_name"`
                UserEmail            string     `db:"user_email" json:"user_email"`
                EventID              int64      `db:"event_id" json:"event_id"`
                EventTitle           string     `db:"event_title" json:"event_title"`
                UniqueCode           string     `db:"unique_code" json:"unique_code"`
                CommissionPercentage float64    `db:"commission_percentage" json:"commission_percentage"`
                ExpiresAt            *time.Time `db:"expires_at" json:"expires_at"`
                IsActive             bool       `db:"is_active" json:"is_active"`
                TotalBuyers          int        `db:"total_buyers" json:"total_buyers"`
                TotalEarnings        float64    `db:"total_earnings" json:"total_earnings"`
        }

        // Simplified query - get approved affiliates first
        err = config.DB.Select(&amp;stats, `
                SELECT 
                        ap.id, ap.user_id, u.name as user_name, u.email as user_email,
                        ap.event_id, e.title as event_title, ap.unique_code, ap.commission_percentage,
                        ap.expires_at, COALESCE(ap.is_active, 1) as is_active,
                        0 as total_buyers, 0 as total_earnings
                FROM affiliate_partnerships ap
                JOIN users u ON ap.user_id = u.id
                JOIN events e ON ap.event_id = e.id
                WHERE ap.organization_id = ? AND ap.status = 'APPROVED'
                ORDER BY ap.created_at DESC
        `, orgID)

        fmt.Printf("[ORG-AFFILIATE-STATS] orgID=%d, found %d affiliates, err=%v\n", orgID, len(stats), err)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ORG-AFFILIATE-STATS] Query error: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mengambil statistik: " + err.Error()})
                return
        }</span>

        // Calculate stats for each affiliate from purchases
        <span class="cov0" title="0">for i := range stats </span><span class="cov0" title="0">{
                var buyers int
                var earnings float64
                config.DB.Get(&amp;buyers, `
                        SELECT COUNT(DISTINCT p.user_id)
                        FROM purchases p
                        WHERE p.affiliate_code = ? AND p.status = 'PAID'
                `, stats[i].UniqueCode)

                config.DB.Get(&amp;earnings, `
                        SELECT COALESCE(SUM(p.price_paid * ? / 100), 0)
                        FROM purchases p
                        WHERE p.affiliate_code = ? AND p.status = 'PAID'
                `, stats[i].CommissionPercentage, stats[i].UniqueCode)

                stats[i].TotalBuyers = buyers
                stats[i].TotalEarnings = earnings
        }</span>

        <span class="cov0" title="0">if stats == nil </span><span class="cov0" title="0">{
                stats = make([]struct {
                        ID                   int64      `db:"id" json:"id"`
                        UserID               int64      `db:"user_id" json:"user_id"`
                        UserName             string     `db:"user_name" json:"user_name"`
                        UserEmail            string     `db:"user_email" json:"user_email"`
                        EventID              int64      `db:"event_id" json:"event_id"`
                        EventTitle           string     `db:"event_title" json:"event_title"`
                        UniqueCode           string     `db:"unique_code" json:"unique_code"`
                        CommissionPercentage float64    `db:"commission_percentage" json:"commission_percentage"`
                        ExpiresAt            *time.Time `db:"expires_at" json:"expires_at"`
                        IsActive             bool       `db:"is_active" json:"is_active"`
                        TotalBuyers          int        `db:"total_buyers" json:"total_buyers"`
                        TotalEarnings        float64    `db:"total_earnings" json:"total_earnings"`
                }, 0)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, stats)</span>
}

// generateAffiliateCode creates a unique promo code
func generateAffiliateCode(eventTitle string, userID int64) string <span class="cov0" title="0">{
        // Clean event title: uppercase, alphanumeric only
        reg := regexp.MustCompile(`[^a-zA-Z0-9]+`)
        cleanTitle := strings.ToUpper(reg.ReplaceAllString(eventTitle, ""))
        if len(cleanTitle) &gt; 8 </span><span class="cov0" title="0">{
                cleanTitle = cleanTitle[:8]
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s-%d", cleanTitle, userID)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package controllers

import (
        "log"
        "net/http"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"

        "BACKEND/config"
        "BACKEND/helpers"
        "BACKEND/models" // Pastikan import models ada
)

// ================================
// REGISTER
// ================================
type RegisterRequest struct {
        Name     string `json:"name"`
        Email    string `json:"email"`
        Password string `json:"password"`
        Phone    string `json:"phone"`

        // Organization registration fields (optional)
        RegisterType    string `json:"register_type"` // "user" or "organization"
        OrgName         string `json:"org_name"`
        OrgDescription  string `json:"org_description"`
        OrgCategory     string `json:"org_category"`
        OrgPhone        string `json:"org_phone"`
        BankName        string `json:"bank_name"`
        BankAccount     string `json:"bank_account"`
        BankAccountName string `json:"bank_account_name"`
}

func Register(c *gin.Context) <span class="cov8" title="1">{
        var req RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        // 1. Cek email sudah ada
        <span class="cov8" title="1">var count int
        if err := config.DB.Get(&amp;count, "SELECT COUNT(*) FROM users WHERE email=?", req.Email); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
                return
        }</span>
        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusConflict, gin.H{"error": "Email already in use"})
                return
        }</span>

        // 2. Hash password
        <span class="cov8" title="1">hash, err := helpers.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
                return
        }</span>

        // 3. Insert user with phone
        <span class="cov8" title="1">res, err := config.DB.Exec(`
                INSERT INTO users (name, email, password_hash, phone) 
                VALUES (?, ?, ?, ?)
        `, req.Name, req.Email, hash, req.Phone)

        if err != nil </span><span class="cov0" title="0">{
                log.Println("Insert user error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Cannot create user"})
                return
        }</span>

        <span class="cov8" title="1">userID, _ := res.LastInsertId()

        // 4. Assign role USER (id=1) sebagai default
        if _, err := config.DB.Exec(`
                INSERT INTO user_roles (user_id, role_id) VALUES (?, 1)
        `, userID); err != nil </span><span class="cov0" title="0">{
                log.Println("Assign role error:", err)
        }</span>

        // 5. If registering as organization, create organization application
        <span class="cov8" title="1">if req.RegisterType == "organization" &amp;&amp; req.OrgName != "" </span><span class="cov8" title="1">{
                _, err := config.DB.Exec(`
                        INSERT INTO organization_applications 
                        (user_id, org_name, org_description, org_category, org_phone, 
                         bank_name, bank_account, bank_account_name, reason, submitted_at)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, 'Registrasi langsung sebagai organisasi', NOW())
                `, userID, req.OrgName, req.OrgDescription, req.OrgCategory, req.OrgPhone,
                        req.BankName, req.BankAccount, req.BankAccountName)

                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Insert org application error:", err)
                        // Don't fail registration, user is still created
                }</span>

                // Notify admins about new application
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        var adminIDs []int64
                        config.DB.Select(&amp;adminIDs, `
                                SELECT u.id FROM users u
                                JOIN user_roles ur ON u.id = ur.user_id
                                JOIN roles r ON ur.role_id = r.id
                                WHERE r.name IN ('ADMIN', 'SUPERADMIN')
                        `)
                        for _, adminID := range adminIDs </span><span class="cov0" title="0">{
                                CreateNotification(
                                        adminID,
                                        "new_application",
                                        "📝 Pengajuan Organisasi Baru!",
                                        req.Name+" mendaftar sebagai organisasi \""+req.OrgName+"\"",
                                )
                        }</span>
                }()

                <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                        "message":     "Register success! Pengajuan organisasi sedang ditinjau.",
                        "user_id":     userID,
                        "org_pending": true,
                })
                return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Register success",
                "user_id": userID,
        })</span>
}

// ================================
// LOGIN
// ================================
type LoginRequest struct {
        Email    string `json:"email"`
        Password string `json:"password"`
        // Roles dihapus dari request karena client tidak kirim role saat login
}

func Login(c *gin.Context) <span class="cov8" title="1">{
        var req LoginRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        // 1. Ambil user berdasarkan email
        <span class="cov8" title="1">var user models.User // Menggunakan struct dari models agar lebih rapi
        if err := config.DB.Get(&amp;user, `
                SELECT id, name, email, password_hash 
                FROM users 
                WHERE email = ?
        `, req.Email); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Email atau password salah"})
                return
        }</span>

        // 2. Cek password
        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Email atau password salah"})
                return
        }</span>

        // 3. AMBIL SEMUA ROLE (Fix: Menggunakan Select &amp; []string)
        <span class="cov8" title="1">var roles []string
        err := config.DB.Select(&amp;roles, `
                SELECT r.name 
                FROM roles r 
                JOIN user_roles ur ON r.id = ur.role_id
                WHERE ur.user_id = ?
        `, user.ID)

        if err != nil </span><span class="cov0" title="0">{
                roles = []string{} // Default array kosong jika tidak ada role
        }</span>

        // 4. Generate token
        // Pastikan function GenerateToken di helpers sudah support parameter roles ([]string)
        <span class="cov8" title="1">token, err := helpers.GenerateToken(user.ID, roles)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Token error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to generate token"})
                return
        }</span>

        // 5. Kirim Response Lengkap
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "message": "Login success",
                "token":   token,
                "user": gin.H{
                        "id":    user.ID,
                        "name":  user.Name,
                        "email": user.Email,
                },
                "roles": roles, // Mengirim array roles ke frontend
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "strconv"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
)

// ===============================================
// CART MANAGEMENT
// ===============================================

// GetCart - Get user's cart with items
// GET /user/cart
func GetCart(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        // Ensure cart exists
        var cartID int64
        err := config.DB.Get(&amp;cartID, "SELECT id FROM carts WHERE user_id = ?", userID)
        if err != nil </span><span class="cov8" title="1">{
                // Create cart if not exists
                result, _ := config.DB.Exec("INSERT INTO carts (user_id) VALUES (?)", userID)
                cartID, _ = result.LastInsertId()
        }</span>

        // Get affiliate code if applied
        <span class="cov8" title="1">var affiliateCode *string
        config.DB.Get(&amp;affiliateCode, "SELECT affiliate_code FROM carts WHERE id = ?", cartID)

        // Get cart items with details
        var items []struct {
                ID           int64   `db:"id" json:"id"`
                ItemType     string  `db:"item_type" json:"item_type"`
                SessionID    *int64  `db:"session_id" json:"session_id"`
                EventID      *int64  `db:"event_id" json:"event_id"`
                Price        float64 `db:"price" json:"price"`
                ItemTitle    string  `db:"item_title" json:"item_title"`
                EventTitle   string  `db:"event_title" json:"event_title"`
                ThumbnailURL *string `db:"thumbnail_url" json:"thumbnail_url"`
        }

        config.DB.Select(&amp;items, `
                SELECT ci.id, ci.item_type, ci.session_id, ci.event_id, ci.price,
                        CASE 
                                WHEN ci.item_type = 'SESSION' THEN s.title
                                ELSE CONCAT(e.title, ' (Full Package)')
                        END as item_title,
                        e.title as event_title,
                        e.thumbnail_url
                FROM cart_items ci
                LEFT JOIN sessions s ON ci.session_id = s.id
                LEFT JOIN events e ON COALESCE(ci.event_id, s.event_id) = e.id
                WHERE ci.cart_id = ?
                ORDER BY ci.added_at DESC
        `, cartID)

        // Calculate total
        var total float64
        for _, item := range items </span><span class="cov8" title="1">{
                total += item.Price
        }</span>

        <span class="cov8" title="1">if items == nil </span><span class="cov8" title="1">{
                items = []struct {
                        ID           int64   `db:"id" json:"id"`
                        ItemType     string  `db:"item_type" json:"item_type"`
                        SessionID    *int64  `db:"session_id" json:"session_id"`
                        EventID      *int64  `db:"event_id" json:"event_id"`
                        Price        float64 `db:"price" json:"price"`
                        ItemTitle    string  `db:"item_title" json:"item_title"`
                        EventTitle   string  `db:"event_title" json:"event_title"`
                        ThumbnailURL *string `db:"thumbnail_url" json:"thumbnail_url"`
                }{}
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "cart_id":        cartID,
                "items":          items,
                "total_price":    total,
                "item_count":     len(items),
                "affiliate_code": affiliateCode,
        })</span>
}

// AddToCartInput represents add to cart request
type AddToCartInput struct {
        SessionID *int64 `json:"session_id"` // For single session
        EventID   *int64 `json:"event_id"`   // For event package (all sessions)
}

// AddToCart - Add session or event package to cart
// POST /user/cart/add
func AddToCart(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var input AddToCartInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "session_id atau event_id diperlukan"})
                return
        }</span>

        <span class="cov8" title="1">if input.SessionID == nil &amp;&amp; input.EventID == nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "session_id atau event_id diperlukan"})
                return
        }</span>

        // Get or create cart
        <span class="cov8" title="1">var cartID int64
        err := config.DB.Get(&amp;cartID, "SELECT id FROM carts WHERE user_id = ?", userID)
        if err != nil </span><span class="cov8" title="1">{
                result, _ := config.DB.Exec("INSERT INTO carts (user_id) VALUES (?)", userID)
                cartID, _ = result.LastInsertId()
        }</span>

        <span class="cov8" title="1">if input.SessionID != nil </span><span class="cov8" title="1">{
                // Add single session
                var session struct {
                        ID            int64   `db:"id"`
                        Price         float64 `db:"price"`
                        EventID       int64   `db:"event_id"`
                        PublishStatus string  `db:"publish_status"`
                }
                err := config.DB.Get(&amp;session, "SELECT id, price, event_id, publish_status FROM sessions WHERE id = ?", *input.SessionID)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Sesi tidak ditemukan"})
                        return
                }</span>
                <span class="cov8" title="1">if session.PublishStatus != "PUBLISHED" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Sesi belum dipublish"})
                        return
                }</span>

                // Check if already purchased
                <span class="cov8" title="1">var purchased int
                config.DB.Get(&amp;purchased, "SELECT COUNT(*) FROM purchases WHERE user_id = ? AND session_id = ? AND status = 'PAID'", userID, *input.SessionID)
                if purchased &gt; 0 </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah membeli sesi ini"})
                        return
                }</span>

                // Check if already in cart
                <span class="cov8" title="1">var inCart int
                config.DB.Get(&amp;inCart, "SELECT COUNT(*) FROM cart_items WHERE cart_id = ? AND session_id = ?", cartID, *input.SessionID)
                if inCart &gt; 0 </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Sesi sudah ada di keranjang"})
                        return
                }</span>

                // Add to cart
                <span class="cov8" title="1">_, err = config.DB.Exec(`
                        INSERT INTO cart_items (cart_id, item_type, session_id, price)
                        VALUES (?, 'SESSION', ?, ?)
                `, cartID, *input.SessionID, session.Price)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menambahkan ke keranjang"})
                        return
                }</span>

        } else<span class="cov0" title="0"> if input.EventID != nil </span><span class="cov0" title="0">{
                // Add event package (all sessions)
                var event struct {
                        ID           int64    `db:"id"`
                        PackagePrice *float64 `db:"package_price"`
                        Title        string   `db:"title"`
                }
                err := config.DB.Get(&amp;event, "SELECT id, package_price, title FROM events WHERE id = ? AND publish_status = 'PUBLISHED'", *input.EventID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan"})
                        return
                }</span>

                <span class="cov0" title="0">if event.PackagePrice == nil || *event.PackagePrice &lt;= 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Event ini tidak memiliki paket bundling"})
                        return
                }</span>

                // Check if already in cart
                <span class="cov0" title="0">var inCart int
                config.DB.Get(&amp;inCart, "SELECT COUNT(*) FROM cart_items WHERE cart_id = ? AND event_id = ? AND item_type = 'EVENT_PACKAGE'", cartID, *input.EventID)
                if inCart &gt; 0 </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Paket event sudah ada di keranjang"})
                        return
                }</span>

                // Add package to cart
                <span class="cov0" title="0">_, err = config.DB.Exec(`
                        INSERT INTO cart_items (cart_id, item_type, event_id, price)
                        VALUES (?, 'EVENT_PACKAGE', ?, ?)
                `, cartID, *input.EventID, *event.PackagePrice)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menambahkan ke keranjang"})
                        return
                }</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Berhasil ditambahkan ke keranjang"})</span>
}

// RemoveFromCart - Remove item from cart
// DELETE /user/cart/items/:id
func RemoveFromCart(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")
        itemID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        // Get cart
        var cartID int64
        err := config.DB.Get(&amp;cartID, "SELECT id FROM carts WHERE user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Keranjang tidak ditemukan"})
                return
        }</span>

        // Delete item
        <span class="cov8" title="1">result, _ := config.DB.Exec("DELETE FROM cart_items WHERE id = ? AND cart_id = ?", itemID, cartID)
        affected, _ := result.RowsAffected()
        if affected == 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Item tidak ditemukan"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Item dihapus dari keranjang"})</span>
}

// ApplyAffiliateCode - Apply promo code to cart
// POST /user/cart/apply-code
func ApplyAffiliateCode(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        var input struct {
                Code string `json:"code" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode promo diperlukan"})
                return
        }</span>

        // Validate code exists, is approved, active, and not expired
        <span class="cov8" title="1">var partnership struct {
                ID                   int64   `db:"id"`
                EventID              int64   `db:"event_id"`
                CommissionPercentage float64 `db:"commission_percentage"`
                IsActive             bool    `db:"is_active"`
                IsExpired            bool    `db:"is_expired"`
        }
        err := config.DB.Get(&amp;partnership, `
                SELECT id, event_id, commission_percentage, 
                        COALESCE(is_active, 1) as is_active,
                        CASE WHEN expires_at IS NOT NULL AND expires_at &lt; NOW() THEN 1 ELSE 0 END as is_expired
                FROM affiliate_partnerships 
                WHERE unique_code = ? AND status = 'APPROVED'
        `, input.Code)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode promo tidak valid"})
                return
        }</span>

        // Check if code is active
        <span class="cov8" title="1">if !partnership.IsActive </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode promo sudah tidak aktif"})
                return
        }</span>

        // Check if code is expired
        <span class="cov8" title="1">if partnership.IsExpired </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode promo sudah kadaluarsa"})
                return
        }</span>

        // Get or create cart
        <span class="cov8" title="1">var cartID int64
        config.DB.Get(&amp;cartID, "SELECT id FROM carts WHERE user_id = ?", userID)
        if cartID == 0 </span><span class="cov8" title="1">{
                result, _ := config.DB.Exec("INSERT INTO carts (user_id) VALUES (?)", userID)
                cartID, _ = result.LastInsertId()
        }</span>

        // Apply code to cart
        <span class="cov8" title="1">config.DB.Exec("UPDATE carts SET affiliate_code = ? WHERE id = ?", input.Code, cartID)

        c.JSON(http.StatusOK, gin.H{
                "message": fmt.Sprintf("Kode promo berhasil diterapkan (diskon affiliate: %.0f%%)", partnership.CommissionPercentage),
                "code":    input.Code,
        })</span>
}

// ClearCart - Clear all items from cart
// DELETE /user/cart
func ClearCart(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        config.DB.Exec("DELETE ci FROM cart_items ci JOIN carts c ON ci.cart_id = c.id WHERE c.user_id = ?", userID)
        config.DB.Exec("UPDATE carts SET affiliate_code = NULL WHERE user_id = ?", userID)

        c.JSON(http.StatusOK, gin.H{"message": "Keranjang dikosongkan"})
}</span>

// ClearAffiliateCode - Clear only affiliate code from cart (keep items)
// DELETE /user/cart/clear-code OR POST /user/cart/clear-code
func ClearAffiliateCode(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        config.DB.Exec("UPDATE carts SET affiliate_code = NULL WHERE user_id = ?", userID)

        c.JSON(http.StatusOK, gin.H{"message": "Kode affiliate dihapus"})
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "strconv"
        "strings"
        "time"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
        "github.com/midtrans/midtrans-go"
        "github.com/midtrans/midtrans-go/snap"
)

// ===============================================
// CART CHECKOUT
// ===============================================

// CheckoutCart - Create payment for all items in cart
// POST /user/cart/checkout
func CheckoutCart(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get cart
        var cart struct {
                ID            int64   `db:"id"`
                AffiliateCode *string `db:"affiliate_code"`
        }
        err := config.DB.Get(&amp;cart, "SELECT id, affiliate_code FROM carts WHERE user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Keranjang kosong"})
                return
        }</span>

        // Validate affiliate code if present - check if still active and not expired
        <span class="cov0" title="0">if cart.AffiliateCode != nil &amp;&amp; *cart.AffiliateCode != "" </span><span class="cov0" title="0">{
                var validCode struct {
                        IsActive  bool `db:"is_active"`
                        IsExpired bool `db:"is_expired"`
                }
                err := config.DB.Get(&amp;validCode, `
                        SELECT COALESCE(is_active, 1) as is_active,
                                CASE WHEN expires_at IS NOT NULL AND expires_at &lt; NOW() THEN 1 ELSE 0 END as is_expired
                        FROM affiliate_partnerships 
                        WHERE unique_code = ? AND status = 'APPROVED'
                `, *cart.AffiliateCode)

                if err != nil || !validCode.IsActive || validCode.IsExpired </span><span class="cov0" title="0">{
                        // Clear invalid/expired/inactive affiliate code from cart
                        config.DB.Exec("UPDATE carts SET affiliate_code = NULL WHERE id = ?", cart.ID)
                        cart.AffiliateCode = nil
                        fmt.Printf("[CHECKOUT] Cleared invalid/inactive/expired affiliate code\n")
                }</span>
        }

        // Get cart items
        <span class="cov0" title="0">var items []struct {
                ID        int64   `db:"id"`
                ItemType  string  `db:"item_type"`
                SessionID *int64  `db:"session_id"`
                EventID   *int64  `db:"event_id"`
                Price     float64 `db:"price"`
        }
        config.DB.Select(&amp;items, "SELECT id, item_type, session_id, event_id, price FROM cart_items WHERE cart_id = ?", cart.ID)

        if len(items) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Keranjang kosong"})
                return
        }</span>

        // Calculate total
        <span class="cov0" title="0">var total float64
        for _, item := range items </span><span class="cov0" title="0">{
                total += item.Price
        }</span>

        <span class="cov0" title="0">if total &lt; 100 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Total minimal Rp 100 untuk pembayaran"})
                return
        }</span>

        // Get user details
        <span class="cov0" title="0">var user struct {
                Name     string `db:"name"`
                Email    string `db:"email"`
                Phone    string `db:"phone"`
                Username string `db:"username"`
        }
        config.DB.Get(&amp;user, "SELECT name, email, COALESCE(phone, '') as phone, COALESCE(username, '') as username FROM users WHERE id = ?", userID)

        // Check profile completeness
        if user.Name == "" || user.Email == "" || user.Phone == "" || user.Username == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":              "Lengkapi profil Anda terlebih dahulu",
                        "profile_incomplete": true,
                })
                return
        }</span>

        // Generate order ID - save base order ID for database updates
        <span class="cov0" title="0">baseOrderID := fmt.Sprintf("CART-%d-%d-%d", time.Now().Unix(), cart.ID, userID)
        orderID := baseOrderID

        // Start transaction
        tx, _ := config.DB.Beginx()
        defer tx.Rollback()

        // Create purchases for each item with affiliate code
        for _, item := range items </span><span class="cov0" title="0">{
                if item.ItemType == "SESSION" &amp;&amp; item.SessionID != nil </span><span class="cov0" title="0">{
                        // Single session purchase - include affiliate_code
                        _, err := tx.Exec(`
                                INSERT INTO purchases (user_id, session_id, price_paid, status, order_id, affiliate_code)
                                VALUES (?, ?, ?, 'PENDING', ?, ?)
                                ON DUPLICATE KEY UPDATE status = 'PENDING', order_id = ?, price_paid = ?, affiliate_code = ?
                        `, userID, *item.SessionID, item.Price, baseOrderID, cart.AffiliateCode, baseOrderID, item.Price, cart.AffiliateCode)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[CHECKOUT] Error creating purchase: %v\n", err)
                        }</span>
                } else<span class="cov0" title="0"> if item.ItemType == "EVENT_PACKAGE" &amp;&amp; item.EventID != nil </span><span class="cov0" title="0">{
                        // Package = all sessions in event
                        var sessionIDs []int64
                        config.DB.Select(&amp;sessionIDs, "SELECT id FROM sessions WHERE event_id = ? AND publish_status = 'PUBLISHED'", *item.EventID)

                        pricePerSession := item.Price / float64(len(sessionIDs))
                        for _, sessID := range sessionIDs </span><span class="cov0" title="0">{
                                tx.Exec(`
                                        INSERT INTO purchases (user_id, session_id, price_paid, status, order_id, affiliate_code)
                                        VALUES (?, ?, ?, 'PENDING', ?, ?)
                                        ON DUPLICATE KEY UPDATE status = 'PENDING', order_id = ?, price_paid = ?, affiliate_code = ?
                                `, userID, sessID, pricePerSession, baseOrderID, cart.AffiliateCode, baseOrderID, pricePerSession, cart.AffiliateCode)
                        }</span>
                }
        }

        // Store affiliate code in order for later split payment (keep for backward compat)
        <span class="cov0" title="0">if cart.AffiliateCode != nil </span><span class="cov0" title="0">{
                orderID = fmt.Sprintf("%s-AFF-%s", baseOrderID, *cart.AffiliateCode)
        }</span>

        // Create Midtrans payment
        <span class="cov0" title="0">var midtransItems []midtrans.ItemDetails
        for i, item := range items </span><span class="cov0" title="0">{
                itemName := fmt.Sprintf("Item %d", i+1)
                if item.ItemType == "SESSION" </span><span class="cov0" title="0">{
                        var title string
                        config.DB.Get(&amp;title, "SELECT title FROM sessions WHERE id = ?", item.SessionID)
                        itemName = title
                }</span> else<span class="cov0" title="0"> {
                        var title string
                        config.DB.Get(&amp;title, "SELECT title FROM events WHERE id = ?", item.EventID)
                        itemName = fmt.Sprintf("%s (Package)", title)
                }</span>
                <span class="cov0" title="0">if len(itemName) &gt; 50 </span><span class="cov0" title="0">{
                        itemName = itemName[:47] + "..."
                }</span>

                <span class="cov0" title="0">midtransItems = append(midtransItems, midtrans.ItemDetails{
                        ID:    strconv.Itoa(i + 1),
                        Name:  itemName,
                        Price: int64(item.Price),
                        Qty:   1,
                })</span>
        }

        <span class="cov0" title="0">snapReq := &amp;snap.Request{
                TransactionDetails: midtrans.TransactionDetails{
                        OrderID:  orderID,
                        GrossAmt: int64(total),
                },
                CustomerDetail: &amp;midtrans.CustomerDetails{
                        FName: user.Name,
                        Email: user.Email,
                        Phone: user.Phone,
                },
                Items: &amp;midtransItems,
                EnabledPayments: []snap.SnapPaymentType{
                        "gopay",
                },
        }

        snapResp, snapErr := config.SnapClient.CreateTransaction(snapReq)
        if snapErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create payment: " + snapErr.Message})
                return
        }</span>

        // Update all purchases with snap token
        // IMPORTANT: Store BOTH order IDs - base for our DB lookup, full for Midtrans lookup
        <span class="cov0" title="0">tx.Exec("UPDATE purchases SET snap_token = ?, midtrans_order_id = ? WHERE order_id = ?", snapResp.Token, orderID, baseOrderID)

        tx.Commit()

        fmt.Printf("[CART-CHECKOUT] ✅ Created order: base=%s, midtrans=%s, items=%d\n", baseOrderID, orderID, len(items))

        c.JSON(http.StatusOK, gin.H{
                "token":             snapResp.Token,
                "redirect_url":      snapResp.RedirectURL,
                "order_id":          baseOrderID, // For DB lookup
                "midtrans_order_id": orderID,     // For Midtrans API check (includes affiliate code)
                "total":             total,
                "item_count":        len(items),
        })</span>
}

// ===============================================
// UPDATED processSuccessfulPayment for Cart Checkout
// ===============================================

// ProcessCartPayment handles successful cart payment with split payments
// Called from HandleMidtransNotification when order starts with "CART-"
func ProcessCartPayment(orderID string, grossAmount string) error <span class="cov0" title="0">{
        fmt.Printf("[CART-PAYMENT] Processing order: %s, amount: %s\n", orderID, grossAmount)

        // Parse affiliate code from order ID if present (backward compat)
        var affiliateCodeFromURL *string
        if strings.Contains(orderID, "-AFF-") </span><span class="cov0" title="0">{
                parts := strings.Split(orderID, "-AFF-")
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        affiliateCodeFromURL = &amp;parts[1]
                        orderID = parts[0] // Use base order ID for DB queries
                        fmt.Printf("[CART-PAYMENT] Parsed affiliate code from URL: %s\n", *affiliateCodeFromURL)
                }</span>
        }

        <span class="cov0" title="0">tx, _ := config.DB.Beginx()
        defer tx.Rollback()

        // Update all purchases to PAID (use exact match since we store baseOrderID)
        result, err := tx.Exec("UPDATE purchases SET status = 'PAID' WHERE order_id = ?", orderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update purchases: %v", err)
        }</span>
        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        fmt.Printf("[CART-PAYMENT] Updated %d purchases to PAID\n", rowsAffected)

        // Get all purchases in this order - now include affiliate_code from purchases table!
        var purchases []struct {
                ID            int64   `db:"id"`
                SessionID     int64   `db:"session_id"`
                PricePaid     float64 `db:"price_paid"`
                EventID       int64   `db:"event_id"`
                OrgID         int64   `db:"org_id"`
                IsOfficial    bool    `db:"is_official"`
                AffiliateCode *string `db:"affiliate_code"`
        }
        tx.Select(&amp;purchases, `
                SELECT p.id, p.session_id, p.price_paid, e.id as event_id, 
                        o.id as org_id, COALESCE(o.is_official, 0) as is_official,
                        p.affiliate_code
                FROM purchases p
                JOIN sessions s ON p.session_id = s.id
                JOIN events e ON s.event_id = e.id
                JOIN organizations o ON e.organization_id = o.id
                WHERE p.order_id = ?
        `, orderID)

        fmt.Printf("[CART-PAYMENT] Found %d purchases to process\n", len(purchases))

        // Get buyer ID
        var buyerID int64
        tx.Get(&amp;buyerID, "SELECT user_id FROM purchases WHERE order_id = ? LIMIT 1", orderID)

        // Process each purchase with split payment
        for _, purchase := range purchases </span><span class="cov0" title="0">{
                if purchase.IsOfficial </span><span class="cov0" title="0">{
                        continue</span> // Skip official org - no balance credit
                }

                // Check if affiliate code is valid for this event
                // Use affiliate_code from purchase table, fallback to URL-parsed code
                <span class="cov0" title="0">var affiliateCode *string
                if purchase.AffiliateCode != nil &amp;&amp; *purchase.AffiliateCode != "" </span><span class="cov0" title="0">{
                        affiliateCode = purchase.AffiliateCode
                        fmt.Printf("[CART-PAYMENT] Using affiliate code from purchase: %s for event %d\n", *affiliateCode, purchase.EventID)
                }</span> else<span class="cov0" title="0"> if affiliateCodeFromURL != nil </span><span class="cov0" title="0">{
                        affiliateCode = affiliateCodeFromURL
                        fmt.Printf("[CART-PAYMENT] Using affiliate code from URL: %s for event %d\n", *affiliateCode, purchase.EventID)
                }</span>

                <span class="cov0" title="0">var partnership struct {
                        UserID               int64   `db:"user_id"`
                        CommissionPercentage float64 `db:"commission_percentage"`
                }

                hasAffiliate := false
                if affiliateCode != nil </span><span class="cov0" title="0">{
                        // Only credit affiliate if code is active and not expired
                        err := tx.Get(&amp;partnership, `
                                SELECT user_id, commission_percentage 
                                FROM affiliate_partnerships 
                                WHERE unique_code = ? AND event_id = ? AND status = 'APPROVED'
                                        AND COALESCE(is_active, 1) = 1
                                        AND (expires_at IS NULL OR expires_at &gt;= NOW())
                        `, *affiliateCode, purchase.EventID)
                        if err == nil </span><span class="cov0" title="0">{
                                hasAffiliate = true
                                fmt.Printf("[CART-PAYMENT] ✅ Found active affiliate partnership: user=%d, commission=%.2f%%\n", partnership.UserID, partnership.CommissionPercentage)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[CART-PAYMENT] ⚠️ No valid/active partnership for code=%s, event=%d: %v\n", *affiliateCode, purchase.EventID, err)
                        }</span>
                }

                <span class="cov0" title="0">if hasAffiliate </span><span class="cov0" title="0">{
                        // Split payment: affiliate gets commission, org gets remainder
                        commission := purchase.PricePaid * (partnership.CommissionPercentage / 100)
                        orgAmount := purchase.PricePaid - commission

                        fmt.Printf("[CART-PAYMENT] 💰 Splitting payment: total=%.0f, commission=%.0f (%.2f%%), org=%.0f\n",
                                purchase.PricePaid, commission, partnership.CommissionPercentage, orgAmount)

                        // Credit affiliate balance
                        _, affErr := tx.Exec(`
                                INSERT INTO affiliate_balances (user_id, balance, total_earned)
                                VALUES (?, ?, ?)
                                ON DUPLICATE KEY UPDATE 
                                        balance = balance + ?,
                                        total_earned = total_earned + ?
                        `, partnership.UserID, commission, commission, commission, commission)

                        if affErr != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[CART-PAYMENT] ❌ Error crediting affiliate balance: %v\n", affErr)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[CART-PAYMENT] ✅ Credited Rp %.0f to affiliate user %d\n", commission, partnership.UserID)
                        }</span>

                        // Record affiliate transaction
                        <span class="cov0" title="0">tx.Exec(`
                                INSERT INTO financial_transactions (transaction_type, entity_type, entity_id, amount, description, reference_id)
                                VALUES ('AFFILIATE_CREDIT', 'AFFILIATE', ?, ?, ?, ?)
                        `, partnership.UserID, commission, fmt.Sprintf("Komisi dari session ID %d", purchase.SessionID), orderID)

                        // Credit org balance (minus commission)
                        tx.Exec(`
                                INSERT INTO organization_balances (organization_id, balance, total_earned)
                                VALUES (?, ?, ?)
                                ON DUPLICATE KEY UPDATE 
                                        balance = balance + ?,
                                        total_earned = total_earned + ?
                        `, purchase.OrgID, orgAmount, orgAmount, orgAmount, orgAmount)

                        // Notify affiliate
                        CreateNotification(
                                partnership.UserID,
                                "affiliate_sale",
                                "🛒 Penjualan dari Kode Promo!",
                                fmt.Sprintf("Anda mendapat komisi Rp %.0f dari penjualan", commission),
                        )</span>

                } else<span class="cov0" title="0"> {
                        // No affiliate - full amount to org
                        tx.Exec(`
                                INSERT INTO organization_balances (organization_id, balance, total_earned)
                                VALUES (?, ?, ?)
                                ON DUPLICATE KEY UPDATE 
                                        balance = balance + ?,
                                        total_earned = total_earned + ?
                        `, purchase.OrgID, purchase.PricePaid, purchase.PricePaid, purchase.PricePaid, purchase.PricePaid)
                }</span>

                // Record org transaction
                <span class="cov0" title="0">tx.Exec(`
                        INSERT INTO financial_transactions (transaction_type, entity_type, entity_id, amount, description, reference_id)
                        VALUES ('SALE', 'ORGANIZATION', ?, ?, ?, ?)
                `, purchase.OrgID, purchase.PricePaid, fmt.Sprintf("Penjualan session ID %d", purchase.SessionID), orderID)</span>
        }

        // Clear cart
        <span class="cov0" title="0">tx.Exec("DELETE ci FROM cart_items ci JOIN carts c ON ci.cart_id = c.id WHERE c.user_id = ?", buyerID)
        tx.Exec("UPDATE carts SET affiliate_code = NULL WHERE user_id = ?", buyerID)

        // Notify buyer
        CreateNotification(
                buyerID,
                "purchase_success",
                "✅ Pembayaran Berhasil!",
                fmt.Sprintf("Pembelian %d item berhasil. Silakan akses konten Anda.", len(purchases)),
        )

        return tx.Commit()</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package controllers

import (
        "fmt" // &lt;-- DITAMBAHKAN: Untuk mengatasi error undefined: fmt
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
        "BACKEND/models"
)

// Helper
func getOrganizationIDByUser(userID int64) (int64, error) <span class="cov0" title="0">{
        var orgID int64
        err := config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)
        return orgID, err
}</span>

// Structs
type SessionVideoResponse struct {
        ID          int64  `db:"id" json:"id"`
        Title       string `db:"title" json:"title"`
        Description string `db:"description" json:"description"`
        VideoURL    string `db:"video_url" json:"video_url"`
}

type SessionFileResponse struct {
        ID          int64  `db:"id" json:"id"`
        Title       string `db:"title" json:"title"`
        Description string `db:"description" json:"description"`
        FileURL     string `db:"file_url" json:"file_url"`
}

type SessionWithMedia struct {
        ID            int64                  `db:"id" json:"id"`
        EventID       int64                  `db:"event_id" json:"event_id"`
        Title         string                 `db:"title" json:"title"`
        Description   string                 `db:"description" json:"description"`
        Price         int                    `db:"price" json:"price"`
        PublishStatus string                 `db:"publish_status" json:"publish_status"`
        Videos        []SessionVideoResponse `json:"videos"`
        Files         []SessionFileResponse  `json:"files"`
}

// GET DETAIL FOR MANAGE
func GetMyEventDetailForManage(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Anda belum terdaftar sebagai creator"})
                return
        }</span>

        <span class="cov0" title="0">var event models.Event
        err = config.DB.Get(&amp;event, `
                SELECT id, organization_id, title, description, category, thumbnail_url, COALESCE(publish_status, 'DRAFT') as publish_status, publish_at, created_at, updated_at
                FROM events WHERE id = ? AND organization_id = ?
        `, eventID, orgID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">var sessions []SessionWithMedia
        err = config.DB.Select(&amp;sessions, `SELECT id, event_id, title, description, price, COALESCE(publish_status, 'DRAFT') as publish_status FROM sessions WHERE event_id = ? ORDER BY order_index ASC, created_at ASC`, eventID)
        if err != nil </span><span class="cov0" title="0">{ sessions = []SessionWithMedia{} }</span>

        <span class="cov0" title="0">for i := range sessions </span><span class="cov0" title="0">{
                var videos []SessionVideoResponse
                config.DB.Select(&amp;videos, `SELECT id, title, COALESCE(description, '') as description, video_url FROM session_videos WHERE session_id = ? ORDER BY order_index ASC`, sessions[i].ID)
                if videos == nil </span><span class="cov0" title="0">{ videos = []SessionVideoResponse{} }</span>
                <span class="cov0" title="0">sessions[i].Videos = videos

                var files []SessionFileResponse
                config.DB.Select(&amp;files, `SELECT id, title, COALESCE(description, '') as description, file_url FROM session_files WHERE session_id = ? ORDER BY order_index ASC`, sessions[i].ID)
                if files == nil </span><span class="cov0" title="0">{ files = []SessionFileResponse{} }</span>
                <span class="cov0" title="0">sessions[i].Files = files</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"event": event, "sessions": sessions})</span>
}

// CREATE EVENT
type CreateEventRequest struct {
        Title       string `json:"title" binding:"required"`
        Description string `json:"description"`
        Category    string `json:"category"`
}

func CreateEvent(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Organization not found"})
                return
        }</span>
        <span class="cov0" title="0">var req CreateEventRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">res, err := config.DB.Exec(`INSERT INTO events (organization_id, title, description, category, publish_status, created_at, updated_at) VALUES (?, ?, ?, ?, 'DRAFT', ?, ?)`, orgID, req.Title, req.Description, req.Category, time.Now(), time.Now())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create event"})
                return
        }</span>
        <span class="cov0" title="0">eventID, _ := res.LastInsertId()
        c.JSON(http.StatusOK, gin.H{"message": "Event created", "event_id": eventID})</span>
}

// LIST MY EVENTS
func ListMyEvents(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Organization not found"})
                return
        }</span>
        <span class="cov0" title="0">var events []models.Event
        config.DB.Select(&amp;events, `SELECT id, organization_id, title, description, category, thumbnail_url, COALESCE(publish_status, 'DRAFT') as publish_status, publish_at, created_at, updated_at FROM events WHERE organization_id = ? ORDER BY created_at DESC`, orgID)
        if events == nil </span><span class="cov0" title="0">{ events = []models.Event{} }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"events": events})</span>
}

// ==========================================
// DELETE EVENT (FIXED: Full Cleanup)
// ==========================================
func DeleteEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        // 1. Ambil Info Thumbnail untuk dihapus nanti
        <span class="cov0" title="0">var thumbnailURL string
        err = config.DB.Get(&amp;thumbnailURL, "SELECT COALESCE(thumbnail_url, '') FROM events WHERE id = ? AND organization_id = ?", eventID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan atau bukan milik Anda"})
                return
        }</span>

        // 2. Ambil semua Session ID di event ini
        <span class="cov0" title="0">var sessionIDs []int64
        err = config.DB.Select(&amp;sessionIDs, "SELECT id FROM sessions WHERE event_id = ?", eventID)
        
        if err == nil </span><span class="cov0" title="0">{
                // LOOP SETIAP SESI: Hapus isinya dulu
                for _, sessID := range sessionIDs </span><span class="cov0" title="0">{
                        // A. Hapus Video (File Fisik &amp; DB)
                        var videoPaths []string
                        config.DB.Select(&amp;videoPaths, "SELECT video_url FROM session_videos WHERE session_id = ?", sessID)
                        for _, path := range videoPaths </span><span class="cov0" title="0">{ os.Remove(path) }</span>
                        <span class="cov0" title="0">config.DB.Exec("DELETE FROM session_videos WHERE session_id = ?", sessID)

                        // B. Hapus Files (File Fisik &amp; DB)
                        var filePaths []string
                        config.DB.Select(&amp;filePaths, "SELECT file_url FROM session_files WHERE session_id = ?", sessID)
                        for _, path := range filePaths </span><span class="cov0" title="0">{ os.Remove(path) }</span>
                        <span class="cov0" title="0">config.DB.Exec("DELETE FROM session_files WHERE session_id = ?", sessID)

                        // C. Hapus Purchases (DB) - PENTING!
                        config.DB.Exec("DELETE FROM purchases WHERE session_id = ?", sessID)</span>
                }

                // 3. Setelah isi sesi kosong, Hapus SEMUA SESI di event ini
                <span class="cov0" title="0">_, err := config.DB.Exec("DELETE FROM sessions WHERE event_id = ?", eventID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus sesi-sesi (DB Error): " + err.Error()})
                        return
                }</span>
        }

        // 4. Hapus Thumbnail Event Fisik
        <span class="cov0" title="0">if thumbnailURL != "" </span><span class="cov0" title="0">{
                os.Remove(thumbnailURL)
        }</span>

        // 5. Akhirnya Hapus Event dari DB
        <span class="cov0" title="0">_, err = config.DB.Exec("DELETE FROM events WHERE id = ? AND organization_id = ?", eventID, orgID)
        
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error delete event:", err) // Menggunakan fmt yang sekarang sudah diimport
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus event (DB Error): " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event dan semua isinya berhasil dihapus"})</span>
}

// ==========================================
// UPDATE EVENT (Title, Desc, Category)
// ==========================================
type UpdateEventInput struct {
        Title       string `json:"title"`
        Description string `json:"description"`
        Category    string `json:"category"`
}

func UpdateEvent(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        // Cek kepemilikan
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, "SELECT COUNT(*) FROM events WHERE id = ? AND organization_id = ?", eventID, orgID)
        if count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan atau bukan milik Anda"})
                return
        }</span>

        <span class="cov0" title="0">var input UpdateEventInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Update DB
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                UPDATE events 
                SET title = ?, description = ?, category = ?, updated_at = NOW() 
                WHERE id = ?
        `, input.Title, input.Description, input.Category, eventID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update event"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event berhasil diperbarui"})</span>
}

// ==========================================
// UPLOAD EVENT THUMBNAIL
// ==========================================
func UploadEventThumbnail(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        // Cek kepemilikan
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, "SELECT COUNT(*) FROM events WHERE id = ? AND organization_id = ?", eventID, orgID)
        if count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan atau bukan milik Anda"})
                return
        }</span>

        // Ambil File
        <span class="cov0" title="0">file, err := c.FormFile("thumbnail")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File thumbnail wajib diupload"})
                return
        }</span>

        // Simpan File
        <span class="cov0" title="0">saveDir := "uploads/events"
        os.MkdirAll(saveDir, os.ModePerm)

        ext := filepath.Ext(file.Filename)
        filename := fmt.Sprintf("event_thumb_%s_%d%s", eventID, time.Now().Unix(), ext)
        filePath := filepath.Join(saveDir, filename)

        if err := c.SaveUploadedFile(file, filePath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan gambar"})
                return
        }</span>

        // Update DB (path separator forward slash untuk URL)
        <span class="cov0" title="0">dbPath := "uploads/events/" + filename
        _, err = config.DB.Exec("UPDATE events SET thumbnail_url = ? WHERE id = ?", dbPath, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update database"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":       "Thumbnail berhasil diupload",
                "thumbnail_url": dbPath,
        })</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package controllers

import (
        "BACKEND/config"
        "BACKEND/models"
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
)

// Struct respon ringkas
type PublicEventResponse struct {
        ID               int64   `db:"id" json:"id"`
        OrganizationID   int64   `db:"organization_id" json:"organization_id"`
        Title            string  `db:"title" json:"title"`
        Description      string  `db:"description" json:"description"`
        Category         string  `db:"category" json:"category"`
        ThumbnailURL     *string `db:"thumbnail_url" json:"thumbnail_url"`
        OrganizationName string  `db:"organization_name" json:"organization_name"`
        SessionCount     int     `db:"session_count" json:"session_count"`
        MinPrice         float64 `db:"min_price" json:"min_price"`
        PublishAt        *string `db:"publish_at" json:"publish_at"`
}

// =========================================================
// GET ALL PUBLIC EVENTS
// =========================================================
func ListPublicEvents(c *gin.Context) <span class="cov0" title="0">{
        // Base Query
        baseQuery := `
                SELECT 
                        e.id, e.organization_id, e.title, e.description, e.category, e.thumbnail_url,
                        o.name AS organization_name,
                        (SELECT COUNT(*) FROM sessions s WHERE s.event_id = e.id) AS session_count,
                        (SELECT COALESCE(MIN(price), 0) FROM sessions s WHERE s.event_id = e.id) AS min_price,
                        e.publish_at
                FROM events e
                JOIN organizations o ON o.id = e.organization_id
        `

        // 1. PUBLISHED
        var publishedEvents []PublicEventResponse
        config.DB.Select(&amp;publishedEvents, baseQuery+" WHERE e.publish_status = 'PUBLISHED' ORDER BY e.created_at DESC")
        if publishedEvents == nil </span><span class="cov0" title="0">{
                publishedEvents = []PublicEventResponse{}
        }</span>

        // 2. UPCOMING (SCHEDULED)
        <span class="cov0" title="0">var upcomingEvents []PublicEventResponse
        config.DB.Select(&amp;upcomingEvents, baseQuery+" WHERE e.publish_status = 'SCHEDULED' ORDER BY e.publish_at ASC")
        if upcomingEvents == nil </span><span class="cov0" title="0">{
                upcomingEvents = []PublicEventResponse{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "events":   publishedEvents,
                "upcoming": upcomingEvents,
        })</span>
}

// =========================
// GET EVENT DETAIL (PUBLIC)
// =========================
func GetEventDetail(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")

        // 1. Ambil Event (Izinkan PUBLISHED atau SCHEDULED)
        var event models.Event
        err := config.DB.Get(&amp;event, `
                SELECT 
                        id, organization_id, title, description, category, thumbnail_url,
                        COALESCE(publish_status, 'DRAFT') as publish_status, 
                        publish_at, created_at, updated_at
                FROM events 
                WHERE id = ? AND (publish_status = 'PUBLISHED' OR publish_status = 'SCHEDULED')
        `, eventID)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ Public Event Error:", err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Event tidak ditemukan atau belum rilis"})
                return
        }</span>

        // 2. Ambil data organisasi
        <span class="cov0" title="0">var organization struct {
                ID      int64  `db:"id" json:"id"`
                Name    string `db:"name" json:"name"`
                LogoURL string `db:"logo_url" json:"logo_url"`
        }
        config.DB.Get(&amp;organization, `
                SELECT id, name, COALESCE(logo_url, '') as logo_url
                FROM organizations WHERE id = ?
        `, event.OrganizationID)

        // 3. Ambil Sesi (Hanya yang tidak DRAFT)
        var sessions []models.Session
        err = config.DB.Select(&amp;sessions, `
                SELECT 
                        id, event_id, title, description, price, order_index, 
                        COALESCE(publish_status, 'DRAFT') as publish_status, 
                        publish_at, created_at
                FROM sessions
                WHERE event_id = ? AND publish_status != 'DRAFT'
                ORDER BY order_index ASC
        `, eventID)

        if err != nil </span><span class="cov0" title="0">{
                sessions = []models.Session{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "event":        event,
                "sessions":     sessions,
                "organization": organization,
        })</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
)

// Helper cek kepemilikan (Sama seperti sebelumnya, tapi kita log errornya)
func checkEventOwnedByUserID(eventID int64, userID int64) bool <span class="cov0" title="0">{
        var count int
        config.DB.Get(&amp;count, `
                SELECT COUNT(*) FROM events e 
                JOIN organizations o ON e.organization_id = o.id 
                WHERE e.id = ? AND o.owner_user_id = ?
        `, eventID, userID)
        return count &gt; 0
}</span>

func PublishEvent(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        eventID, _ := strconv.ParseInt(c.Param("eventID"), 10, 64)

        if !checkEventOwnedByUserID(eventID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`UPDATE events SET publish_status = 'PUBLISHED', publish_at = NULL WHERE id = ?`, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to publish"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event published!", "status": "PUBLISHED"})</span>
}

func UnpublishEvent(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        eventID, _ := strconv.ParseInt(c.Param("eventID"), 10, 64)

        if !checkEventOwnedByUserID(eventID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`UPDATE events SET publish_status = 'DRAFT', publish_at = NULL WHERE id = ?`, eventID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to unpublish"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event drafted!", "status": "DRAFT"})</span>
}

// FIX: Parsing Tanggal yang Fleksibel untuk Schedule
type ScheduleRequest struct {
        PublishAt string `json:"publish_at" binding:"required"`
}

func SchedulePublish(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        eventID, _ := strconv.ParseInt(c.Param("eventID"), 10, 64)

        if !checkEventOwnedByUserID(eventID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">var req ScheduleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
                return
        }</span>

        // 1. Coba format dari HTML datetime-local (contoh: 2025-12-19T18:00)
        // Kita tambah ":00" detik agar sesuai format SQL standard jika perlu
        <span class="cov0" title="0">layoutHTML := "2006-01-02T15:04"
        layoutISO := time.RFC3339

        parsedTime, err := time.Parse(layoutHTML, req.PublishAt)
        if err != nil </span><span class="cov0" title="0">{
                // Jika gagal, coba format ISO lengkap
                parsedTime, err = time.Parse(layoutISO, req.PublishAt)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("❌ Date Parse Error:", err, "Input:", req.PublishAt)
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Format tanggal tidak valid."})
                        return
                }</span>
        }

        // 2. Ubah ke format SQL
        <span class="cov0" title="0">sqlTimeStr := parsedTime.Format("2006-01-02 15:04:05")

        _, err = config.DB.Exec(`
                UPDATE events 
                SET publish_status = 'SCHEDULED', publish_at = ? 
                WHERE id = ?
        `, sqlTimeStr, eventID)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ DB Error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":    "Event scheduled!",
                "status":     "SCHEDULED",
                "publish_at": req.PublishAt,
        })</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package controllers

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
)

// =============================
// GET FEATURED EVENTS (Public)
// =============================
func GetFeaturedEvents(c *gin.Context) <span class="cov0" title="0">{
        type FeaturedEvent struct {
                ID             int64   `db:"id" json:"id"`
                EventID        int64   `db:"event_id" json:"event_id"`
                OrderIndex     int     `db:"order_index" json:"order_index"`
                Title          string  `db:"title" json:"title"`
                Description    *string `db:"description" json:"description"`
                Category       *string `db:"category" json:"category"`
                ThumbnailURL   *string `db:"thumbnail_url" json:"thumbnail_url"`
                OrganizationID int64   `db:"organization_id" json:"organization_id"`
                OrgName        *string `db:"org_name" json:"org_name"`
        }

        var featured []FeaturedEvent
        err := config.DB.Select(&amp;featured, `
                SELECT 
                        fe.id, fe.event_id, fe.order_index,
                        e.title, e.description, e.category, e.thumbnail_url, e.organization_id,
                        o.name as org_name
                FROM featured_events fe
                JOIN events e ON fe.event_id = e.id
                LEFT JOIN organizations o ON e.organization_id = o.id
                WHERE e.publish_status = 'PUBLISHED'
                ORDER BY fe.order_index ASC
                LIMIT 10
        `)

        if err != nil </span><span class="cov0" title="0">{
                // Table might not exist yet, return empty array
                c.JSON(http.StatusOK, gin.H{"featured": []interface{}{}})
                return
        }</span>

        <span class="cov0" title="0">if featured == nil </span><span class="cov0" title="0">{
                featured = []FeaturedEvent{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"featured": featured})</span>
}

// =============================
// GET ALL FEATURED (Admin)
// =============================
func AdminGetFeaturedEvents(c *gin.Context) <span class="cov0" title="0">{
        type FeaturedEvent struct {
                ID           int64   `db:"id" json:"id"`
                EventID      int64   `db:"event_id" json:"event_id"`
                OrderIndex   int     `db:"order_index" json:"order_index"`
                Title        string  `db:"title" json:"title"`
                Category     *string `db:"category" json:"category"`
                ThumbnailURL *string `db:"thumbnail_url" json:"thumbnail_url"`
                CreatedAt    string  `db:"created_at" json:"created_at"`
        }

        var featured []FeaturedEvent
        err := config.DB.Select(&amp;featured, `
                SELECT 
                        fe.id, fe.event_id, fe.order_index,
                        e.title, e.category, e.thumbnail_url, fe.created_at
                FROM featured_events fe
                JOIN events e ON fe.event_id = e.id
                ORDER BY fe.order_index ASC
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"featured": []interface{}{}})
                return
        }</span>

        <span class="cov0" title="0">if featured == nil </span><span class="cov0" title="0">{
                featured = []FeaturedEvent{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"featured": featured})</span>
}

// =============================
// GET AVAILABLE EVENTS (Admin) - Events not yet featured
// =============================
func AdminGetAvailableEvents(c *gin.Context) <span class="cov0" title="0">{
        type AvailableEvent struct {
                ID           int64   `db:"id" json:"id"`
                Title        string  `db:"title" json:"title"`
                Category     *string `db:"category" json:"category"`
                ThumbnailURL *string `db:"thumbnail_url" json:"thumbnail_url"`
                OrgName      *string `db:"org_name" json:"org_name"`
        }

        var events []AvailableEvent
        err := config.DB.Select(&amp;events, `
                SELECT 
                        e.id, e.title, e.category, e.thumbnail_url,
                        o.name as org_name
                FROM events e
                LEFT JOIN organizations o ON e.organization_id = o.id
                WHERE e.publish_status = 'PUBLISHED'
                AND e.id NOT IN (SELECT event_id FROM featured_events)
                ORDER BY e.created_at DESC
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch events: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if events == nil </span><span class="cov0" title="0">{
                events = []AvailableEvent{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"events": events})</span>
}

// =============================
// ADD TO FEATURED (Admin)
// =============================
func AdminAddFeaturedEvent(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        var req struct {
                EventID int64 `json:"event_id" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Event ID is required"})
                return
        }</span>

        // Check count limit (max 10)
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, `SELECT COUNT(*) FROM featured_events`)
        if count &gt;= 10 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Maximum 10 featured events allowed"})
                return
        }</span>

        // Get next order index
        <span class="cov0" title="0">var maxOrder int
        config.DB.Get(&amp;maxOrder, `SELECT COALESCE(MAX(order_index), 0) FROM featured_events`)

        // Insert
        _, err := config.DB.Exec(`
                INSERT INTO featured_events (event_id, order_index, created_at, created_by)
                VALUES (?, ?, ?, ?)
        `, req.EventID, maxOrder+1, time.Now(), userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to add featured event: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Event added to featured"})</span>
}

// =============================
// REMOVE FROM FEATURED (Admin)
// =============================
func AdminRemoveFeaturedEvent(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        _, err := config.DB.Exec(`DELETE FROM featured_events WHERE id = ?`, id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to remove featured event"})
                return
        }</span>

        // Reorder remaining
        <span class="cov0" title="0">config.DB.Exec(`
                SET @row_number = 0;
                UPDATE featured_events SET order_index = (@row_number:=@row_number + 1) ORDER BY order_index;
        `)

        c.JSON(http.StatusOK, gin.H{"message": "Event removed from featured"})</span>
}

// =============================
// REORDER FEATURED (Admin)
// =============================
func AdminReorderFeaturedEvents(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                Order []int64 `json:"order" binding:"required"` // Array of featured_events IDs in new order
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Order array is required"})
                return
        }</span>

        // Update order for each
        <span class="cov0" title="0">for idx, id := range req.Order </span><span class="cov0" title="0">{
                config.DB.Exec(`UPDATE featured_events SET order_index = ? WHERE id = ?`, idx+1, id)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Order updated"})</span>
}

// =============================
// UPDATE FEATURED ORDER (Admin) - Move single item
// =============================
func AdminUpdateFeaturedOrder(c *gin.Context) <span class="cov0" title="0">{
        id := c.Param("id")

        var req struct {
                OrderIndex int `json:"order_index" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Order index is required"})
                return
        }</span>

        <span class="cov0" title="0">idInt, _ := strconv.ParseInt(id, 10, 64)

        _, err := config.DB.Exec(`UPDATE featured_events SET order_index = ? WHERE id = ?`, req.OrderIndex, idInt)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update order"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Order updated"})</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package controllers

import (
        "BACKEND/config"
)

// Shared helper: check whether a session is owned by the organization of the user
func checkSessionOwnedByUser(sessionID int64, userID int64) bool <span class="cov0" title="0">{
        var count int
        err := config.DB.Get(&amp;count, `
        SELECT COUNT(*) FROM sessions s
        JOIN events e ON s.event_id = e.id
        JOIN organizations o ON e.organization_id = o.id
        WHERE s.id = ? AND o.owner_user_id = ?
    `, sessionID, userID)

        return err == nil &amp;&amp; count &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package controllers

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
)

// =============================
// GET MY NOTIFICATIONS
// =============================
func GetMyNotifications(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        type NotificationRow struct {
                ID        int64  `db:"id" json:"id"`
                UserID    int64  `db:"user_id" json:"user_id"`
                Type      string `db:"type" json:"type"`
                Title     string `db:"title" json:"title"`
                Message   string `db:"message" json:"message"`
                IsRead    bool   `db:"is_read" json:"is_read"`
                CreatedAt string `db:"created_at" json:"created_at"`
        }

        var notifications []NotificationRow
        err := config.DB.Select(&amp;notifications, `
                SELECT id, user_id, 
                       COALESCE(type, '') as type, 
                       COALESCE(title, '') as title, 
                       COALESCE(message, '') as message, 
                       is_read, 
                       created_at
                FROM notifications 
                WHERE user_id = ? 
                ORDER BY created_at DESC 
                LIMIT 50
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                println("Error fetching notifications:", err.Error())
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch notifications: " + err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if notifications == nil </span><span class="cov8" title="1">{
                notifications = []NotificationRow{}
        }</span>

        // Count unread
        <span class="cov8" title="1">var unreadCount int
        config.DB.Get(&amp;unreadCount, `SELECT COUNT(*) FROM notifications WHERE user_id = ? AND is_read = FALSE`, userID)

        c.JSON(http.StatusOK, gin.H{
                "notifications": notifications,
                "unread_count":  unreadCount,
        })</span>
}

// =============================
// MARK NOTIFICATION AS READ
// =============================
func MarkNotificationAsRead(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")
        notifID := c.Param("id")

        _, err := config.DB.Exec(`
                UPDATE notifications SET is_read = TRUE 
                WHERE id = ? AND user_id = ?
        `, notifID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to mark as read"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "Marked as read"})</span>
}

// =============================
// MARK ALL AS READ
// =============================
func MarkAllNotificationsAsRead(c *gin.Context) <span class="cov8" title="1">{
        userID := c.GetInt64("user_id")

        _, err := config.DB.Exec(`UPDATE notifications SET is_read = TRUE WHERE user_id = ?`, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to mark all as read"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "All notifications marked as read"})</span>
}

// =============================
// CREATE NOTIFICATION (Internal helper)
// =============================
func CreateNotification(userID int64, notifType, title, message string) error <span class="cov8" title="1">{
        _, err := config.DB.Exec(`
                INSERT INTO notifications (user_id, type, title, message, is_read, created_at)
                VALUES (?, ?, ?, ?, FALSE, ?)
        `, userID, notifType, title, message, time.Now())
        return err
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
)

// =============================
// USER APPLY ORGANIZATION
// =============================

type ApplyOrganizationRequest struct {
        OrgName        string `json:"org_name" binding:"required"`
        OrgDescription string `json:"org_description"`
        OrgCategory    string `json:"org_category"`
        OrgLogoURL     string `json:"org_logo_url"`

        OrgEmail   string `json:"org_email"`
        OrgPhone   string `json:"org_phone"`
        OrgWebsite string `json:"org_website"`

        Reason      string `json:"reason" binding:"required"`
        SocialMedia string `json:"social_media"`
}

func ApplyOrganization(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // 1. Check if user already has a pending application
        var count int
        config.DB.Get(&amp;count,
                "SELECT COUNT(*) FROM organization_applications WHERE user_id = ? AND status = 'PENDING'",
                userID,
        )

        if count &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "You already have a pending application"})
                return
        }</span>

        // 2. Bind JSON request
        <span class="cov0" title="0">var req ApplyOrganizationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request", "details": err.Error()})
                return
        }</span>

        // 3. Insert into database
        <span class="cov0" title="0">_, err := config.DB.Exec(`
                INSERT INTO organization_applications 
                (user_id, org_name, org_description, org_category, org_logo_url, 
                 org_email, org_phone, org_website, reason, social_media, submitted_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,
                userID,
                req.OrgName,
                req.OrgDescription,
                req.OrgCategory,
                req.OrgLogoURL,
                req.OrgEmail,
                req.OrgPhone,
                req.OrgWebsite,
                req.Reason,
                req.SocialMedia,
                time.Now(),
        )

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to submit application"})
                return
        }</span>

        // Notify all admins about new application
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // Get applicant name
                var applicantName string
                config.DB.Get(&amp;applicantName, "SELECT name FROM users WHERE id = ?", userID)

                // Get all admin user IDs
                var adminIDs []int64
                config.DB.Select(&amp;adminIDs, `
                        SELECT u.id FROM users u
                        JOIN user_roles ur ON u.id = ur.user_id
                        JOIN roles r ON ur.role_id = r.id
                        WHERE r.name = 'ADMIN'
                `)

                // Send notification to each admin
                for _, adminID := range adminIDs </span><span class="cov0" title="0">{
                        CreateNotification(
                                adminID,
                                "new_application",
                                "📝 Pengajuan Baru!",
                                applicantName+" mengajukan organisasi \""+req.OrgName+"\"",
                        )
                }</span>
        }()

        // 4. Return success
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Organization application submitted successfully",
        })</span>
}

// =============================
// USER: GET MY APPLICATION STATUS
// =============================
func GetMyApplicationStatus(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        type ApplicationStatus struct {
                ID          int64   `db:"id" json:"id"`
                Status      string  `db:"status" json:"status"`
                OrgName     string  `db:"org_name" json:"org_name"`
                SubmittedAt string  `db:"submitted_at" json:"submitted_at"`
                ReviewedAt  *string `db:"reviewed_at" json:"reviewed_at,omitempty"`
                ReviewNote  *string `db:"review_note" json:"review_note,omitempty"`
        }

        var app ApplicationStatus
        err := config.DB.Get(&amp;app, `
                SELECT id, status, org_name, submitted_at, reviewed_at, review_note
                FROM organization_applications 
                WHERE user_id = ? 
                ORDER BY submitted_at DESC 
                LIMIT 1
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                // No application found
                c.JSON(http.StatusOK, gin.H{
                        "has_application": false,
                        "application":     nil,
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "has_application": true,
                "application":     app,
        })</span>
}

// Request Structure for Session
type CreateSessionRequest struct {
        Title       string `json:"title" binding:"required"`
        Description string `json:"description"`
        Price       int64  `json:"price"`
}

// =======================================
// ORGANIZATION: CREATE SESSION
// =======================================
func CreateSession(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")

        userID := c.GetInt64("user_id")
        orgID, err := getOrganizationIDByUser(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid organization"})
                return
        }</span>

        // Check event ownership
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, "SELECT COUNT(*) FROM events WHERE id = ? AND organization_id = ?", eventID, orgID)
        if count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Event not found or access denied"})
                return
        }</span>

        <span class="cov0" title="0">var req CreateSessionRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var maxOrder int
        config.DB.Get(&amp;maxOrder, "SELECT COALESCE(MAX(order_index), 0) FROM sessions WHERE event_id = ?", eventID)

        res, err := config.DB.Exec(`
                INSERT INTO sessions (event_id, title, description, price, order_index, created_at)
                VALUES (?, ?, ?, ?, ?, ?)
        `,
                eventID, req.Title, req.Description, req.Price, maxOrder+1, time.Now(),
        )

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ Error Create Session:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create session"})
                return
        }</span>

        <span class="cov0" title="0">sessionID, _ := res.LastInsertId()

        // Notify users who have purchased sessions from this event
        go func() </span><span class="cov0" title="0">{
                // Get event title
                var eventTitle string
                config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", eventID)

                // Get all users who purchased any session of this event
                var buyerIDs []int64
                config.DB.Select(&amp;buyerIDs, `
                        SELECT DISTINCT p.user_id 
                        FROM purchases p
                        JOIN sessions s ON p.session_id = s.id
                        WHERE s.event_id = ?
                `, eventID)

                // Send notification to each buyer
                for _, buyerID := range buyerIDs </span><span class="cov0" title="0">{
                        CreateNotification(
                                buyerID,
                                "new_session",
                                "📚 Sesi Baru Tersedia!",
                                "Event \""+eventTitle+"\" menambahkan sesi baru: \""+req.Title+"\"",
                        )
                }</span>
        }()

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session created!", "session_id": sessionID})</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "os"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
        "BACKEND/models"
)

// =======================================
// PUBLIC: GET ALL ORGANIZATIONS
// =======================================
func GetPublicOrganizations(c *gin.Context) <span class="cov0" title="0">{
        var organizations []struct {
                ID          int64   `db:"id" json:"id"`
                Name        string  `db:"name" json:"name"`
                Description *string `db:"description" json:"description"`
                Category    *string `db:"category" json:"category"`
                LogoURL     *string `db:"logo_url" json:"logo_url"`
                Email       *string `db:"email" json:"email"`
                Phone       *string `db:"phone" json:"phone"`
                Website     *string `db:"website" json:"website"`
                SocialLink  *string `db:"social_link" json:"social_link"`
                Address     *string `db:"address" json:"address"`
                EventCount  int     `db:"event_count" json:"event_count"`
        }

        err := config.DB.Select(&amp;organizations, `
                SELECT o.id, o.name, o.description, o.category, o.logo_url,
                        o.email, o.phone, o.website, o.social_link, o.address,
                        (SELECT COUNT(*) FROM events e WHERE e.organization_id = o.id AND e.publish_status = 'PUBLISHED') as event_count
                FROM organizations o
                ORDER BY event_count DESC, o.name ASC
                LIMIT 50
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to fetch organizations"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, gin.H{"organizations": organizations})</span>
}

// =======================================
// ORGANIZATION: GET PROFILE
// =======================================
func GetOrganizationProfile(c *gin.Context) <span class="cov0" title="0">{

        // Read user_id from context robustly
        var userID int64
        if v, ok := c.Get("user_id"); ok </span><span class="cov0" title="0">{
                switch t := v.(type) </span>{
                case int64:<span class="cov0" title="0">
                        userID = t</span>
                case int:<span class="cov0" title="0">
                        userID = int64(t)</span>
                case float64:<span class="cov0" title="0">
                        userID = int64(t)</span>
                default:<span class="cov0" title="0">
                        userID = 0</span>
                }
        }

        // Debug: Print the user_id we're searching for
        <span class="cov0" title="0">fmt.Printf("DEBUG GetOrganizationProfile: Searching for owner_user_id=%d\n", userID)

        var org models.Organization

        err := config.DB.Get(&amp;org, `
                SELECT * FROM organizations WHERE owner_user_id = ?
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                // Log for debugging
                fmt.Printf("DEBUG: No organization found for user_id=%d, error=%v\n", userID, err)
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "Organization profile not found",
                        "user_id": userID,
                })
                return
        }</span>

        // Debug: Success
        <span class="cov0" title="0">fmt.Printf("DEBUG: Found organization ID=%d, name='%s' for user_id=%d\n", org.ID, org.Name, userID)
        c.JSON(http.StatusOK, gin.H{"organization": org})</span>
}

// =======================================
// ORGANIZATION: UPDATE PROFILE
// =======================================

type UpdateOrgProfileRequest struct {
        Name        string `json:"name"`
        Description string `json:"description"`
        Category    string `json:"category"`
        LogoURL     string `json:"logo_url"`
        Email       string `json:"email"`
        Phone       string `json:"phone"`
        Website     string `json:"website"`
        SocialLink  string `json:"social_link"`
        Address     string `json:"address"`
}

func UpdateOrganizationProfile(c *gin.Context) <span class="cov0" title="0">{

        userID := c.GetInt64("user_id")

        var req UpdateOrgProfileRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`
                UPDATE organizations 
                SET name = ?, 
                        description = ?, 
                        category = ?, 
                        logo_url = ?, 
                        email = ?, 
                        phone = ?, 
                        website = ?,
                        social_link = ?,
                        address = ?
                WHERE owner_user_id = ?
        `,
                req.Name,
                req.Description,
                req.Category,
                req.LogoURL,
                req.Email,
                req.Phone,
                req.Website,
                req.SocialLink,
                req.Address,
                userID,
        )

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update organization profile"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Organization profile updated successfully",
        })</span>
}

// =======================================
// ORGANIZATION: REPORT (TOTAL EVENT + BUYERS PER EVENT + REVENUE)
// =======================================
func GetOrganizationReport(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // 1. Ambil org id milik user
        var orgID int64
        err := config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Organization not found"})
                return
        }</span>

        // 2. Get events (simpler query)
        <span class="cov0" title="0">type EventBasic struct {
                ID           int64   `db:"id" json:"id"`
                Title        string  `db:"title" json:"title"`
                ThumbnailURL *string `db:"thumbnail_url" json:"thumbnail_url"`
                CreatedAt    string  `db:"created_at" json:"created_at"`
        }

        var eventsBasic []EventBasic
        err = config.DB.Select(&amp;eventsBasic, `
                SELECT id, title, thumbnail_url, created_at
                FROM events WHERE organization_id = ?
                ORDER BY created_at DESC
        `, orgID)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ORG-REPORT] Error fetching events: %v\n", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("[ORG-REPORT] orgID=%d, found %d events\n", orgID, len(eventsBasic))

        // 3. For each event, calculate stats
        type EventStat struct {
                ID                  int64   `json:"id"`
                Title               string  `json:"title"`
                ThumbnailURL        *string `json:"thumbnail_url"`
                Buyers              int     `json:"buyers"`
                GrossRevenue        float64 `json:"gross_revenue"`
                AffiliateCommission float64 `json:"affiliate_commission"`
                NetRevenue          float64 `json:"net_revenue"`
                CreatedAt           string  `json:"created_at"`
        }

        var events []EventStat
        var totalBuyers int
        var totalGrossRevenue, totalAffiliateCommission, totalNetRevenue float64

        for _, eb := range eventsBasic </span><span class="cov0" title="0">{
                var buyers int
                var grossRevenue float64
                var affiliateCommission float64

                config.DB.Get(&amp;buyers, `
                        SELECT COUNT(DISTINCT p.user_id) 
                        FROM purchases p 
                        JOIN sessions s ON p.session_id = s.id 
                        WHERE s.event_id = ? AND p.status = 'PAID'
                `, eb.ID)

                config.DB.Get(&amp;grossRevenue, `
                        SELECT COALESCE(SUM(p.price_paid), 0) 
                        FROM purchases p 
                        JOIN sessions s ON p.session_id = s.id 
                        WHERE s.event_id = ? AND p.status = 'PAID'
                `, eb.ID)

                config.DB.Get(&amp;affiliateCommission, `
                        SELECT COALESCE(SUM(p.price_paid * COALESCE(ap.commission_percentage, 0) / 100), 0)
                        FROM purchases p 
                        JOIN sessions s ON p.session_id = s.id 
                        LEFT JOIN affiliate_partnerships ap ON p.affiliate_code = ap.unique_code AND ap.event_id = s.event_id
                        WHERE s.event_id = ? AND p.status = 'PAID'
                `, eb.ID)

                netRevenue := grossRevenue - affiliateCommission

                events = append(events, EventStat{
                        ID:                  eb.ID,
                        Title:               eb.Title,
                        ThumbnailURL:        eb.ThumbnailURL,
                        Buyers:              buyers,
                        GrossRevenue:        grossRevenue,
                        AffiliateCommission: affiliateCommission,
                        NetRevenue:          netRevenue,
                        CreatedAt:           eb.CreatedAt,
                })

                totalBuyers += buyers
                totalGrossRevenue += grossRevenue
                totalAffiliateCommission += affiliateCommission
                totalNetRevenue += netRevenue
        }</span>

        <span class="cov0" title="0">if events == nil </span><span class="cov0" title="0">{
                events = []EventStat{}
        }</span>

        // 4. Get balance from organization_balances
        <span class="cov0" title="0">var balance struct {
                AvailableBalance float64 `db:"balance"`
                TotalWithdrawn   float64 `db:"total_withdrawn"`
        }
        config.DB.Get(&amp;balance, `
                SELECT COALESCE(balance, 0) as balance, COALESCE(total_withdrawn, 0) as total_withdrawn
                FROM organization_balances WHERE organization_id = ?
        `, orgID)

        c.JSON(200, gin.H{
                "total_events":         len(events),
                "total_buyers":         totalBuyers,
                "events":               events,
                "gross_revenue":        totalGrossRevenue,
                "affiliate_commission": totalAffiliateCommission,
                "net_revenue":          totalNetRevenue,
                "available_balance":    balance.AvailableBalance,
                "total_withdrawn":      balance.TotalWithdrawn,
        })</span>
}

// =======================================
// ORGANIZATION: UPLOAD LOGO
// =======================================
func UploadOrganizationLogo(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get file from form
        file, err := c.FormFile("logo")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Logo file is required"})
                return
        }</span>

        // Validate file size (max 2MB)
        <span class="cov0" title="0">if file.Size &gt; 2*1024*1024 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File size must be less than 2MB"})
                return
        }</span>

        // Generate unique filename
        <span class="cov0" title="0">ext := ".jpg"
        if file.Filename != "" </span><span class="cov0" title="0">{
                for _, e := range []string{".png", ".jpg", ".jpeg", ".gif", ".webp"} </span><span class="cov0" title="0">{
                        if len(file.Filename) &gt; len(e) &amp;&amp; file.Filename[len(file.Filename)-len(e):] == e </span><span class="cov0" title="0">{
                                ext = e
                                break</span>
                        }
                }
        }

        // Get org ID
        <span class="cov0" title="0">var orgID int64
        err = config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Organization not found"})
                return
        }</span>

        // Create directory if not exists
        <span class="cov0" title="0">uploadDir := "uploads/organization"
        if err := os.MkdirAll(uploadDir, 0755); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create upload directory"})
                return
        }</span>

        // Generate unique filename with timestamp
        <span class="cov0" title="0">filename := fmt.Sprintf("org_logo_%d_%d%s", orgID, time.Now().UnixNano(), ext)
        uploadPath := uploadDir + "/" + filename

        // Save file
        if err := c.SaveUploadedFile(file, uploadPath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save logo file: " + err.Error()})
                return
        }</span>

        // Update database
        <span class="cov0" title="0">_, err = config.DB.Exec(`UPDATE organizations SET logo_url = ? WHERE owner_user_id = ?`, uploadPath, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update logo URL"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message":  "Logo uploaded successfully",
                "logo_url": uploadPath,
        })</span>
}

// =======================================
// ORGANIZATION: GET EVENT BUYERS
// =======================================
func GetEventBuyers(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        eventID := c.Param("eventID")

        fmt.Printf("[EVENT-BUYERS] Request: userID=%d, eventID=%s\n", userID, eventID)

        // Verify organization owns this event
        var orgID int64
        err := config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[EVENT-BUYERS] Error: Organization not found for user %d: %v\n", userID, err)
                c.JSON(400, gin.H{"error": "Organization not found"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[EVENT-BUYERS] Found orgID=%d for userID=%d\n", orgID, userID)

        var eventOrgID int64
        err = config.DB.Get(&amp;eventOrgID, `SELECT organization_id FROM events WHERE id = ?`, eventID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[EVENT-BUYERS] Error: Event %s not found: %v\n", eventID, err)
                c.JSON(403, gin.H{"error": "Event not found"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[EVENT-BUYERS] Event %s has organization_id=%d (my org=%d)\n", eventID, eventOrgID, orgID)

        if eventOrgID != orgID </span><span class="cov0" title="0">{
                fmt.Printf("[EVENT-BUYERS] Error: Event org mismatch! eventOrgID=%d != orgID=%d\n", eventOrgID, orgID)
                c.JSON(403, gin.H{"error": "Event not owned by your organization"})
                return
        }</span>

        // Get detailed purchase list (individual purchases, not grouped)
        <span class="cov0" title="0">type PurchaseDetail struct {
                ID               int64   `db:"id" json:"id"`
                UserID           int64   `db:"user_id" json:"user_id"`
                UserName         string  `db:"user_name" json:"user_name"`
                UserEmail        string  `db:"user_email" json:"user_email"`
                UserPhone        string  `db:"user_phone" json:"user_phone"`
                SessionID        int64   `db:"session_id" json:"session_id"`
                SessionTitle     string  `db:"session_title" json:"session_title"`
                PricePaid        float64 `db:"price_paid" json:"price_paid"`
                AffiliateCode    string  `db:"affiliate_code" json:"affiliate_code"`
                AffiliateName    string  `db:"affiliate_name" json:"affiliate_name"`
                CommissionPct    float64 `db:"commission_pct" json:"commission_pct"`
                CommissionAmount float64 `db:"commission_amount" json:"commission_amount"`
                NetAmount        float64 `db:"net_amount" json:"net_amount"`
                PurchasedAt      string  `db:"purchased_at" json:"purchased_at"`
                PaymentStatus    string  `db:"payment_status" json:"payment_status"`
        }

        var purchases []PurchaseDetail

        // Debug: First check if there are ANY purchases for this event
        var rawCount int
        config.DB.Get(&amp;rawCount, `
                SELECT COUNT(*) FROM purchases p 
                JOIN sessions s ON p.session_id = s.id 
                WHERE s.event_id = ?
        `, eventID)
        fmt.Printf("[EVENT-BUYERS] Raw purchase count for eventID=%s: %d\n", eventID, rawCount)

        // Also check paid only
        var debugPaidCount int
        config.DB.Get(&amp;debugPaidCount, `
                SELECT COUNT(*) FROM purchases p 
                JOIN sessions s ON p.session_id = s.id 
                WHERE s.event_id = ? AND p.status = 'PAID'
        `, eventID)
        fmt.Printf("[EVENT-BUYERS] Paid purchase count for eventID=%s: %d\n", eventID, debugPaidCount)

        // Try the full query with affiliate info
        query := `
                SELECT 
                        p.id,
                        p.user_id,
                        u.name as user_name,
                        u.email as user_email,
                        COALESCE(u.phone, '') as user_phone,
                        p.session_id,
                        s.title as session_title,
                        p.price_paid,
                        COALESCE(p.affiliate_code, '') as affiliate_code,
                        COALESCE(aff_user.name, '') as affiliate_name,
                        COALESCE(ap.commission_percentage, 0) as commission_pct,
                        CASE 
                                WHEN ap.commission_percentage IS NOT NULL 
                                THEN p.price_paid * ap.commission_percentage / 100 
                                ELSE 0 
                        END as commission_amount,
                        CASE 
                                WHEN ap.commission_percentage IS NOT NULL 
                                THEN p.price_paid - (p.price_paid * ap.commission_percentage / 100) 
                                ELSE p.price_paid 
                        END as net_amount,
                        p.purchased_at as purchased_at,
                        COALESCE(p.status, 'PENDING') as payment_status
                FROM purchases p
                JOIN users u ON p.user_id = u.id
                JOIN sessions s ON p.session_id = s.id
                LEFT JOIN affiliate_partnerships ap ON p.affiliate_code = ap.unique_code AND ap.event_id = s.event_id
                LEFT JOIN users aff_user ON ap.user_id = aff_user.id
                WHERE s.event_id = ?
                ORDER BY p.purchased_at DESC
        `
        err = config.DB.Select(&amp;purchases, query, eventID)

        // Debug logging
        fmt.Printf("[EVENT-BUYERS] eventID=%s, purchases_count=%d, err=%v\n", eventID, len(purchases), err)

        // If main query failed or returned empty but we know there are purchases, try simpler query
        if (err != nil || len(purchases) == 0) &amp;&amp; rawCount &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("[EVENT-BUYERS] Trying fallback query...\n")

                // Simpler query without affiliate joins
                fallbackQuery := `
                        SELECT 
                                p.id,
                                p.user_id,
                                u.name as user_name,
                                u.email as user_email,
                                COALESCE(u.phone, '') as user_phone,
                                p.session_id,
                                s.title as session_title,
                                p.price_paid,
                                COALESCE(p.affiliate_code, '') as affiliate_code,
                                '' as affiliate_name,
                                0 as commission_pct,
                                0 as commission_amount,
                                p.price_paid as net_amount,
                                p.purchased_at as purchased_at,
                                COALESCE(p.status, 'PENDING') as payment_status
                        FROM purchases p
                        JOIN users u ON p.user_id = u.id
                        JOIN sessions s ON p.session_id = s.id
                        WHERE s.event_id = ?
                        ORDER BY p.purchased_at DESC
                `
                err = config.DB.Select(&amp;purchases, fallbackQuery, eventID)
                fmt.Printf("[EVENT-BUYERS] Fallback result: purchases_count=%d, err=%v\n", len(purchases), err)
        }</span>

        <span class="cov0" title="0">if purchases == nil </span><span class="cov0" title="0">{
                purchases = []PurchaseDetail{}
        }</span>

        // Calculate summary
        <span class="cov0" title="0">var totalRevenue, totalCommission, totalNetRevenue float64
        var paidCount, pendingCount int
        for _, p := range purchases </span><span class="cov0" title="0">{
                if p.PaymentStatus == "PAID" </span><span class="cov0" title="0">{
                        totalRevenue += p.PricePaid
                        totalCommission += p.CommissionAmount
                        totalNetRevenue += p.NetAmount
                        paidCount++
                }</span> else<span class="cov0" title="0"> {
                        pendingCount++
                }</span>
        }

        <span class="cov0" title="0">c.JSON(200, gin.H{
                "purchases": purchases,
                "summary": gin.H{
                        "total_purchases":  len(purchases),
                        "paid_count":       paidCount,
                        "pending_count":    pendingCount,
                        "gross_revenue":    totalRevenue,
                        "total_commission": totalCommission,
                        "net_revenue":      totalNetRevenue,
                },
        })</span>
}

// =======================================
// ORGANIZATION: BALANCE &amp; WITHDRAWAL
// =======================================

// GetOrganizationBalance - Get balance summary for organization
func GetOrganizationBalance(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get org ID
        var orgID int64
        err := config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Organization not found"})
                return
        }</span>

        <span class="cov0" title="0">var balance struct {
                TotalEarned      float64 `db:"total_earned" json:"total_earned"`
                TotalWithdrawn   float64 `db:"total_withdrawn" json:"total_withdrawn"`
                AvailableBalance float64 `json:"available_balance"`
        }

        // Get from organization_balances table
        err = config.DB.Get(&amp;balance, `
                SELECT COALESCE(total_earned, 0) as total_earned, 
                       COALESCE(total_withdrawn, 0) as total_withdrawn
                FROM organization_balances WHERE organization_id = ?
        `, orgID)

        if err != nil </span><span class="cov0" title="0">{
                // No balance record - calculate from purchases
                config.DB.Get(&amp;balance.TotalEarned, `
                        SELECT COALESCE(SUM(p.price_paid), 0)
                        FROM purchases p
                        JOIN sessions s ON p.session_id = s.id
                        JOIN events e ON s.event_id = e.id
                        WHERE e.organization_id = ? AND p.status = 'PAID'
                `, orgID)
                balance.TotalWithdrawn = 0
        }</span>

        <span class="cov0" title="0">balance.AvailableBalance = balance.TotalEarned - balance.TotalWithdrawn

        c.JSON(200, gin.H{"balance": balance, "organization_id": orgID})</span>
}

// SimulateOrgWithdraw - Simulate instant withdrawal for organization
func SimulateOrgWithdraw(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get org ID
        var orgID int64
        err := config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Organization not found"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                Amount        float64 `json:"amount" binding:"required"`
                PaymentMethod string  `json:"payment_method" binding:"required"`
                AccountName   string  `json:"account_name" binding:"required"`
                AccountNumber string  `json:"account_number" binding:"required"`
                BankName      string  `json:"bank_name"`
        }

        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Data tidak lengkap"})
                return
        }</span>

        // Minimum withdrawal Rp 50,000
        <span class="cov0" title="0">if input.Amount &lt; 50000 </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Minimal penarikan Rp 50.000"})
                return
        }</span>

        // Get current balance
        <span class="cov0" title="0">var balance struct {
                TotalEarned    float64 `db:"total_earned"`
                TotalWithdrawn float64 `db:"total_withdrawn"`
        }
        err = config.DB.Get(&amp;balance, `
                SELECT COALESCE(total_earned, 0) as total_earned, 
                       COALESCE(total_withdrawn, 0) as total_withdrawn
                FROM organization_balances WHERE organization_id = ?
        `, orgID)

        if err != nil </span><span class="cov0" title="0">{
                // No balance record - check purchases
                config.DB.Get(&amp;balance.TotalEarned, `
                        SELECT COALESCE(SUM(p.price_paid), 0)
                        FROM purchases p
                        JOIN sessions s ON p.session_id = s.id
                        JOIN events e ON s.event_id = e.id
                        WHERE e.organization_id = ? AND p.status = 'PAID'
                `, orgID)
        }</span>

        <span class="cov0" title="0">availableBalance := balance.TotalEarned - balance.TotalWithdrawn

        if input.Amount &gt; availableBalance </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": fmt.Sprintf("Saldo tidak cukup. Saldo tersedia: Rp %.0f", availableBalance)})
                return
        }</span>

        // Update balance - simulate instant withdrawal
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                INSERT INTO organization_balances (organization_id, total_earned, total_withdrawn, balance)
                VALUES (?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE 
                        total_withdrawn = total_withdrawn + ?,
                        balance = total_earned - (total_withdrawn + ?)
        `, orgID, balance.TotalEarned, input.Amount, balance.TotalEarned-input.Amount, input.Amount, input.Amount)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ORG WITHDRAW] Error updating balance: %v\n", err)
                c.JSON(500, gin.H{"error": "Gagal memproses penarikan"})
                return
        }</span>

        // Record transaction
        <span class="cov0" title="0">withdrawRef := fmt.Sprintf("WD-ORG-%d-%d", time.Now().Unix(), orgID)
        description := fmt.Sprintf("Penarikan ke %s - %s (%s)", input.PaymentMethod, input.AccountName, input.AccountNumber)
        if input.PaymentMethod == "BANK" &amp;&amp; input.BankName != "" </span><span class="cov0" title="0">{
                description = fmt.Sprintf("Penarikan ke %s %s - %s (%s)", input.BankName, input.PaymentMethod, input.AccountName, input.AccountNumber)
        }</span>

        <span class="cov0" title="0">config.DB.Exec(`
                INSERT INTO financial_transactions (transaction_type, entity_type, entity_id, amount, description, reference_id)
                VALUES ('WITHDRAWAL', 'ORGANIZATION', ?, ?, ?, ?)
        `, orgID, input.Amount, description, withdrawRef)

        fmt.Printf("[ORG WITHDRAW] ✅ Org %d withdrew Rp %.0f to %s\n", orgID, input.Amount, input.PaymentMethod)

        c.JSON(200, gin.H{
                "message":     "Penarikan berhasil diproses",
                "amount":      input.Amount,
                "reference":   withdrawRef,
                "new_balance": availableBalance - input.Amount,
        })</span>
}

// GetOrgWithdrawalHistory - Get withdrawal transaction history for organization
func GetOrgWithdrawalHistory(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get org ID
        var orgID int64
        err := config.DB.Get(&amp;orgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Organization not found"})
                return
        }</span>

        <span class="cov0" title="0">var transactions []struct {
                ID          int64   `db:"id" json:"id"`
                Amount      float64 `db:"amount" json:"amount"`
                Description string  `db:"description" json:"description"`
                ReferenceID string  `db:"reference_id" json:"reference_id"`
                CreatedAt   string  `db:"created_at" json:"created_at"`
        }

        config.DB.Select(&amp;transactions, `
                SELECT id, amount, description, reference_id, created_at
                FROM financial_transactions
                WHERE entity_type = 'ORGANIZATION' AND entity_id = ? AND transaction_type = 'WITHDRAWAL'
                ORDER BY created_at DESC
                LIMIT 50
        `, orgID)

        c.JSON(200, gin.H{"transactions": transactions})</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package controllers

import (
        "BACKEND/config"
        "BACKEND/utils"
        "fmt"
        "math/rand"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"
)

// ================================
// FORGOT PASSWORD - Request Reset Code
// ================================
type ForgotPasswordRequest struct {
        Email string `json:"email" binding:"required,email"`
}

func ForgotPassword(c *gin.Context) <span class="cov0" title="0">{
        var req ForgotPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Email tidak valid"})
                return
        }</span>

        // Find user by email
        <span class="cov0" title="0">var user struct {
                ID   int64  `db:"id"`
                Name string `db:"name"`
        }
        err := config.DB.Get(&amp;user, "SELECT id, name FROM users WHERE email = ?", req.Email)

        // Always return success for security (don't reveal if email exists)
        if err != nil </span><span class="cov0" title="0">{
                println("Password reset requested for non-existent email:", req.Email)
                c.JSON(http.StatusOK, gin.H{
                        "message": "Jika email terdaftar, Anda akan menerima kode verifikasi.",
                })
                return
        }</span>

        // Generate 6-digit code
        <span class="cov0" title="0">rand.Seed(time.Now().UnixNano())
        code := fmt.Sprintf("%06d", rand.Intn(1000000))

        // Set expiry to 15 minutes from now
        expiresAt := time.Now().Add(15 * time.Minute)

        // Delete any existing tokens for this user
        config.DB.Exec("DELETE FROM password_reset_tokens WHERE user_id = ?", user.ID)

        // Insert new code
        _, err = config.DB.Exec(`
                INSERT INTO password_reset_tokens (user_id, token, expires_at) 
                VALUES (?, ?, ?)
        `, user.ID, code, expiresAt)

        if err != nil </span><span class="cov0" title="0">{
                println("Failed to save reset code:", err.Error())
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan kode"})
                return
        }</span>

        // Send email asynchronously
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err := utils.SendPasswordResetEmail(req.Email, code, user.Name)
                if err != nil </span><span class="cov0" title="0">{
                        println("Failed to send password reset email:", err.Error())
                }</span>
        }()

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Jika email terdaftar, Anda akan menerima kode verifikasi.",
        })</span>
}

// ================================
// VERIFY CODE - Check if code is valid
// ================================
type VerifyCodeRequest struct {
        Email string `json:"email" binding:"required,email"`
        Code  string `json:"code" binding:"required"`
}

func VerifyResetCode(c *gin.Context) <span class="cov0" title="0">{
        var req VerifyCodeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid"})
                return
        }</span>

        // Find user by email
        <span class="cov0" title="0">var userID int64
        err := config.DB.Get(&amp;userID, "SELECT id FROM users WHERE email = ?", req.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode tidak valid"})
                return
        }</span>

        // Find valid code
        <span class="cov0" title="0">var tokenData struct {
                ID        int64     `db:"id"`
                ExpiresAt time.Time `db:"expires_at"`
                Used      bool      `db:"used"`
        }
        err = config.DB.Get(&amp;tokenData, `
                SELECT id, expires_at, used 
                FROM password_reset_tokens 
                WHERE user_id = ? AND token = ?
        `, userID, req.Code)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">if time.Now().After(tokenData.ExpiresAt) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode sudah kadaluarsa"})
                return
        }</span>

        <span class="cov0" title="0">if tokenData.Used </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode sudah digunakan"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"valid": true, "message": "Kode valid"})</span>
}

// ================================
// RESET PASSWORD - Set New Password with Code
// ================================
type ResetPasswordRequest struct {
        Email           string `json:"email" binding:"required,email"`
        Code            string `json:"code" binding:"required"`
        Password        string `json:"password" binding:"required,min=6"`
        ConfirmPassword string `json:"confirm_password" binding:"required"`
}

func ResetPassword(c *gin.Context) <span class="cov0" title="0">{
        var req ResetPasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Data tidak valid. Password minimal 6 karakter."})
                return
        }</span>

        // Validate password match
        <span class="cov0" title="0">if req.Password != req.ConfirmPassword </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Password dan konfirmasi tidak cocok"})
                return
        }</span>

        // Find user by email
        <span class="cov0" title="0">var userID int64
        err := config.DB.Get(&amp;userID, "SELECT id FROM users WHERE email = ?", req.Email)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode tidak valid"})
                return
        }</span>

        // Find valid code
        <span class="cov0" title="0">var tokenData struct {
                ID        int64     `db:"id"`
                ExpiresAt time.Time `db:"expires_at"`
                Used      bool      `db:"used"`
        }
        err = config.DB.Get(&amp;tokenData, `
                SELECT id, expires_at, used 
                FROM password_reset_tokens 
                WHERE user_id = ? AND token = ?
        `, userID, req.Code)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode tidak valid"})
                return
        }</span>

        <span class="cov0" title="0">if time.Now().After(tokenData.ExpiresAt) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode sudah kadaluarsa. Silakan minta kode baru."})
                return
        }</span>

        <span class="cov0" title="0">if tokenData.Used </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Kode sudah digunakan. Silakan minta kode baru."})
                return
        }</span>

        // Hash new password
        <span class="cov0" title="0">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal memproses password"})
                return
        }</span>

        // Update user password
        <span class="cov0" title="0">_, err = config.DB.Exec("UPDATE users SET password_hash = ? WHERE id = ?", string(hashedPassword), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mengupdate password"})
                return
        }</span>

        // Mark code as used and delete all tokens for this user
        <span class="cov0" title="0">config.DB.Exec("DELETE FROM password_reset_tokens WHERE user_id = ?", userID)

        // Send notification to user
        go CreateNotification(
                userID,
                "password_changed",
                "🔐 Password Berhasil Diubah",
                "Password akun Anda telah berhasil direset. Jika Anda tidak melakukan ini, segera hubungi support.",
        )

        c.JSON(http.StatusOK, gin.H{
                "message": "Password berhasil direset! Silakan login dengan password baru.",
        })</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package controllers

import (
        "crypto/sha512"
        "encoding/hex"
        "fmt"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
        "github.com/midtrans/midtrans-go"
        "github.com/midtrans/midtrans-go/snap"
)

// ===============================================
// PAYMENT TOKEN GENERATION
// ===============================================

// GetPaymentTokenInput binds the payment token request
type GetPaymentTokenInput struct {
        SessionID int64 `json:"session_id" binding:"required"`
}

// GetPaymentToken creates a Midtrans Snap token for payment
// POST /api/user/payment/token
func GetPaymentToken(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        var input GetPaymentTokenInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input: " + err.Error()})
                return
        }</span>

        // Get session details
        <span class="cov0" title="0">var session struct {
                ID            int64  `db:"id"`
                Title         string `db:"title"`
                Price         int64  `db:"price"`
                EventID       int64  `db:"event_id"`
                PublishStatus string `db:"publish_status"`
        }

        err := config.DB.Get(&amp;session, `
                SELECT id, title, price, event_id, publish_status 
                FROM sessions WHERE id = ?
        `, input.SessionID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
                return
        }</span>

        <span class="cov0" title="0">if session.PublishStatus != "PUBLISHED" </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Session is not published"})
                return
        }</span>

        // Check if already purchased
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, `
                SELECT COUNT(*) FROM purchases 
                WHERE user_id = ? AND session_id = ? AND status = 'PAID'
        `, userID, input.SessionID)

        if count &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "You already purchased this session"})
                return
        }</span>

        // Get user details
        <span class="cov0" title="0">var user struct {
                Name     string `db:"name"`
                Email    string `db:"email"`
                Phone    string `db:"phone"`
                Username string `db:"username"`
        }
        config.DB.Get(&amp;user, "SELECT name, email, COALESCE(phone, '') as phone, COALESCE(username, '') as username FROM users WHERE id = ?", userID)

        // Check profile completeness - required: name, phone, email, username
        var missingFields []string
        if user.Name == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "nama")
        }</span>
        <span class="cov0" title="0">if user.Email == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "email")
        }</span>
        <span class="cov0" title="0">if user.Phone == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "nomor telepon")
        }</span>
        <span class="cov0" title="0">if user.Username == "" </span><span class="cov0" title="0">{
                missingFields = append(missingFields, "username")
        }</span>

        <span class="cov0" title="0">if len(missingFields) &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":              "Lengkapi profil Anda terlebih dahulu sebelum melakukan pembelian",
                        "missing_fields":     missingFields,
                        "profile_incomplete": true,
                })
                return
        }</span>

        // Get event title for item name
        <span class="cov0" title="0">var eventTitle string
        config.DB.Get(&amp;eventTitle, "SELECT title FROM events WHERE id = ?", session.EventID)

        // Generate unique order ID
        orderID := fmt.Sprintf("ORDER-%d-%d-%d", time.Now().Unix(), session.ID, userID)

        // Create PENDING purchase record
        _, err = config.DB.Exec(`
                INSERT INTO purchases (user_id, session_id, price_paid, status, order_id)
                VALUES (?, ?, ?, 'PENDING', ?)
        `, userID, input.SessionID, session.Price, orderID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create purchase record"})
                return
        }</span>

        // Ensure minimum price (Midtrans requires at least 100 rupiah for QRIS)
        <span class="cov0" title="0">if session.Price &lt; 100 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Harga minimal Rp 100 untuk pembayaran QRIS"})
                return
        }</span>

        // Truncate item name to 50 chars (Midtrans limit)
        <span class="cov0" title="0">itemName := fmt.Sprintf("%s - %s", eventTitle, session.Title)
        if len(itemName) &gt; 50 </span><span class="cov0" title="0">{
                itemName = itemName[:47] + "..."
        }</span>

        // Create Snap request - GoPay/QRIS ONLY
        <span class="cov0" title="0">snapReq := &amp;snap.Request{
                TransactionDetails: midtrans.TransactionDetails{
                        OrderID:  orderID,
                        GrossAmt: session.Price,
                },
                CustomerDetail: &amp;midtrans.CustomerDetails{
                        FName: user.Name,
                        Email: user.Email,
                        Phone: user.Phone,
                },
                Items: &amp;[]midtrans.ItemDetails{
                        {
                                ID:    strconv.FormatInt(session.ID, 10),
                                Name:  itemName,
                                Price: session.Price,
                                Qty:   1,
                        },
                },
                // Only show GoPay (includes QRIS) payment method
                EnabledPayments: []snap.SnapPaymentType{
                        "gopay",
                },
        }

        // Get Snap token
        snapResp, snapErr := config.SnapClient.CreateTransaction(snapReq)
        if snapErr != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create payment token: " + snapErr.Message})
                return
        }</span>

        // Save snap_token to purchase record for later use (continue payment)
        <span class="cov0" title="0">config.DB.Exec(`UPDATE purchases SET snap_token = ? WHERE order_id = ?`, snapResp.Token, orderID)

        c.JSON(http.StatusOK, gin.H{
                "token":        snapResp.Token,
                "redirect_url": snapResp.RedirectURL,
                "order_id":     orderID,
        })</span>
}

// ===============================================
// MIDTRANS WEBHOOK HANDLER
// ===============================================

// MidtransNotification represents the webhook payload
type MidtransNotification struct {
        TransactionStatus string `json:"transaction_status"`
        OrderID           string `json:"order_id"`
        GrossAmount       string `json:"gross_amount"`
        SignatureKey      string `json:"signature_key"`
        StatusCode        string `json:"status_code"`
        PaymentType       string `json:"payment_type"`
        FraudStatus       string `json:"fraud_status"`
}

// HandleMidtransNotification handles webhook notifications from Midtrans
// POST /api/webhook/midtrans
func HandleMidtransNotification(c *gin.Context) <span class="cov0" title="0">{
        var notification MidtransNotification
        if err := c.ShouldBindJSON(&amp;notification); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid notification"})
                return
        }</span>

        // Verify signature (optional but recommended)
        <span class="cov0" title="0">serverKey := os.Getenv("MIDTRANS_SERVER_KEY")
        signatureInput := notification.OrderID + notification.StatusCode + notification.GrossAmount + serverKey
        hash := sha512.Sum512([]byte(signatureInput))
        expectedSignature := hex.EncodeToString(hash[:])

        if notification.SignatureKey != expectedSignature </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid signature"})
                return
        }</span>

        // Process based on transaction status
        <span class="cov0" title="0">switch notification.TransactionStatus </span>{
        case "capture", "settlement":<span class="cov0" title="0">
                // Check fraud status for card payments
                if notification.PaymentType == "credit_card" &amp;&amp; notification.FraudStatus != "accept" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusOK, gin.H{"message": "Fraud detected, ignoring"})
                        return
                }</span>

                // Route to appropriate handler based on order ID prefix
                <span class="cov0" title="0">var err error
                if strings.HasPrefix(notification.OrderID, "CART-") </span><span class="cov0" title="0">{
                        // Cart checkout order
                        err = ProcessCartPayment(notification.OrderID, notification.GrossAmount)
                }</span> else<span class="cov0" title="0"> {
                        // Single session order (legacy)
                        err = processSuccessfulPayment(notification.OrderID, notification.GrossAmount)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                        return
                }</span>

        case "pending":<span class="cov0" title="0">
                // Payment is pending, do nothing
                break</span>

        case "deny", "cancel", "expire":<span class="cov0" title="0">
                // Payment failed
                _, err := config.DB.Exec(`
                        UPDATE purchases SET status = 'FAILED' WHERE order_id = ?
                `, notification.OrderID)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update purchase status"})
                        return
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "OK"})</span>
}

// processSuccessfulPayment handles the logic when payment is successful
func processSuccessfulPayment(orderID string, grossAmount string) error <span class="cov0" title="0">{
        // Parse order ID to get session ID (format: ORDER-{timestamp}-{sessionID}-{userID})
        parts := strings.Split(orderID, "-")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid order ID format")
        }</span>

        <span class="cov0" title="0">sessionID, err := strconv.ParseInt(parts[2], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse session ID")
        }</span>

        // Start transaction
        <span class="cov0" title="0">tx, err := config.DB.Beginx()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start transaction")
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Update purchase status to PAID
        _, err = tx.Exec(`
                UPDATE purchases SET status = 'PAID' WHERE order_id = ?
        `, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update purchase status")
        }</span>

        // Check if this session belongs to an affiliate event
        <span class="cov0" title="0">var affiliateInfo struct {
                AffiliateSubmissionID *int64 `db:"affiliate_submission_id"`
                EventTitle            string `db:"event_title"`
        }

        err = tx.Get(&amp;affiliateInfo, `
                SELECT e.affiliate_submission_id, e.title as event_title
                FROM sessions s
                JOIN events e ON s.event_id = e.id
                WHERE s.id = ?
        `, sessionID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get event info")
        }</span>

        // If this is an affiliate event, create ledger entry AND auto-credit to affiliate balance
        <span class="cov0" title="0">if affiliateInfo.AffiliateSubmissionID != nil </span><span class="cov0" title="0">{
                amount, _ := strconv.ParseFloat(grossAmount, 64)
                platformFee := amount * 0.10     // 10% platform fee
                affiliateAmount := amount * 0.90 // 90% affiliate amount

                _, err = tx.Exec(`
                        INSERT INTO affiliate_ledgers 
                        (affiliate_submission_id, order_id, transaction_amount, platform_fee, affiliate_amount, is_paid_out)
                        VALUES (?, ?, ?, ?, ?, 1)
                `, *affiliateInfo.AffiliateSubmissionID, orderID, amount, platformFee, affiliateAmount)

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create affiliate ledger entry")
                }</span>

                // Get affiliate user ID from submission
                <span class="cov0" title="0">var affiliateInfo2 struct {
                        UserID     *int64 `db:"user_id"`
                        Email      string `db:"email"`
                        EventTitle string `db:"event_title"`
                }
                config.DB.Get(&amp;affiliateInfo2, `
                        SELECT user_id, email, event_title FROM affiliate_submissions WHERE id = ?
                `, *affiliateInfo.AffiliateSubmissionID)

                var affiliateUserID int64
                if affiliateInfo2.UserID != nil </span><span class="cov0" title="0">{
                        affiliateUserID = *affiliateInfo2.UserID
                }</span> else<span class="cov0" title="0"> {
                        // Fallback to email lookup
                        config.DB.Get(&amp;affiliateUserID, "SELECT id FROM users WHERE email = ?", affiliateInfo2.Email)
                }</span>

                // AUTO-CREDIT to affiliate_balances
                <span class="cov0" title="0">if affiliateUserID &gt; 0 </span><span class="cov0" title="0">{
                        // Upsert affiliate balance
                        _, err = tx.Exec(`
                                INSERT INTO affiliate_balances (user_id, balance, total_earned)
                                VALUES (?, ?, ?)
                                ON DUPLICATE KEY UPDATE 
                                        balance = balance + ?,
                                        total_earned = total_earned + ?
                        `, affiliateUserID, affiliateAmount, affiliateAmount, affiliateAmount, affiliateAmount)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[PAYMENT] Error crediting affiliate balance: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[PAYMENT] ✅ Credited Rp %.0f to affiliate user %d\n", affiliateAmount, affiliateUserID)
                        }</span>

                        // Record financial transaction
                        <span class="cov0" title="0">tx.Exec(`
                                INSERT INTO financial_transactions (transaction_type, entity_type, entity_id, amount, description, reference_id)
                                VALUES ('AFFILIATE_CREDIT', 'AFFILIATE', ?, ?, ?, ?)
                        `, affiliateUserID, affiliateAmount, fmt.Sprintf("Penjualan event: %s", affiliateInfo2.EventTitle), orderID)

                        // Notify affiliate about the sale
                        CreateNotification(
                                affiliateUserID,
                                "affiliate_sale",
                                "🛒 Penjualan Baru!",
                                fmt.Sprintf("Event \"%s\" terjual! Anda mendapat Rp %.0f (sudah masuk ke saldo)", affiliateInfo2.EventTitle, affiliateAmount),
                        )</span>
                }
        } else<span class="cov0" title="0"> {
                // Regular organization event - credit to organization balance
                amount, _ := strconv.ParseFloat(grossAmount, 64)

                // Get organization ID from session
                var orgInfo struct {
                        OrgID      int64 `db:"organization_id"`
                        IsOfficial bool  `db:"is_official"`
                }
                config.DB.Get(&amp;orgInfo, `
                        SELECT o.id as organization_id, COALESCE(o.is_official, 0) as is_official
                        FROM sessions s
                        JOIN events e ON s.event_id = e.id
                        JOIN organizations o ON e.organization_id = o.id
                        WHERE s.id = ?
                `, sessionID)

                // Only credit if it's NOT official org (regular org)
                if orgInfo.OrgID &gt; 0 &amp;&amp; !orgInfo.IsOfficial </span><span class="cov0" title="0">{
                        // Upsert organization balance
                        _, err = tx.Exec(`
                                INSERT INTO organization_balances (organization_id, balance, total_earned)
                                VALUES (?, ?, ?)
                                ON DUPLICATE KEY UPDATE 
                                        balance = balance + ?,
                                        total_earned = total_earned + ?
                        `, orgInfo.OrgID, amount, amount, amount, amount)

                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[PAYMENT] Error crediting org balance: %v\n", err)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[PAYMENT] ✅ Credited Rp %.0f to organization %d\n", amount, orgInfo.OrgID)
                        }</span>

                        // Record financial transaction
                        <span class="cov0" title="0">tx.Exec(`
                                INSERT INTO financial_transactions (transaction_type, entity_type, entity_id, amount, description, reference_id)
                                VALUES ('SALE', 'ORGANIZATION', ?, ?, ?, ?)
                        `, orgInfo.OrgID, amount, fmt.Sprintf("Penjualan sesi ID %d", sessionID), orderID)</span>
                }
        }

        // Notify buyer
        <span class="cov0" title="0">var buyerID int64
        config.DB.Get(&amp;buyerID, "SELECT user_id FROM purchases WHERE order_id = ?", orderID)

        if buyerID &gt; 0 </span><span class="cov0" title="0">{
                CreateNotification(
                        buyerID,
                        "purchase_success",
                        "✅ Pembayaran Berhasil!",
                        "Pembelian Anda telah berhasil. Silakan akses konten yang telah dibeli.",
                )
        }</span>

        // Notify organization owner
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                var sessionInfo struct {
                        SessionTitle string `db:"session_title"`
                        EventTitle   string `db:"event_title"`
                        OwnerID      int64  `db:"owner_id"`
                }
                config.DB.Get(&amp;sessionInfo, `
                        SELECT s.title as session_title, e.title as event_title, o.owner_user_id as owner_id
                        FROM sessions s
                        JOIN events e ON s.event_id = e.id
                        JOIN organizations o ON e.organization_id = o.id
                        WHERE s.id = ?
                `, sessionID)

                var buyerName string
                config.DB.Get(&amp;buyerName, "SELECT name FROM users WHERE id = ?", buyerID)

                if sessionInfo.OwnerID &gt; 0 </span><span class="cov0" title="0">{
                        CreateNotification(
                                sessionInfo.OwnerID,
                                "new_purchase",
                                "💰 Pembelian Baru!",
                                buyerName+" membeli sesi \""+sessionInfo.SessionTitle+"\" dari event \""+sessionInfo.EventTitle+"\"",
                        )
                }</span>
        }()

        <span class="cov0" title="0">return tx.Commit()</span>
}

// ===============================================
// HELPER ENDPOINT
// ===============================================

// GetMidtransConfig returns Midtrans client key for frontend
// GET /api/config/midtrans
func GetMidtransConfig(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "client_key": config.GetMidtransClientKey(),
                "is_sandbox": true,
        })
}</span>

// CheckPaymentStatus manually checks and updates payment status from Midtrans
// This is useful for localhost testing where webhook doesn't work
// POST /api/user/payment/check-status
func CheckPaymentStatus(c *gin.Context) <span class="cov0" title="0">{
        var input struct {
                OrderID string `json:"order_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "order_id is required"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[CHECK-STATUS] Checking order: %s\n", input.OrderID)

        // Check if purchase exists (cart orders may have multiple purchases, get any one)
        var purchase struct {
                ID              int64   `db:"id"`
                Status          string  `db:"status"`
                MidtransOrderID *string `db:"midtrans_order_id"`
        }
        err := config.DB.Get(&amp;purchase, "SELECT id, status, midtrans_order_id FROM purchases WHERE order_id = ? LIMIT 1", input.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})
                return
        }</span>

        // If already PAID, no need to check
        <span class="cov0" title="0">if purchase.Status == "PAID" </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "order_id": input.OrderID,
                        "status":   "PAID",
                        "message":  "Pembayaran sudah berhasil",
                })
                return
        }</span>

        // ----------------------------------------------
        // FIX: Check status directly to Midtrans (Active Check)
        // ----------------------------------------------
        // Use midtrans_order_id if available (for cart orders with affiliate code)
        // Otherwise use the input order_id
        <span class="cov0" title="0">midtransOrderID := input.OrderID
        if purchase.MidtransOrderID != nil &amp;&amp; *purchase.MidtransOrderID != "" </span><span class="cov0" title="0">{
                midtransOrderID = *purchase.MidtransOrderID
        }</span>

        <span class="cov0" title="0">fmt.Printf("[CHECK-STATUS] Checking Midtrans with order_id: %s\n", midtransOrderID)

        transactionStatusResp, midtransErr := config.CoreClient.CheckTransaction(midtransOrderID)

        // Handle Midtrans SDK error - check both error and response
        if midtransErr != nil || transactionStatusResp == nil </span><span class="cov0" title="0">{
                fmt.Printf("[CHECK-STATUS] Midtrans check failed or empty response: err=%v, resp=%v\n", midtransErr, transactionStatusResp)
                // If check fails, just return current local status
                c.JSON(http.StatusOK, gin.H{
                        "order_id":       input.OrderID,
                        "current_status": purchase.Status,
                        "message":        "Gagal cek ke Midtrans, status lokal: " + purchase.Status,
                })
                return
        }</span>

        <span class="cov0" title="0">status := transactionStatusResp.TransactionStatus
        fmt.Printf("[CHECK-STATUS] Midtrans status: %s\n", status)

        // If Midtrans says it's paid (capture/settlement), UPDATE OUR DB!
        if status == "capture" || status == "settlement" </span><span class="cov0" title="0">{
                // Route to appropriate handler based on order ID prefix
                // Use input.OrderID (base order) for our handlers since that's what's in the DB
                var processErr error
                if strings.HasPrefix(input.OrderID, "CART-") </span><span class="cov0" title="0">{
                        processErr = ProcessCartPayment(input.OrderID, transactionStatusResp.GrossAmount)
                }</span> else<span class="cov0" title="0"> {
                        processErr = processSuccessfulPayment(input.OrderID, transactionStatusResp.GrossAmount)
                }</span>
                <span class="cov0" title="0">if processErr != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[CHECK-STATUS] Error updating paid status: %v\n", processErr)
                }</span> else<span class="cov0" title="0"> {
                        purchase.Status = "PAID" // Update local var for response
                        fmt.Printf("[CHECK-STATUS] ✅ Updated status to PAID\n")
                }</span>
        } else<span class="cov0" title="0"> if status == "deny" || status == "cancel" || status == "expire" </span><span class="cov0" title="0">{
                // Mark as FAILED
                config.DB.Exec("UPDATE purchases SET status = 'FAILED' WHERE order_id = ?", input.OrderID)
                purchase.Status = "FAILED"
        }</span> else<span class="cov0" title="0"> if status == "pending" </span><span class="cov0" title="0">{
                fmt.Printf("[CHECK-STATUS] Payment still pending\n")
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "order_id": input.OrderID,
                "status":   purchase.Status, // Return the updated status
        })</span>
}

// SimulatePaymentSuccess - FOR SANDBOX TESTING ONLY
// This simulates a successful payment for localhost testing
// POST /api/user/payment/simulate-success
func SimulatePaymentSuccess(c *gin.Context) <span class="cov0" title="0">{
        var input struct {
                OrderID string `json:"order_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "order_id is required"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[SIMULATE] Simulating payment for order: %s\n", input.OrderID)

        // Check if purchase exists and is PENDING
        var purchase struct {
                ID        int64   `db:"id"`
                Status    string  `db:"status"`
                PricePaid float64 `db:"price_paid"`
        }
        err := config.DB.Get(&amp;purchase, "SELECT id, status, price_paid FROM purchases WHERE order_id = ? LIMIT 1", input.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Order not found"})
                return
        }</span>

        <span class="cov0" title="0">if purchase.Status == "PAID" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Order already paid"})
                return
        }</span>

        // Get total amount for cart orders (may have multiple items)
        <span class="cov0" title="0">var totalAmount float64
        config.DB.Get(&amp;totalAmount, "SELECT COALESCE(SUM(price_paid), 0) FROM purchases WHERE order_id = ?", input.OrderID)
        if totalAmount == 0 </span><span class="cov0" title="0">{
                totalAmount = purchase.PricePaid
        }</span>

        // Simulate successful payment - route to correct handler based on order type
        <span class="cov0" title="0">grossAmount := fmt.Sprintf("%.2f", totalAmount)

        if strings.HasPrefix(input.OrderID, "CART-") </span><span class="cov0" title="0">{
                // Cart order - use ProcessCartPayment
                err = ProcessCartPayment(input.OrderID, grossAmount)
        }</span> else<span class="cov0" title="0"> {
                // Single session order
                err = processSuccessfulPayment(input.OrderID, grossAmount)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[SIMULATE] Error: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to process payment: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[SIMULATE] ✅ Payment simulated successfully for order: %s\n", input.OrderID)

        c.JSON(http.StatusOK, gin.H{
                "message":  "Pembayaran berhasil disimulasikan (SANDBOX ONLY)",
                "order_id": input.OrderID,
                "status":   "PAID",
        })</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package controllers

import (
        "strconv"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
)

// =============================
// BUY SESSION
// =============================
func BuySession(c *gin.Context) <span class="cov0" title="0">{

        userID := c.GetInt64("user_id")
        sessionIDstr := c.Param("sessionID")

        sessionID, err := strconv.ParseInt(sessionIDstr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Invalid session ID"})
                return
        }</span>

        // Check session exists and published
        <span class="cov0" title="0">var price float64
        var publishStatus string

        err = config.DB.Get(&amp;price, `
                SELECT price FROM sessions WHERE id = ?
        `, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(404, gin.H{"error": "Session not found"})
                return
        }</span>

        <span class="cov0" title="0">err = config.DB.Get(&amp;publishStatus, `
                SELECT publish_status FROM sessions WHERE id = ?
        `, sessionID)
        if err != nil || publishStatus != "PUBLISHED" </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "Session is not published"})
                return
        }</span>

        // Check if user already bought session
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, `
                SELECT COUNT(*) FROM purchases 
                WHERE user_id = ? AND session_id = ?
        `, userID, sessionID)

        if count &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "You already purchased this session"})
                return
        }</span>

        // Insert new purchase record - FREE sessions get PAID status immediately
        <span class="cov0" title="0">status := "PAID" // For free sessions, mark as PAID immediately
        if price &gt; 0 </span><span class="cov0" title="0">{
                status = "PENDING" // For paid sessions, will be updated by Midtrans webhook
        }</span>

        <span class="cov0" title="0">_, err = config.DB.Exec(`
                INSERT INTO purchases (user_id, session_id, price_paid, status) 
                VALUES (?, ?, ?, ?)
        `, userID, sessionID, price, status)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to complete purchase"})
                return
        }</span>

        // Notify organization owner about the purchase
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                // Get session and event info
                var sessionInfo struct {
                        SessionTitle string `db:"session_title"`
                        EventTitle   string `db:"event_title"`
                        OwnerID      int64  `db:"owner_id"`
                }
                config.DB.Get(&amp;sessionInfo, `
                        SELECT s.title as session_title, e.title as event_title, o.owner_user_id as owner_id
                        FROM sessions s
                        JOIN events e ON s.event_id = e.id
                        JOIN organizations o ON e.organization_id = o.id
                        WHERE s.id = ?
                `, sessionID)

                // Get buyer name
                var buyerName string
                config.DB.Get(&amp;buyerName, "SELECT name FROM users WHERE id = ?", userID)

                // Notify buyer (user) about successful purchase
                CreateNotification(
                        userID,
                        "purchase_success",
                        "✅ Pembelian Berhasil!",
                        "Anda berhasil membeli sesi \""+sessionInfo.SessionTitle+"\" dari event \""+sessionInfo.EventTitle+"\". Selamat belajar!",
                )

                // Notify organization owner about new purchase
                if sessionInfo.OwnerID &gt; 0 </span><span class="cov0" title="0">{
                        CreateNotification(
                                sessionInfo.OwnerID,
                                "new_purchase",
                                "💰 Pembelian Baru!",
                                buyerName+" membeli sesi \""+sessionInfo.SessionTitle+"\" dari event \""+sessionInfo.EventTitle+"\"",
                        )
                }</span>
        }()

        <span class="cov0" title="0">c.JSON(200, gin.H{
                "message":    "Purchase successful",
                "session_id": sessionID,
                "price_paid": price,
        })</span>
}

// =============================
// LIST PURCHASED SESSIONS
// =============================
func MyPurchases(c *gin.Context) <span class="cov0" title="0">{

        userID := c.GetInt64("user_id")

        var purchases []struct {
                PurchaseID   int64   `db:"id" json:"id"`
                SessionID    int64   `db:"session_id" json:"session_id"`
                SessionTitle string  `db:"session_title" json:"session_title"`
                PricePaid    float64 `db:"price_paid" json:"price_paid"`
                EventID      int64   `db:"event_id" json:"event_id"`
                EventTitle   string  `db:"event_title" json:"event_title"`
                EventThumb   *string `db:"thumbnail_url" json:"thumbnail_url"`
        }

        // Return purchases with session + event info so frontend dapat menampilkan grouped view
        err := config.DB.Select(&amp;purchases, `
                SELECT p.id, p.session_id, s.title as session_title, p.price_paid,
                           e.id as event_id, e.title as event_title, e.thumbnail_url
                FROM purchases p
                JOIN sessions s ON p.session_id = s.id
                JOIN events e ON s.event_id = e.id
                WHERE p.user_id = ? AND p.status = 'PAID'
                ORDER BY p.purchased_at DESC
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to load purchased sessions"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(200, gin.H{"purchases": purchases})</span>
}

// =============================
// CHECK SESSION PURCHASE STATUS
// =============================
func CheckSessionPurchase(c *gin.Context) <span class="cov0" title="0">{

        userID := c.GetInt64("user_id")
        sessionIDstr := c.Param("sessionID")

        sessionID, err := strconv.ParseInt(sessionIDstr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(400, gin.H{"error": "Invalid session ID"})
                return
        }</span>

        // 1. Cek sesi ada atau tidak (opsional, agar response rapi)
        <span class="cov0" title="0">var sessionTitle string
        err = config.DB.Get(&amp;sessionTitle, "SELECT title FROM sessions WHERE id = ?", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(404, gin.H{"error": "Session not found"})
                return
        }</span>

        // 2. Cek apakah user sudah membeli DAN status PAID
        <span class="cov0" title="0">var count int
        err = config.DB.Get(&amp;count, `
                SELECT COUNT(*) FROM purchases 
                WHERE user_id = ? AND session_id = ? AND status = 'PAID'
        `, userID, sessionID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to check purchase status"})
                return
        }</span>

        // Jika count &gt; 0 berarti sudah beli (true), jika 0 belum (false)
        <span class="cov0" title="0">hasPurchased := count &gt; 0

        c.JSON(200, gin.H{
                "session_id":    sessionID,
                "session_title": sessionTitle,
                "has_purchased": hasPurchased, // Ini data penting untuk frontend nanti
        })</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package controllers

import (
        "BACKEND/config"
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"
)

// ========================================================
// ORGANIZATION - CERTIFICATE SETTINGS
// ========================================================

// GetCertificateSettings - Get certificate settings for an event
func GetCertificateSettings(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        // Verify ownership
        if !checkEventOwnedByUserID(mustParseInt64(eventID), userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">var settings struct {
                ID               int64   `db:"id" json:"id"`
                EventID          int64   `db:"event_id" json:"event_id"`
                IsEnabled        bool    `db:"is_enabled" json:"is_enabled"`
                MinScorePercent  int     `db:"min_score_percent" json:"min_score_percent"`
                CertificateTitle *string `db:"certificate_title" json:"certificate_title"`
        }

        err := config.DB.Get(&amp;settings, `
                SELECT id, event_id, is_enabled, min_score_percent, certificate_title
                FROM event_certificates WHERE event_id = ?
        `, eventID)

        if err != nil </span><span class="cov0" title="0">{
                // Return default settings if not exists
                c.JSON(http.StatusOK, gin.H{
                        "settings": gin.H{
                                "event_id":          eventID,
                                "is_enabled":        false,
                                "min_score_percent": 80,
                                "certificate_title": nil,
                        },
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"settings": settings})</span>
}

// UpdateCertificateSettings - Update certificate settings
func UpdateCertificateSettings(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        if !checkEventOwnedByUserID(mustParseInt64(eventID), userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                IsEnabled        bool    `json:"is_enabled"`
                MinScorePercent  int     `json:"min_score_percent"`
                CertificateTitle *string `json:"certificate_title"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
                return
        }</span>

        <span class="cov0" title="0">if input.MinScorePercent &lt; 1 || input.MinScorePercent &gt; 100 </span><span class="cov0" title="0">{
                input.MinScorePercent = 80
        }</span>

        // Upsert
        <span class="cov0" title="0">_, err := config.DB.Exec(`
                INSERT INTO event_certificates (event_id, is_enabled, min_score_percent, certificate_title)
                VALUES (?, ?, ?, ?)
                ON DUPLICATE KEY UPDATE is_enabled = VALUES(is_enabled), 
                                        min_score_percent = VALUES(min_score_percent),
                                        certificate_title = VALUES(certificate_title)
        `, eventID, input.IsEnabled, input.MinScorePercent, input.CertificateTitle)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Settings saved"})</span>
}

// ========================================================
// ORGANIZATION - QUIZ MANAGEMENT
// ========================================================

// GetSessionQuiz - Get quiz for a session
func GetSessionQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionID")
        userID := c.GetInt64("user_id")

        // Verify ownership through event
        var eventID int64
        config.DB.Get(&amp;eventID, "SELECT event_id FROM sessions WHERE id = ?", sessionID)
        if !checkEventOwnedByUserID(eventID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">var quiz struct {
                ID        int64  `db:"id" json:"id"`
                SessionID int64  `db:"session_id" json:"session_id"`
                Title     string `db:"title" json:"title"`
                IsEnabled bool   `db:"is_enabled" json:"is_enabled"`
        }

        err := config.DB.Get(&amp;quiz, `SELECT id, session_id, title, is_enabled FROM session_quizzes WHERE session_id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"quiz": nil, "questions": []interface{}{}})
                return
        }</span>

        <span class="cov0" title="0">var questions []struct {
                ID            int64   `db:"id" json:"id"`
                QuestionText  string  `db:"question_text" json:"question_text"`
                OptionA       string  `db:"option_a" json:"option_a"`
                OptionB       string  `db:"option_b" json:"option_b"`
                OptionC       *string `db:"option_c" json:"option_c"`
                OptionD       *string `db:"option_d" json:"option_d"`
                CorrectOption string  `db:"correct_option" json:"correct_option"`
                OrderIndex    int     `db:"order_index" json:"order_index"`
        }
        config.DB.Select(&amp;questions, `SELECT id, question_text, option_a, option_b, option_c, option_d, correct_option, order_index FROM quiz_questions WHERE quiz_id = ? ORDER BY order_index`, quiz.ID)

        c.JSON(http.StatusOK, gin.H{"quiz": quiz, "questions": questions})</span>
}

// SaveSessionQuiz - Create or update quiz with questions
func SaveSessionQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionID")
        userID := c.GetInt64("user_id")

        fmt.Printf("[DEBUG SaveSessionQuiz] sessionID=%s, userID=%d\n", sessionID, userID)

        var eventID int64
        err := config.DB.Get(&amp;eventID, "SELECT event_id FROM sessions WHERE id = ?", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Session not found: %v\n", err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Session not found"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[DEBUG] eventID=%d, checking ownership\n", eventID)

        if !checkEventOwnedByUserID(eventID, userID) </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Ownership check failed for eventID=%d, userID=%d\n", eventID, userID)
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied - not owner of this event"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                Title     string `json:"title"`
                IsEnabled bool   `json:"is_enabled"`
                Questions []struct {
                        QuestionText  string  `json:"question_text"`
                        OptionA       string  `json:"option_a"`
                        OptionB       string  `json:"option_b"`
                        OptionC       *string `json:"option_c"`
                        OptionD       *string `json:"option_d"`
                        CorrectOption string  `json:"correct_option"`
                } `json:"questions"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
                return
        }</span>

        <span class="cov0" title="0">if len(input.Questions) &gt; 10 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Maximum 10 questions allowed"})
                return
        }</span>

        // Upsert quiz
        <span class="cov0" title="0">result, err := config.DB.Exec(`
                INSERT INTO session_quizzes (session_id, title, is_enabled)
                VALUES (?, ?, ?)
                ON DUPLICATE KEY UPDATE title = VALUES(title), is_enabled = VALUES(is_enabled)
        `, sessionID, input.Title, input.IsEnabled)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save quiz"})
                return
        }</span>

        // Get quiz ID
        <span class="cov0" title="0">var quizID int64
        config.DB.Get(&amp;quizID, "SELECT id FROM session_quizzes WHERE session_id = ?", sessionID)
        if quizID == 0 </span><span class="cov0" title="0">{
                quizID, _ = result.LastInsertId()
        }</span>

        // Delete old questions and insert new
        <span class="cov0" title="0">config.DB.Exec("DELETE FROM quiz_questions WHERE quiz_id = ?", quizID)

        for i, q := range input.Questions </span><span class="cov0" title="0">{
                config.DB.Exec(`
                        INSERT INTO quiz_questions (quiz_id, question_text, option_a, option_b, option_c, option_d, correct_option, order_index)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                `, quizID, q.QuestionText, q.OptionA, q.OptionB, q.OptionC, q.OptionD, q.CorrectOption, i+1)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Quiz saved", "quiz_id": quizID})</span>
}

// DeleteSessionQuiz - Delete quiz
func DeleteSessionQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionID")
        userID := c.GetInt64("user_id")

        var eventID int64
        config.DB.Get(&amp;eventID, "SELECT event_id FROM sessions WHERE id = ?", sessionID)
        if !checkEventOwnedByUserID(eventID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">config.DB.Exec("DELETE FROM session_quizzes WHERE session_id = ?", sessionID)
        c.JSON(http.StatusOK, gin.H{"message": "Quiz deleted"})</span>
}

// ========================================================
// USER - QUIZ TAKING &amp; PROGRESS
// ========================================================

// GetUserEventProgress - Get user's progress for an event
func GetUserEventProgress(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        // Get all quizzes for this event
        var quizzes []struct {
                QuizID      int64  `db:"quiz_id"`
                SessionID   int64  `db:"session_id"`
                SessionName string `db:"session_name"`
        }
        config.DB.Select(&amp;quizzes, `
                SELECT sq.id as quiz_id, s.id as session_id, s.title as session_name
                FROM session_quizzes sq
                JOIN sessions s ON sq.session_id = s.id
                WHERE s.event_id = ? AND sq.is_enabled = 1
        `, eventID)

        if len(quizzes) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "has_quizzes":     false,
                        "progress":        []interface{}{},
                        "total_percent":   0,
                        "can_certificate": false,
                })
                return
        }</span>

        // Get user attempts for each quiz
        <span class="cov0" title="0">weightPerQuiz := 100.0 / float64(len(quizzes))
        var totalScore float64
        var progress []gin.H

        for _, q := range quizzes </span><span class="cov0" title="0">{
                var attempt struct {
                        ScorePercent float64 `db:"score_percent"`
                        Passed       bool    `db:"passed"`
                }
                err := config.DB.Get(&amp;attempt, `
                        SELECT score_percent, passed FROM quiz_attempts 
                        WHERE user_id = ? AND quiz_id = ? 
                        ORDER BY score_percent DESC LIMIT 1
                `, userID, q.QuizID)

                contribution := 0.0
                if err == nil </span><span class="cov0" title="0">{
                        contribution = attempt.ScorePercent * weightPerQuiz / 100.0
                        totalScore += contribution
                }</span>

                <span class="cov0" title="0">progress = append(progress, gin.H{
                        "session_id":   q.SessionID,
                        "session_name": q.SessionName,
                        "quiz_id":      q.QuizID,
                        "score":        attempt.ScorePercent,
                        "passed":       attempt.Passed,
                        "weight":       weightPerQuiz,
                        "contribution": contribution,
                        "completed":    err == nil,
                })</span>
        }

        // Check certificate eligibility
        <span class="cov0" title="0">var minScore int
        config.DB.Get(&amp;minScore, "SELECT COALESCE(min_score_percent, 80) FROM event_certificates WHERE event_id = ?", eventID)
        if minScore == 0 </span><span class="cov0" title="0">{
                minScore = 80
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "has_quizzes":        true,
                "progress":           progress,
                "total_percent":      totalScore,
                "min_score_required": minScore,
                "can_certificate":    totalScore &gt;= float64(minScore),
        })</span>
}

// GetQuizForUser - Get quiz questions (without answers) for user
func GetQuizForUser(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionID")
        userID := c.GetInt64("user_id")

        // Check if user has purchased this session
        var purchased int
        config.DB.Get(&amp;purchased, "SELECT COUNT(*) FROM purchases WHERE user_id = ? AND session_id = ?", userID, sessionID)
        if purchased == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Please purchase this session first"})
                return
        }</span>

        <span class="cov0" title="0">var quiz struct {
                ID    int64  `db:"id" json:"id"`
                Title string `db:"title" json:"title"`
        }
        err := config.DB.Get(&amp;quiz, "SELECT id, title FROM session_quizzes WHERE session_id = ? AND is_enabled = 1", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "No quiz available"})
                return
        }</span>

        <span class="cov0" title="0">var questions []struct {
                ID           int64   `db:"id" json:"id"`
                QuestionText string  `db:"question_text" json:"question_text"`
                OptionA      string  `db:"option_a" json:"option_a"`
                OptionB      string  `db:"option_b" json:"option_b"`
                OptionC      *string `db:"option_c" json:"option_c"`
                OptionD      *string `db:"option_d" json:"option_d"`
                OrderIndex   int     `db:"order_index" json:"order_index"`
        }
        config.DB.Select(&amp;questions, `
                SELECT id, question_text, option_a, option_b, option_c, option_d, order_index 
                FROM quiz_questions WHERE quiz_id = ? ORDER BY order_index
        `, quiz.ID)

        c.JSON(http.StatusOK, gin.H{"quiz": quiz, "questions": questions})</span>
}

// SubmitQuiz - Submit quiz answers
func SubmitQuiz(c *gin.Context) <span class="cov0" title="0">{
        sessionID := c.Param("sessionID")
        userID := c.GetInt64("user_id")

        fmt.Printf("[DEBUG SubmitQuiz] sessionID=%s, userID=%d\n", sessionID, userID)

        var input struct {
                Answers map[string]string `json:"answers"` // {"question_id": "A/B/C/D"}
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Invalid data: %v\n", err)
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[DEBUG] Answers received: %v\n", input.Answers)

        // Get quiz
        var quizID int64
        err := config.DB.Get(&amp;quizID, "SELECT id FROM session_quizzes WHERE session_id = ? AND is_enabled = 1", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Quiz not found: %v\n", err)
                c.JSON(http.StatusNotFound, gin.H{"error": "No quiz found"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[DEBUG] quizID=%d\n", quizID)

        // Get correct answers
        var questions []struct {
                ID            int64  `db:"id"`
                CorrectOption string `db:"correct_option"`
        }
        config.DB.Select(&amp;questions, "SELECT id, correct_option FROM quiz_questions WHERE quiz_id = ?", quizID)

        if len(questions) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] No questions found for quizID=%d\n", quizID)
                c.JSON(http.StatusBadRequest, gin.H{"error": "No questions in quiz"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("[DEBUG] Found %d questions\n", len(questions))

        // Calculate score
        correct := 0
        for _, q := range questions </span><span class="cov0" title="0">{
                if answer, ok := input.Answers[fmt.Sprintf("%d", q.ID)]; ok </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] Question %d: user=%s, correct=%s\n", q.ID, answer, q.CorrectOption)
                        if answer == q.CorrectOption </span><span class="cov0" title="0">{
                                correct++
                        }</span>
                }
        }

        <span class="cov0" title="0">scorePercent := float64(correct) / float64(len(questions)) * 100.0
        passed := scorePercent &gt;= 80 // Default pass threshold

        fmt.Printf("[DEBUG] Score: %.2f%%, Correct: %d/%d, Passed: %v\n", scorePercent, correct, len(questions), passed)

        // Convert answers to proper JSON
        answersJSON, _ := json.Marshal(input.Answers)

        // Save attempt
        result, saveErr := config.DB.Exec(`
                INSERT INTO quiz_attempts (user_id, quiz_id, score_percent, answers, passed)
                VALUES (?, ?, ?, ?, ?)
        `, userID, quizID, scorePercent, string(answersJSON), passed)

        if saveErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Failed to save attempt: %v\n", saveErr)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save quiz attempt"})
                return
        }</span>

        <span class="cov0" title="0">insertedID, _ := result.LastInsertId()
        fmt.Printf("[DEBUG] Quiz attempt saved with ID=%d\n", insertedID)

        c.JSON(http.StatusOK, gin.H{
                "score_percent":   scorePercent,
                "correct_answers": correct,
                "total_questions": len(questions),
                "passed":          passed,
                "message":         fmt.Sprintf("You scored %.0f%% (%d/%d correct)", scorePercent, correct, len(questions)),
        })</span>
}

// ========================================================
// USER - CERTIFICATE
// ========================================================

// GetUserCertificate - Get or generate certificate
func GetUserCertificate(c *gin.Context) <span class="cov0" title="0">{
        eventID := c.Param("eventID")
        userID := c.GetInt64("user_id")

        // Check if certificate already exists
        var cert struct {
                ID              int64   `db:"id" json:"id"`
                TotalScore      float64 `db:"total_score_percent" json:"total_score_percent"`
                CertificateCode string  `db:"certificate_code" json:"certificate_code"`
                IssuedAt        string  `db:"issued_at" json:"issued_at"`
        }
        err := config.DB.Get(&amp;cert, `
                SELECT id, total_score_percent, certificate_code, issued_at 
                FROM user_certificates WHERE user_id = ? AND event_id = ?
        `, userID, eventID)

        if err == nil </span><span class="cov0" title="0">{
                // Certificate exists, get additional info
                var eventInfo struct {
                        EventTitle string `db:"event_title"`
                        OrgName    string `db:"org_name"`
                }
                config.DB.Get(&amp;eventInfo, `
                        SELECT e.title as event_title, o.name as org_name
                        FROM events e JOIN organizations o ON e.organization_id = o.id
                        WHERE e.id = ?
                `, eventID)

                var userName string
                config.DB.Get(&amp;userName, "SELECT name FROM users WHERE id = ?", userID)

                c.JSON(http.StatusOK, gin.H{
                        "has_certificate": true,
                        "certificate":     cert,
                        "user_name":       userName,
                        "event_title":     eventInfo.EventTitle,
                        "org_name":        eventInfo.OrgName,
                })
                return
        }</span>

        // Check eligibility
        <span class="cov0" title="0">var quizzes []struct {
                QuizID int64 `db:"quiz_id"`
        }
        config.DB.Select(&amp;quizzes, `
                SELECT sq.id as quiz_id FROM session_quizzes sq
                JOIN sessions s ON sq.session_id = s.id
                WHERE s.event_id = ? AND sq.is_enabled = 1
        `, eventID)

        if len(quizzes) == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "No quizzes available for certificate"})
                return
        }</span>

        // Calculate total score
        <span class="cov0" title="0">weightPerQuiz := 100.0 / float64(len(quizzes))
        var totalScore float64

        for _, q := range quizzes </span><span class="cov0" title="0">{
                var score float64
                config.DB.Get(&amp;score, `
                        SELECT COALESCE(MAX(score_percent), 0) FROM quiz_attempts 
                        WHERE user_id = ? AND quiz_id = ?
                `, userID, q.QuizID)
                totalScore += score * weightPerQuiz / 100.0
        }</span>

        // Check min score
        <span class="cov0" title="0">var minScore int
        config.DB.Get(&amp;minScore, "SELECT COALESCE(min_score_percent, 80) FROM event_certificates WHERE event_id = ?", eventID)
        if minScore == 0 </span><span class="cov0" title="0">{
                minScore = 80
        }</span>

        <span class="cov0" title="0">if totalScore &lt; float64(minScore) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "has_certificate": false,
                        "total_score":     totalScore,
                        "min_required":    minScore,
                        "message":         fmt.Sprintf("You need %.0f%% to get certificate, current: %.2f%%", float64(minScore), totalScore),
                })
                return
        }</span>

        // Generate certificate
        <span class="cov0" title="0">certCode := generateCertCode()
        config.DB.Exec(`
                INSERT INTO user_certificates (user_id, event_id, total_score_percent, certificate_code)
                VALUES (?, ?, ?, ?)
        `, userID, eventID, totalScore, certCode)

        // Get info for response
        var eventInfo struct {
                EventTitle string `db:"event_title"`
                OrgName    string `db:"org_name"`
        }
        config.DB.Get(&amp;eventInfo, `
                SELECT e.title as event_title, o.name as org_name
                FROM events e JOIN organizations o ON e.organization_id = o.id
                WHERE e.id = ?
        `, eventID)

        var userName string
        config.DB.Get(&amp;userName, "SELECT name FROM users WHERE id = ?", userID)

        c.JSON(http.StatusOK, gin.H{
                "has_certificate": true,
                "certificate": gin.H{
                        "total_score_percent": totalScore,
                        "certificate_code":    certCode,
                        "issued_at":           "just now",
                },
                "user_name":   userName,
                "event_title": eventInfo.EventTitle,
                "org_name":    eventInfo.OrgName,
        })</span>
}

// Helper functions
func mustParseInt64(s string) int64 <span class="cov0" title="0">{
        v, _ := strconv.ParseInt(s, 10, 64)
        return v
}</span>

func generateCertCode() string <span class="cov0" title="0">{
        bytes := make([]byte, 8)
        rand.Read(bytes)
        return "CERT-" + hex.EncodeToString(bytes)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package controllers

import (
        "BACKEND/config"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// SubmitReport - User submits a report
func SubmitReport(c *gin.Context) <span class="cov8" title="1">{
        // Get user ID (optional - can be anonymous)
        var userID *int64
        if v, exists := c.Get("user_id"); exists </span><span class="cov8" title="1">{
                if uid, ok := v.(int64); ok &amp;&amp; uid &gt; 0 </span><span class="cov8" title="1">{
                        userID = &amp;uid
                }</span>
        }

        <span class="cov8" title="1">category := c.PostForm("category")
        subject := c.PostForm("subject")
        description := c.PostForm("description")

        if subject == "" || description == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Subject dan description wajib diisi"})
                return
        }</span>

        // Handle photo upload
        <span class="cov8" title="1">var photoURL string
        if file, err := c.FormFile("photo"); err == nil </span><span class="cov0" title="0">{
                os.MkdirAll("uploads/reports", os.ModePerm)
                filename := fmt.Sprintf("report_%d_%s%s", time.Now().UnixNano(), uuid.New().String()[:8], filepath.Ext(file.Filename))
                photoPath := filepath.Join("uploads/reports", filename)
                if err := c.SaveUploadedFile(file, photoPath); err == nil </span><span class="cov0" title="0">{
                        photoURL = photoPath
                }</span>
        }

        <span class="cov8" title="1">_, err := config.DB.Exec(`
                INSERT INTO reports (user_id, category, subject, description, photo_url)
                VALUES (?, ?, ?, ?, ?)
        `, userID, category, subject, description, photoURL)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[REPORT] Error: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menyimpan laporan"})
                return
        }</span>

        // Notify admins
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                var adminIDs []int64
                config.DB.Select(&amp;adminIDs, `
                        SELECT u.id FROM users u
                        JOIN user_roles ur ON u.id = ur.user_id
                        JOIN roles r ON ur.role_id = r.id
                        WHERE r.name = 'ADMIN'
                `)
                for _, adminID := range adminIDs </span><span class="cov0" title="0">{
                        CreateNotification(adminID, "new_report", "📢 Laporan Baru", "Ada laporan baru: "+subject)
                }</span>
        }()

        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{"message": "Laporan berhasil dikirim"})</span>
}

// GetReports - Admin gets all reports
func GetReports(c *gin.Context) <span class="cov8" title="1">{
        var reports []struct {
                ID          int64   `db:"id" json:"id"`
                UserID      *int64  `db:"user_id" json:"user_id"`
                UserName    *string `db:"user_name" json:"user_name"`
                UserEmail   *string `db:"user_email" json:"user_email"`
                Category    string  `db:"category" json:"category"`
                Subject     string  `db:"subject" json:"subject"`
                Description string  `db:"description" json:"description"`
                PhotoURL    *string `db:"photo_url" json:"photo_url"`
                Status      string  `db:"status" json:"status"`
                AdminNotes  *string `db:"admin_notes" json:"admin_notes"`
                CreatedAt   string  `db:"created_at" json:"created_at"`
        }

        err := config.DB.Select(&amp;reports, `
                SELECT r.id, r.user_id, u.name as user_name, u.email as user_email, r.category, r.subject, 
                       r.description, r.photo_url, r.status, r.admin_notes, r.created_at
                FROM reports r
                LEFT JOIN users u ON r.user_id = u.id
                ORDER BY r.created_at DESC
        `)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to fetch reports"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(200, gin.H{"reports": reports})</span>
}

// UpdateReportStatus - Admin updates report status
func UpdateReportStatus(c *gin.Context) <span class="cov8" title="1">{
        reportID := c.Param("id")

        var input struct {
                Status     string `json:"status"`
                AdminNotes string `json:"admin_notes"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov8" title="1">{
                c.JSON(400, gin.H{"error": "Invalid request"})
                return
        }</span>

        <span class="cov8" title="1">_, err := config.DB.Exec(`
                UPDATE reports SET status = ?, admin_notes = ? WHERE id = ?
        `, input.Status, input.AdminNotes, reportID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(500, gin.H{"error": "Failed to update report"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(200, gin.H{"message": "Report updated"})</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package controllers

import (
        "BACKEND/config"
        "net/http"
        "os"
        "strconv"

        "github.com/gin-gonic/gin"
)

// Helper Local: Cek apakah event milik organisasi (user ini)
func checkEventOwnedByUser(eventID, userID int64) bool <span class="cov0" title="0">{
        var count int
        err := config.DB.Get(&amp;count, `
                SELECT COUNT(*) FROM events e
                JOIN organizations o ON e.organization_id = o.id
                WHERE e.id = ? AND o.owner_user_id = ?
        `, eventID, userID)
        return err == nil &amp;&amp; count &gt; 0
}</span>

// Input struct untuk Create/Update Session
type SessionInput struct {
        Title       string `json:"title" binding:"required"`
        Description string `json:"description"`
        Price       int64  `json:"price"` 
}

// ---------------------------------------------
// UPDATE SESSION
// ---------------------------------------------
func UpdateSession(c *gin.Context) <span class="cov0" title="0">{
        sessionIDStr := c.Param("sessionID")
        sessionID, err := strconv.ParseInt(sessionIDStr, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Session ID"})
                return
        }</span>

        <span class="cov0" title="0">userID := c.GetInt64("user_id")

        // Validasi Kepemilikan
        var count int
        checkQuery := `
                SELECT COUNT(*) FROM sessions s
                JOIN events e ON s.event_id = e.id
                JOIN organizations o ON e.organization_id = o.id
                WHERE s.id = ? AND o.owner_user_id = ?
        `
        err = config.DB.Get(&amp;count, checkQuery, sessionID, userID)
        if err != nil || count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Sesi tidak ditemukan atau Anda tidak memiliki akses"})
                return
        }</span>

        <span class="cov0" title="0">var input SessionInput
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">updateQuery := `UPDATE sessions SET title = ?, description = ?, price = ? WHERE id = ?`
        _, err = config.DB.Exec(updateQuery, input.Title, input.Description, input.Price, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mengupdate sesi: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Sesi berhasil diperbarui"})</span>
}

// ---------------------------------------------
// DELETE SESSION (FIXED: Manual Cascade)
// ---------------------------------------------
func DeleteSession(c *gin.Context) <span class="cov0" title="0">{
        sessionIDStr := c.Param("sessionID")
        sessionID, _ := strconv.ParseInt(sessionIDStr, 10, 64)
        userID := c.GetInt64("user_id")

        // 1. Cek Kepemilikan
        var count int
        checkQuery := `
                SELECT COUNT(*) FROM sessions s
                JOIN events e ON s.event_id = e.id
                JOIN organizations o ON e.organization_id = o.id
                WHERE s.id = ? AND o.owner_user_id = ?
        `
        config.DB.Get(&amp;count, checkQuery, sessionID, userID)
        if count == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses ditolak"})
                return
        }</span>

        // 2. Hapus File Fisik (Video &amp; Modul)
        <span class="cov0" title="0">var filePaths []string
        config.DB.Select(&amp;filePaths, "SELECT video_url FROM session_videos WHERE session_id = ?", sessionID)
        var docPaths []string
        config.DB.Select(&amp;docPaths, "SELECT file_url FROM session_files WHERE session_id = ?", sessionID)
        filePaths = append(filePaths, docPaths...)

        for _, path := range filePaths </span><span class="cov0" title="0">{
                if path != "" </span><span class="cov0" title="0">{ os.Remove(path) }</span>
        }

        // 3. Hapus DATA ANAK Dulu (Video, File, Purchase) dari Database
        // Agar tidak kena error constraint foreign key
        <span class="cov0" title="0">_, err := config.DB.Exec("DELETE FROM session_videos WHERE session_id = ?", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus data video: " + err.Error()})
                return
        }</span>
        <span class="cov0" title="0">_, err = config.DB.Exec("DELETE FROM session_files WHERE session_id = ?", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus data file: " + err.Error()})
                return
        }</span>
        // Hapus history pembelian jika ada (karena foreign key ke session)
        <span class="cov0" title="0">config.DB.Exec("DELETE FROM purchases WHERE session_id = ?", sessionID)

        // 4. Baru Hapus Sesi
        _, err = config.DB.Exec("DELETE FROM sessions WHERE id = ?", sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus sesi (DB constraint): " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Sesi dan materinya berhasil dihapus"})</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package controllers

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
        "BACKEND/models"
)

// NOTE: Fungsi checkSessionOwnedByUser diasumsikan ada di helpers.go

// =======================================
// UPLOAD VIDEO KE SESI
// =======================================
func UploadSessionVideo(c *gin.Context) <span class="cov0" title="0">{
        sessionIDStr := c.Param("sessionID")
        userID := c.GetInt64("user_id")

        var sessionID int64
        if _, err := fmt.Sscan(sessionIDStr, &amp;sessionID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid session ID"})
                return
        }</span>

        <span class="cov0" title="0">if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "You don't own this session"})
                return
        }</span>

        <span class="cov0" title="0">file, header, err := c.Request.FormFile("video")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Video file is required"})
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        titleInput := c.PostForm("title")
        descriptionInput := c.PostForm("description")

        finalTitle := titleInput
        if finalTitle == "" </span><span class="cov0" title="0">{
                finalTitle = header.Filename
        }</span>

        <span class="cov0" title="0">ext := filepath.Ext(header.Filename)
        uniqueName := fmt.Sprintf("session_%d_%d%s", sessionID, time.Now().Unix(), ext)
        filePath := "uploads/videos/" + uniqueName

        os.MkdirAll("uploads/videos", os.ModePerm)

        out, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save video file"})
                return
        }</span>
        <span class="cov0" title="0">defer out.Close()
        io.Copy(out, file)

        var maxOrder int
        config.DB.Get(&amp;maxOrder, "SELECT COALESCE(MAX(order_index), 0) FROM session_videos WHERE session_id = ?", sessionID)

        _, err = config.DB.Exec(`
                INSERT INTO session_videos (session_id, title, description, video_url, size_bytes, order_index, created_at)
                VALUES (?, ?, ?, ?, ?, ?, NOW())
        `, sessionID, finalTitle, descriptionInput, filePath, header.Size, maxOrder+1)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[UPLOAD_VIDEO_ERROR] Failed to insert: %v\n", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save video metadata: " + err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Video uploaded successfully"})</span>
}

// =======================================
// UPLOAD FILE MATERI KE SESI
// =======================================
func UploadSessionFile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDParam := c.Param("sessionID")

        var sessionID int64
        if _, err := fmt.Sscan(sessionIDParam, &amp;sessionID); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid session ID"})
                return
        }</span>

        <span class="cov0" title="0">if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "You don't own this session"})
                return
        }</span>

        <span class="cov0" title="0">file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "File is required"})
                return
        }</span>

        <span class="cov0" title="0">ext := filepath.Ext(file.Filename)
        switch ext </span>{
        case ".pdf", ".ppt", ".pptx", ".doc", ".docx":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                c.JSON(http.StatusBadRequest, gin.H{"error": "Only pdf/ppt/pptx/doc/docx allowed"})
                return</span>
        }

        <span class="cov0" title="0">titleInput := c.PostForm("title")
        descriptionInput := c.PostForm("description")

        finalTitle := titleInput
        if finalTitle == "" </span><span class="cov0" title="0">{
                finalTitle = file.Filename
        }</span>

        <span class="cov0" title="0">filename := fmt.Sprintf("session_file_%d_%d%s", sessionID, time.Now().Unix(), ext)
        path := "uploads/files/" + filename

        os.MkdirAll("uploads/files", os.ModePerm)

        if err := c.SaveUploadedFile(file, path); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save file"})
                return
        }</span>

        <span class="cov0" title="0">var maxOrder int
        config.DB.Get(&amp;maxOrder, `SELECT COALESCE(MAX(order_index), 0) FROM session_files WHERE session_id = ?`, sessionID)

        _, err = config.DB.Exec(`
                INSERT INTO session_files (session_id, title, description, file_url, size_bytes, order_index, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, NOW())
        `, sessionID, finalTitle, descriptionInput, path, file.Size, maxOrder+1, time.Now())

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save file metadata"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "File uploaded successfully", "path": path})</span>
}

// =======================================
// UPDATE VIDEO
// =======================================
func UpdateSessionVideo(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDStr := c.Param("sessionID")
        mediaIDStr := c.Param("mediaID")

        var sessionID, mediaID int64
        fmt.Sscan(sessionIDStr, &amp;sessionID)
        fmt.Sscan(mediaIDStr, &amp;mediaID)

        if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "You don't own this session"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                Title       string `json:"title"`
                Description string `json:"description"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`UPDATE session_videos SET title=?, description=? WHERE id=? AND session_id=?`,
                input.Title, input.Description, mediaID, sessionID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update video info"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Video info updated"})</span>
}

// =======================================
// UPDATE FILE
// =======================================
func UpdateSessionFile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDStr := c.Param("sessionID")
        mediaIDStr := c.Param("mediaID")

        var sessionID, mediaID int64
        fmt.Sscan(sessionIDStr, &amp;sessionID)
        fmt.Sscan(mediaIDStr, &amp;mediaID)

        if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "You don't own this session"})
                return
        }</span>

        <span class="cov0" title="0">var input struct {
                Title       string `json:"title"`
                Description string `json:"description"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`UPDATE session_files SET title=?, description=? WHERE id=? AND session_id=?`,
                input.Title, input.Description, mediaID, sessionID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update file info"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "File info updated"})</span>
}

// =======================================
// DELETE VIDEO (BARU)
// =======================================
func DeleteSessionVideo(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDStr := c.Param("sessionID")
        mediaIDStr := c.Param("mediaID")

        var sessionID, mediaID int64
        fmt.Sscan(sessionIDStr, &amp;sessionID)
        fmt.Sscan(mediaIDStr, &amp;mediaID)

        if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses Ditolak"})
                return
        }</span>

        // 1. Ambil Path File
        <span class="cov0" title="0">var videoPath string
        err := config.DB.Get(&amp;videoPath, "SELECT video_url FROM session_videos WHERE id = ? AND session_id = ?", mediaID, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Video tidak ditemukan"})
                return
        }</span>

        // 2. Hapus File Fisik
        <span class="cov0" title="0">if videoPath != "" </span><span class="cov0" title="0">{
                os.Remove(videoPath)
        }</span>

        // 3. Hapus Record DB
        <span class="cov0" title="0">_, err = config.DB.Exec("DELETE FROM session_videos WHERE id = ?", mediaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus data video"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Video berhasil dihapus"})</span>
}

// =======================================
// DELETE FILE (BARU)
// =======================================
func DeleteSessionFile(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDStr := c.Param("sessionID")
        mediaIDStr := c.Param("mediaID")

        var sessionID, mediaID int64
        fmt.Sscan(sessionIDStr, &amp;sessionID)
        fmt.Sscan(mediaIDStr, &amp;mediaID)

        if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Akses Ditolak"})
                return
        }</span>

        // 1. Ambil Path File
        <span class="cov0" title="0">var filePath string
        err := config.DB.Get(&amp;filePath, "SELECT file_url FROM session_files WHERE id = ? AND session_id = ?", mediaID, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "File tidak ditemukan"})
                return
        }</span>

        // 2. Hapus File Fisik
        <span class="cov0" title="0">if filePath != "" </span><span class="cov0" title="0">{
                os.Remove(filePath)
        }</span>

        // 3. Hapus Record DB
        <span class="cov0" title="0">_, err = config.DB.Exec("DELETE FROM session_files WHERE id = ?", mediaID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal menghapus data file"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "File berhasil dihapus"})</span>
}

// ... (GET MEDIA FUNCTIONS tetap sama, tidak perlu diubah) ...
// (Pastikan GetSessionMedia dan GetUserSessionMedia tetap ada di bawah sini seperti kode sebelumnya)
func GetSessionMedia(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDStr := c.Param("sessionID")
        var sessionID int64
        fmt.Sscan(sessionIDStr, &amp;sessionID)
        if !checkSessionOwnedByUser(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "Access Denied"})
                return
        }</span>
        <span class="cov0" title="0">var videos []models.SessionVideo
        config.DB.Select(&amp;videos, `SELECT id, session_id, title, COALESCE(description, '') as description, video_url FROM session_videos WHERE session_id = ? ORDER BY order_index ASC`, sessionID)
        if videos == nil </span><span class="cov0" title="0">{
                videos = []models.SessionVideo{}
        }</span>
        <span class="cov0" title="0">var files []models.SessionFile
        config.DB.Select(&amp;files, `SELECT id, session_id, title, COALESCE(description, '') as description, file_url FROM session_files WHERE session_id = ? ORDER BY order_index ASC`, sessionID)
        if files == nil </span><span class="cov0" title="0">{
                files = []models.SessionFile{}
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"videos": videos, "files": files})</span>
}

func GetUserSessionMedia(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionIDStr := c.Param("sessionID")
        var sessionID int64
        fmt.Sscan(sessionIDStr, &amp;sessionID)
        var count int
        config.DB.Get(&amp;count, `SELECT COUNT(*) FROM purchases WHERE user_id = ? AND session_id = ?`, userID, sessionID)
        if count == 0 </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "Not Purchased"})
                return
        }</span>
        <span class="cov0" title="0">var status string
        config.DB.Get(&amp;status, `SELECT publish_status FROM sessions WHERE id = ?`, sessionID)
        if status != "PUBLISHED" </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "Not Published"})
                return
        }</span>
        <span class="cov0" title="0">var videos []models.SessionVideo
        config.DB.Select(&amp;videos, `SELECT id, session_id, title, COALESCE(description, '') as description, video_url FROM session_videos WHERE session_id = ? ORDER BY order_index ASC`, sessionID)
        if videos == nil </span><span class="cov0" title="0">{
                videos = []models.SessionVideo{}
        }</span>
        <span class="cov0" title="0">var files []models.SessionFile
        config.DB.Select(&amp;files, `SELECT id, session_id, title, COALESCE(description, '') as description, file_url FROM session_files WHERE session_id = ? ORDER BY order_index ASC`, sessionID)
        if files == nil </span><span class="cov0" title="0">{
                files = []models.SessionFile{}
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"session_id": sessionID, "videos": videos, "files": files})</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "BACKEND/config"
)

func checkSessionOwnedByUserID(sessionID int64, userID int64) bool <span class="cov0" title="0">{
        var count int
        config.DB.Get(&amp;count, `SELECT COUNT(*) FROM sessions s JOIN events e ON s.event_id = e.id JOIN organizations o ON e.organization_id = o.id WHERE s.id = ? AND o.owner_user_id = ?`, sessionID, userID)
        return count &gt; 0
}</span>

func PublishSession(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionID, _ := strconv.ParseInt(c.Param("sessionID"), 10, 64)

        if !checkSessionOwnedByUserID(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`UPDATE sessions SET publish_status = 'PUBLISHED', publish_at = NULL WHERE id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to publish session"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session published!", "status": "PUBLISHED"})</span>
}

func UnpublishSession(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionID, _ := strconv.ParseInt(c.Param("sessionID"), 10, 64)

        if !checkSessionOwnedByUserID(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">_, err := config.DB.Exec(`UPDATE sessions SET publish_status = 'DRAFT', publish_at = NULL WHERE id = ?`, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to unpublish session"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session drafted!", "status": "DRAFT"})</span>
}

func ScheduleSessionPublish(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        sessionID, _ := strconv.ParseInt(c.Param("sessionID"), 10, 64)

        if !checkSessionOwnedByUserID(sessionID, userID) </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                PublishAt string `json:"publish_at" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid data"})
                return
        }</span>

        // Parsing Tanggal Fleksibel
        <span class="cov0" title="0">parsedTime, err := time.Parse("2006-01-02T15:04", req.PublishAt)
        if err != nil </span><span class="cov0" title="0">{
                parsedTime, err = time.Parse(time.RFC3339, req.PublishAt)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Println("Date Parse Error:", err)
                        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid date format"})
                        return
                }</span>
        }
        <span class="cov0" title="0">sqlTimeStr := parsedTime.Format("2006-01-02 15:04:05")

        _, err = config.DB.Exec(`UPDATE sessions SET publish_status = 'SCHEDULED', publish_at = ? WHERE id = ?`, sqlTimeStr, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("DB Error:", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to schedule session"})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Session scheduled!", "status": "SCHEDULED", "publish_at": req.PublishAt})</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "strconv"
        "time"

        "BACKEND/config"
        "BACKEND/helpers"

        "github.com/gin-gonic/gin"
)

// =============================================================
// STREAM VIDEO (Debug Version)
// =============================================================
func StreamSessionVideo(c *gin.Context) <span class="cov0" title="0">{
        filename := c.Param("filename")
        token := c.Query("token")
        expStr := c.Query("exp")
        uidStr := c.Query("uid")

        fmt.Println("\n--- DEBUG STREAM VIDEO ---")
        fmt.Println("Request Filename:", filename)
        fmt.Println("User ID:", uidStr)

        // 1. Cek Expired
        exp, _ := strconv.ParseInt(expStr, 10, 64)
        if time.Now().Unix() &gt; exp </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: URL Expired")
                c.JSON(403, gin.H{"error": "URL expired"})
                return
        }</span>

        // 2. Validasi Token
        <span class="cov0" title="0">userID, _ := strconv.ParseInt(uidStr, 10, 64)
        if !helpers.ValidateSignedToken(userID, filename, exp, token) </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: Invalid Token Signature")
                c.JSON(403, gin.H{"error": "Invalid token signature"})
                return
        }</span>

        // 3. Cek Database (Pakai LIKE agar lebih aman)
        <span class="cov0" title="0">var sessionID int64
        // Mencari video yang URL-nya MENGANDUNG nama file ini
        err := config.DB.Get(&amp;sessionID, 
                "SELECT session_id FROM session_videos WHERE video_url LIKE ?", 
                "%"+filename,
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: Metadata video tidak ditemukan di DB untuk file:", filename)
                c.JSON(404, gin.H{"error": "Video metadata not found in database"})
                return
        }</span>

        // 4. Cek Pembelian
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count,
                "SELECT COUNT(*) FROM purchases WHERE user_id=? AND session_id=?",
                userID, sessionID,
        )
        if count == 0 </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: User belum beli sesi ini. SessionID:", sessionID)
                c.JSON(403, gin.H{"error": "Unauthorized access (not purchased)"})
                return
        }</span>

        // 5. Cek Fisik File
        <span class="cov0" title="0">fullPath := filepath.Join("uploads/videos", filename)
        fmt.Println("Mencari file fisik di:", fullPath)
        
        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: File fisik tidak ditemukan di server!")
                // Coba cari di folder files barangkali salah upload
                c.JSON(404, gin.H{"error": "Video file not found on server"})
                return
        }</span>

        // 6. Serve File
        <span class="cov0" title="0">fmt.Println("✅ Sukses! Memulai streaming...")
        http.ServeFile(c.Writer, c.Request, fullPath)</span>
}

// =============================================================
// STREAM FILE (Debug Version)
// =============================================================
func StreamSessionFile(c *gin.Context) <span class="cov0" title="0">{
        filename := c.Param("filename")
        token := c.Query("token")
        expStr := c.Query("exp")
        uidStr := c.Query("uid")

        fmt.Println("\n--- DEBUG STREAM FILE ---")
        fmt.Println("Request Filename:", filename)

        exp, _ := strconv.ParseInt(expStr, 10, 64)
        if time.Now().Unix() &gt; exp </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "URL expired"})
                return
        }</span>

        <span class="cov0" title="0">userID, _ := strconv.ParseInt(uidStr, 10, 64)
        if !helpers.ValidateSignedToken(userID, filename, exp, token) </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "Invalid token"})
                return
        }</span>

        <span class="cov0" title="0">var sessionID int64
        err := config.DB.Get(&amp;sessionID, 
                "SELECT session_id FROM session_files WHERE file_url LIKE ?", 
                "%"+filename,
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: Metadata file tidak ditemukan di DB")
                c.JSON(404, gin.H{"error": "File metadata not found"})
                return
        }</span>

        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count,
                "SELECT COUNT(*) FROM purchases WHERE user_id=? AND session_id=?",
                userID, sessionID,
        )
        if count == 0 </span><span class="cov0" title="0">{
                c.JSON(403, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">fullPath := filepath.Join("uploads/files", filename)
        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Println("❌ Error: File fisik tidak ditemukan:", fullPath)
                c.JSON(404, gin.H{"error": "File not found"})
                return
        }</span>

        <span class="cov0" title="0">fmt.Println("✅ Sukses! Membuka file...")
        http.ServeFile(c.Writer, c.Request, fullPath)</span>
}</pre>
		
		<pre class="file" id="file26" style="display: none">package controllers

import (
        "fmt"
        "github.com/gin-gonic/gin"
        "BACKEND/helpers" // Pastikan import ini ada
)

func GetSignedVideoURL(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id") // Ambil User ID
        filename := c.Param("filename")

        // GUNAKAN HELPER INI, JANGAN UUID
        token, exp := helpers.GenerateSignedToken(userID, filename)

        // Masukkan uid ke dalam URL agar controller stream tau siapa yang nonton
        signedURL := fmt.Sprintf("/api/user/sessions/video/%s?token=%s&amp;exp=%d&amp;uid=%d", 
                filename, token, exp, userID)

        c.JSON(200, gin.H{"url": signedURL})
}</span>

func GetSignedFileURL(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        filename := c.Param("filename")

        token, exp := helpers.GenerateSignedToken(userID, filename)

        signedURL := fmt.Sprintf("/api/user/sessions/file/%s?token=%s&amp;exp=%d&amp;uid=%d", 
                filename, token, exp, userID)

        c.JSON(200, gin.H{"url": signedURL})
}</pre>
		
		<pre class="file" id="file27" style="display: none">package controllers

import (
        "fmt"
        "net/http"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"

        "BACKEND/config"
        "BACKEND/models"
)

// ================================
// GET PROFILE USER SENDIRI
// ================================
func GetMe(c *gin.Context) <span class="cov8" title="1">{
        // Read user_id from context robustly (support int/int64/float64)
        var userID int64
        if v, ok := c.Get("user_id"); ok </span><span class="cov8" title="1">{
                switch t := v.(type) </span>{
                case int64:<span class="cov8" title="1">
                        userID = t</span>
                case int:<span class="cov0" title="0">
                        userID = int64(t)</span>
                case float64:<span class="cov0" title="0">
                        userID = int64(t)</span>
                default:<span class="cov0" title="0">
                        userID = 0</span>
                }
        }

        <span class="cov8" title="1">var user models.User
        var err error
        var success bool = false

        // Try 1: Query with all columns including extended profile
        err = config.DB.Get(&amp;user,
                `SELECT id, name, email, COALESCE(phone, '') as phone, 
                        COALESCE(profile_img, '') as profile_img, 
                        COALESCE(bio, '') as bio, 
                        COALESCE(username, '') as username,
                        COALESCE(gender, '') as gender,
                        COALESCE(birthdate, '') as birthdate,
                        COALESCE(address, '') as address
                 FROM users WHERE id = ?`,
                userID,
        )
        if err == nil </span><span class="cov8" title="1">{
                success = true
        }</span>

        // Try 2: WITHOUT bio, WITH username (in case bio column doesn't exist)
        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                err = config.DB.Get(&amp;user,
                        `SELECT id, name, email, COALESCE(phone, '') as phone, 
                                COALESCE(profile_img, '') as profile_img, 
                                COALESCE(username, '') as username
                         FROM users WHERE id = ?`,
                        userID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        user.Bio = ""
                }</span>
        }

        // Try 3: WITH bio, WITHOUT username (in case username column doesn't exist)
        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                err = config.DB.Get(&amp;user,
                        `SELECT id, name, email, COALESCE(phone, '') as phone, 
                                COALESCE(profile_img, '') as profile_img, 
                                COALESCE(bio, '') as bio
                         FROM users WHERE id = ?`,
                        userID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        user.Username = ""
                }</span>
        }

        // Try 4: WITHOUT bio AND username
        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                err = config.DB.Get(&amp;user,
                        `SELECT id, name, email, COALESCE(phone, '') as phone, 
                                COALESCE(profile_img, '') as profile_img
                         FROM users WHERE id = ?`,
                        userID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        user.Bio = ""
                        user.Username = ""
                }</span>
        }

        // Try 5: Minimal query - just basic info
        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                err = config.DB.Get(&amp;user,
                        `SELECT id, name, email FROM users WHERE id = ?`,
                        userID,
                )
                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        user.Phone = ""
                        user.ProfileImg = ""
                        user.Bio = ""
                        user.Username = ""
                }</span>
        }

        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"user": user})</span>
}

// ================================
// UPDATE PROFILE USER SENDIRI
// ================================
type UpdateMeRequest struct {
        Name       string `json:"name"`
        Phone      string `json:"phone"`
        ProfileImg string `json:"profile_img"`
        Bio        string `json:"bio"`
        Username   string `json:"username"`
        // Extended profile fields
        Gender    string `json:"gender"`
        Birthdate string `json:"birthdate"`
        Address   string `json:"address"`
}

func UpdateMe(c *gin.Context) <span class="cov8" title="1">{
        // Read user_id from context robustly (support int/int64/float64)
        var userID int64
        if v, ok := c.Get("user_id"); ok </span><span class="cov8" title="1">{
                switch t := v.(type) </span>{
                case int64:<span class="cov8" title="1">
                        userID = t</span>
                case int:<span class="cov0" title="0">
                        userID = int64(t)</span>
                case float64:<span class="cov0" title="0">
                        userID = int64(t)</span>
                default:<span class="cov0" title="0">
                        userID = 0</span>
                }
        }

        <span class="cov8" title="1">if userID == 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "User not authenticated"})
                return
        }</span>

        <span class="cov8" title="1">var req UpdateMeRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body: " + err.Error()})
                return
        }</span>

        // Log the update request
        <span class="cov8" title="1">println("UpdateMe called for user:", userID)
        println("Request data - Name:", req.Name, "Phone:", req.Phone, "Username:", req.Username)

        var err error
        var success bool = false

        // Try 1: Update with all fields including extended profile
        _, err = config.DB.Exec(`
                UPDATE users 
                SET name = ?, phone = ?, profile_img = ?, bio = ?, username = ?,
                    gender = ?, birthdate = ?, address = ?
                WHERE id = ?
        `, req.Name, req.Phone, req.ProfileImg, req.Bio, req.Username,
                req.Gender, req.Birthdate, req.Address,
                userID)

        if err == nil </span><span class="cov0" title="0">{
                success = true
                println("Update succeeded with all fields including extended profile")
        }</span> else<span class="cov8" title="1"> {
                println("Try 1 failed (extended profile):", err.Error())
        }</span>

        // Try 2: WITHOUT bio, WITH username (in case bio column doesn't exist)
        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                _, err = config.DB.Exec(`
                        UPDATE users 
                        SET name = ?, phone = ?, profile_img = ?, username = ?
                        WHERE id = ?
                `, req.Name, req.Phone, req.ProfileImg, req.Username, userID)

                if err == nil </span><span class="cov8" title="1">{
                        success = true
                        println("Update succeeded without bio, with username")
                }</span> else<span class="cov0" title="0"> {
                        println("Try 2 failed (no bio, with username):", err.Error())
                }</span>
        }

        // Try 3: WITH bio, WITHOUT username (in case username column doesn't exist)
        <span class="cov8" title="1">if !success </span><span class="cov0" title="0">{
                _, err = config.DB.Exec(`
                        UPDATE users 
                        SET name = ?, phone = ?, profile_img = ?, bio = ?
                        WHERE id = ?
                `, req.Name, req.Phone, req.ProfileImg, req.Bio, userID)

                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        println("Update succeeded with bio, without username")
                }</span> else<span class="cov0" title="0"> {
                        println("Try 3 failed (with bio, no username):", err.Error())
                }</span>
        }

        // Try 4: WITHOUT bio AND username
        <span class="cov8" title="1">if !success </span><span class="cov0" title="0">{
                _, err = config.DB.Exec(`
                        UPDATE users 
                        SET name = ?, phone = ?, profile_img = ?
                        WHERE id = ?
                `, req.Name, req.Phone, req.ProfileImg, userID)

                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        println("Update succeeded without bio and username")
                }</span> else<span class="cov0" title="0"> {
                        println("Try 4 failed (no bio, no username):", err.Error())
                }</span>
        }

        // Try 5: Minimal update - just name and phone
        <span class="cov8" title="1">if !success </span><span class="cov0" title="0">{
                _, err = config.DB.Exec(`
                        UPDATE users 
                        SET name = ?, phone = ?
                        WHERE id = ?
                `, req.Name, req.Phone, userID)

                if err == nil </span><span class="cov0" title="0">{
                        success = true
                        println("Update succeeded with minimal fields")
                }</span> else<span class="cov0" title="0"> {
                        println("Try 5 failed (minimal):", err.Error())
                }</span>
        }

        <span class="cov8" title="1">if !success </span><span class="cov0" title="0">{
                println("All update attempts failed")
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update profile: " + err.Error()})
                return
        }</span>

        <span class="cov8" title="1">println("Profile updated successfully for user:", userID)
        c.JSON(http.StatusOK, gin.H{"message": "Profile updated successfully"})</span>
}

// ================================
// ADMIN: GET ALL USERS (WITH ROLES)
// ================================
func GetAllUsers(c *gin.Context) <span class="cov8" title="1">{
        // Kita buat struct custom untuk response agar ada field Roles
        type UserBasicInfo struct {
                ID         int64  `db:"id" json:"id"`
                Name       string `db:"name" json:"name"`
                Email      string `db:"email" json:"email"`
                Phone      string `db:"phone" json:"phone"`
                ProfileImg string `db:"profile_img" json:"profile_img"`
                Bio        string `db:"bio" json:"bio"`
                AdminLevel int    `db:"admin_level" json:"admin_level"`
        }

        type UserWithRole struct {
                UserBasicInfo
                Roles []string `json:"roles"`
        }

        // 1. Ambil semua user dengan COALESCE untuk handle NULL
        var users []UserBasicInfo
        err := config.DB.Select(&amp;users, `
        SELECT id, name, email, 
               COALESCE(phone, '') as phone, 
               COALESCE(profile_img, '') as profile_img, 
               COALESCE(bio, '') as bio,
               COALESCE(admin_level, 0) as admin_level
        FROM users ORDER BY id DESC
    `)

        if err != nil </span><span class="cov0" title="0">{
                println("Error fetching users:", err.Error())
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch users: " + err.Error()})
                return
        }</span>

        // 2. Ambil semua roles mapping (agar efisien, sekali query)
        <span class="cov8" title="1">type UserRoleMap struct {
                UserID   int64  `db:"user_id"`
                RoleName string `db:"role_name"`
        }
        var roleMaps []UserRoleMap
        config.DB.Select(&amp;roleMaps, `
        SELECT ur.user_id, r.name as role_name
        FROM user_roles ur
        JOIN roles r ON ur.role_id = r.id
    `)

        // 3. Gabungkan data User + Role
        var result []UserWithRole

        for _, u := range users </span><span class="cov8" title="1">{
                // Cari role untuk user ini
                var myRoles []string
                for _, rm := range roleMaps </span><span class="cov8" title="1">{
                        if rm.UserID == u.ID </span><span class="cov8" title="1">{
                                myRoles = append(myRoles, rm.RoleName)
                        }</span>
                }

                // Append ke hasil akhir
                <span class="cov8" title="1">result = append(result, UserWithRole{
                        UserBasicInfo: u,
                        Roles:         myRoles,
                })</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"users": result})</span>
}

// ================================
// ADMIN: GET USER BY ID (DETAIL)
// ================================
func GetUserByID(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        // 1. Get user basic info
        type UserBasic struct {
                ID         int64  `db:"id" json:"id"`
                Name       string `db:"name" json:"name"`
                Email      string `db:"email" json:"email"`
                Phone      string `db:"phone" json:"phone"`
                ProfileImg string `db:"profile_img" json:"profile_img"`
                Bio        string `db:"bio" json:"bio"`
                CreatedAt  string `db:"created_at" json:"created_at"`
                AdminLevel int    `db:"admin_level" json:"admin_level"`
                Gender     string `db:"gender" json:"gender"`
                Birthdate  string `db:"birthdate" json:"birthdate"`
                Address    string `db:"address" json:"address"`
        }

        var user UserBasic
        err := config.DB.Get(&amp;user,
                `SELECT id, name, email, COALESCE(phone, '') as phone, 
                        COALESCE(profile_img, '') as profile_img, 
                        COALESCE(bio, '') as bio,
                        COALESCE(created_at, '') as created_at,
                        COALESCE(admin_level, 0) as admin_level,
                        COALESCE(gender, '') as gender,
                        COALESCE(birthdate, '') as birthdate,
                        COALESCE(address, '') as address
                 FROM users WHERE id = ?`,
                id,
        )

        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // 2. Get user roles
        <span class="cov8" title="1">type RoleInfo struct {
                Name string `db:"name"`
        }
        var roles []RoleInfo
        config.DB.Select(&amp;roles, `
                SELECT r.name FROM roles r
                JOIN user_roles ur ON r.id = ur.role_id
                WHERE ur.user_id = ?
        `, id)

        var roleNames []string
        for _, r := range roles </span><span class="cov8" title="1">{
                roleNames = append(roleNames, r.Name)
        }</span>

        // 3. Get events joined (purchases)
        <span class="cov8" title="1">type EventJoined struct {
                EventID       int64   `db:"event_id" json:"event_id"`
                EventTitle    string  `db:"event_title" json:"event_title"`
                SessionsCount int     `db:"sessions_count" json:"sessions_count"`
                TotalPaid     float64 `db:"total_paid" json:"total_paid"`
        }
        var eventsJoined []EventJoined
        config.DB.Select(&amp;eventsJoined, `
                SELECT 
                        e.id as event_id,
                        e.title as event_title,
                        COUNT(p.id) as sessions_count,
                        SUM(p.price_paid) as total_paid
                FROM purchases p
                JOIN sessions s ON p.session_id = s.id
                JOIN events e ON s.event_id = e.id
                WHERE p.user_id = ?
                GROUP BY e.id, e.title
                ORDER BY total_paid DESC
        `, id)

        if eventsJoined == nil </span><span class="cov8" title="1">{
                eventsJoined = []EventJoined{}
        }</span>

        // 4. If organizer, get organization info
        <span class="cov8" title="1">var orgInfo interface{} = nil
        isOrganizer := false
        for _, r := range roleNames </span><span class="cov8" title="1">{
                if r == "ORGANIZATION" || r == "ORGANIZER" </span><span class="cov0" title="0">{
                        isOrganizer = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if isOrganizer </span><span class="cov0" title="0">{
                type OrgDetail struct {
                        ID          int64  `db:"id" json:"id"`
                        Name        string `db:"name" json:"name"`
                        Category    string `db:"category" json:"category"`
                        Description string `db:"description" json:"description"`
                        Email       string `db:"email" json:"email"`
                        Phone       string `db:"phone" json:"phone"`
                        Website     string `db:"website" json:"website"`
                        EventsCount int    `db:"events_count" json:"events_count"`
                }

                var org OrgDetail
                err := config.DB.Get(&amp;org, `
                        SELECT 
                                o.id, 
                                COALESCE(o.name, '') as name,
                                COALESCE(o.category, '') as category,
                                COALESCE(o.description, '') as description,
                                COALESCE(o.email, '') as email,
                                COALESCE(o.phone, '') as phone,
                                COALESCE(o.website, '') as website,
                                (SELECT COUNT(*) FROM events WHERE organization_id = o.id) as events_count
                        FROM organizations o 
                        WHERE o.owner_user_id = ?
                `, id)

                if err == nil </span><span class="cov0" title="0">{
                        // Get org events
                        type OrgEvent struct {
                                ID            int64  `db:"id" json:"id"`
                                Title         string `db:"title" json:"title"`
                                PublishStatus string `db:"publish_status" json:"publish_status"`
                                SessionsCount int    `db:"sessions_count" json:"sessions_count"`
                                BuyersCount   int    `db:"buyers_count" json:"buyers_count"`
                        }
                        var orgEvents []OrgEvent
                        config.DB.Select(&amp;orgEvents, `
                                SELECT 
                                        e.id, 
                                        e.title,
                                        COALESCE(e.publish_status, 'DRAFT') as publish_status,
                                        (SELECT COUNT(*) FROM sessions WHERE event_id = e.id) as sessions_count,
                                        (SELECT COUNT(DISTINCT p.user_id) FROM purchases p JOIN sessions s ON p.session_id = s.id WHERE s.event_id = e.id) as buyers_count
                                FROM events e
                                WHERE e.organization_id = ?
                                ORDER BY e.created_at DESC
                        `, org.ID)

                        if orgEvents == nil </span><span class="cov0" title="0">{
                                orgEvents = []OrgEvent{}
                        }</span>

                        <span class="cov0" title="0">orgInfo = gin.H{
                                "id":           org.ID,
                                "name":         org.Name,
                                "category":     org.Category,
                                "description":  org.Description,
                                "email":        org.Email,
                                "phone":        org.Phone,
                                "website":      org.Website,
                                "events_count": org.EventsCount,
                                "events":       orgEvents,
                        }</span>
                }
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "user": gin.H{
                        "id":          user.ID,
                        "name":        user.Name,
                        "email":       user.Email,
                        "phone":       user.Phone,
                        "profile_img": user.ProfileImg,
                        "bio":         user.Bio,
                        "created_at":  user.CreatedAt,
                        "admin_level": user.AdminLevel,
                        "gender":      user.Gender,
                        "birthdate":   user.Birthdate,
                        "address":     user.Address,
                        "roles":       roleNames,
                },
                "events_joined": eventsJoined,
                "organization":  orgInfo,
        })</span>
}

// ================================
// ADMIN: UPDATE USER
// ================================
type AdminUpdateUserRequest struct {
        Name   string `json:"name"`
        Email  string `json:"email"`
        Phone  string `json:"phone"`
        Bio    string `json:"bio"`
        Reason string `json:"reason"` // Alasan perubahan
}

func UpdateUserByAdmin(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        var req AdminUpdateUserRequest
        if c.ShouldBindJSON(&amp;req) != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
                return
        }</span>

        <span class="cov8" title="1">_, err := config.DB.Exec(`
                UPDATE users 
                SET name=?, email=?, phone=?, bio=?
                WHERE id=?
        `, req.Name, req.Email, req.Phone, req.Bio, id)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update user"})
                return
        }</span>

        // Notify user about profile change
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                var userID int64
                config.DB.Get(&amp;userID, "SELECT id FROM users WHERE id = ?", id)
                if userID &gt; 0 </span><span class="cov8" title="1">{
                        message := "Admin telah memperbarui informasi profil Anda."
                        if req.Reason != "" </span><span class="cov8" title="1">{
                                message += " Alasan: " + req.Reason
                        }</span>
                        <span class="cov8" title="1">CreateNotification(
                                userID,
                                "profile_updated",
                                "👤 Profil Diperbarui",
                                message,
                        )</span>
                }
        }()

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "User updated successfully"})</span>
}

// ================================
// ADMIN: DELETE USER
// ================================
func DeleteUser(c *gin.Context) <span class="cov8" title="1">{
        id := c.Param("id")

        // Check if user exists
        var exists int
        err := config.DB.Get(&amp;exists, "SELECT COUNT(*) FROM users WHERE id=?", id)
        if err != nil || exists == 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // Delete related data in order to avoid foreign key constraints
        // 1. Delete notifications
        <span class="cov8" title="1">config.DB.Exec("DELETE FROM notifications WHERE user_id=?", id)

        // 2. Delete user roles
        config.DB.Exec("DELETE FROM user_roles WHERE user_id=?", id)

        // 3. Delete enrollments
        config.DB.Exec("DELETE FROM enrollments WHERE user_id=?", id)

        // 4. Delete purchases (must be before orders)
        config.DB.Exec("DELETE FROM purchases WHERE user_id=?", id)

        // 5. Delete orders
        config.DB.Exec("DELETE FROM orders WHERE user_id=?", id)

        // 6. Delete reviews
        config.DB.Exec("DELETE FROM reviews WHERE user_id=?", id)

        // 7. Delete affiliate submissions and related ledgers
        config.DB.Exec("DELETE FROM affiliate_ledgers WHERE affiliate_submission_id IN (SELECT id FROM affiliate_submissions WHERE user_id=?)", id)
        config.DB.Exec("DELETE FROM affiliate_submission_videos WHERE submission_id IN (SELECT id FROM affiliate_submissions WHERE user_id=?)", id)
        config.DB.Exec("DELETE FROM affiliate_submission_files WHERE submission_id IN (SELECT id FROM affiliate_submissions WHERE user_id=?)", id)
        config.DB.Exec("DELETE FROM affiliate_submissions WHERE user_id=?", id)

        // 8. Delete organization applications
        config.DB.Exec("DELETE FROM organization_applications WHERE user_id=?", id)

        // Finally delete the user
        _, err = config.DB.Exec("DELETE FROM users WHERE id=?", id)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error deleting user %s: %v\n", id, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete user: " + err.Error()})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})</span>
}

// ================================
// ADMIN: CREATE NEW USER
// ================================
type AdminCreateUserRequest struct {
        Name       string `json:"name"`
        Email      string `json:"email"`
        Password   string `json:"password"`
        Role       string `json:"role"`        // USER, ORGANIZATION, ADMIN
        AdminLevel int    `json:"admin_level"` // 1=Super Admin, 2=Regular Admin (only for ADMIN)
        OrgName    string `json:"org_name"`    // Optional, for ORGANIZATION role
}

func CreateUserByAdmin(c *gin.Context) <span class="cov0" title="0">{
        var req AdminCreateUserRequest

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
                return
        }</span>

        // Cek duplikasi email
        <span class="cov0" title="0">var count int
        config.DB.Get(&amp;count, "SELECT COUNT(*) FROM users WHERE email=?", req.Email)
        if count &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusConflict, gin.H{"error": "Email already in use"})
                return
        }</span>

        // Hash password
        <span class="cov0" title="0">hash, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
                return
        }</span>

        // Determine admin_level
        <span class="cov0" title="0">adminLevel := 0
        if req.Role == "ADMIN" </span><span class="cov0" title="0">{
                adminLevel = req.AdminLevel
                if adminLevel == 0 </span><span class="cov0" title="0">{
                        adminLevel = 2 // default to regular admin
                }</span>
        }

        // Insert user with admin_level
        <span class="cov0" title="0">res, err := config.DB.Exec(`
                INSERT INTO users (name, email, password_hash, admin_level)
                VALUES (?, ?, ?, ?)
        `, req.Name, req.Email, string(hash), adminLevel)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
                return
        }</span>

        <span class="cov0" title="0">userID, _ := res.LastInsertId()

        // Role mapping
        var roleID int
        switch req.Role </span>{
        case "ADMIN":<span class="cov0" title="0">
                roleID = 3</span>
        case "ORGANIZATION":<span class="cov0" title="0">
                roleID = 2</span>
        default:<span class="cov0" title="0">
                roleID = 1</span>
        }

        // Assign role
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                INSERT INTO user_roles (user_id, role_id)
                VALUES (?, ?)
        `, userID, roleID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to assign role"})
                return
        }</span>

        // If organization, create org profile automatically
        <span class="cov0" title="0">if req.Role == "ORGANIZATION" </span><span class="cov0" title="0">{
                orgName := req.OrgName
                if orgName == "" </span><span class="cov0" title="0">{
                        orgName = req.Name + "'s Organization"
                }</span>
                <span class="cov0" title="0">_, err = config.DB.Exec(`
                        INSERT INTO organizations (owner_user_id, name, status)
                        VALUES (?, ?, 'APPROVED')
                `, userID, orgName)
                if err != nil </span><span class="cov0" title="0">{
                        // Log but don't fail
                        println("Warning: Failed to create org profile:", err.Error())
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "User created successfully",
                "user_id": userID,
                "role":    req.Role,
        })</span>
}

// ================================
// ADMIN: SET USER ROLE (REPLACE, NOT ADD)
// ================================
type SetRoleRequest struct {
        Role       string `json:"role"`        // USER, ORGANIZATION, ADMIN
        AdminLevel int    `json:"admin_level"` // 0=none, 1=super, 2=regular (only for ADMIN)
}

func SetUserRole(c *gin.Context) <span class="cov0" title="0">{
        // Check current admin level
        currentUserID := c.GetInt64("user_id")
        var currentAdminLevel int
        config.DB.Get(&amp;currentAdminLevel, `SELECT COALESCE(admin_level, 0) FROM users WHERE id = ?`, currentUserID)

        targetID := c.Param("id")

        // Cannot change own role
        if fmt.Sprintf("%d", currentUserID) == targetID </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Tidak dapat mengubah role sendiri"})
                return
        }</span>

        // Check target user's current admin level
        <span class="cov0" title="0">var targetAdminLevel int
        config.DB.Get(&amp;targetAdminLevel, `SELECT COALESCE(admin_level, 0) FROM users WHERE id = ?`, targetID)

        // Super Admin (level 1) cannot be changed by anyone
        if targetAdminLevel == 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Super Admin tidak dapat diubah rolenya"})
                return
        }</span>

        // Regular Admin (level 2) can only be changed by Super Admin
        <span class="cov0" title="0">if targetAdminLevel == 2 &amp;&amp; currentAdminLevel != 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Admin hanya dapat diubah oleh Super Admin"})
                return
        }</span>

        <span class="cov0" title="0">var req SetRoleRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                return
        }</span>

        // Regular Admin cannot promote to Super Admin
        <span class="cov0" title="0">if currentAdminLevel == 2 &amp;&amp; req.Role == "ADMIN" &amp;&amp; req.AdminLevel == 1 </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "Admin biasa tidak dapat mengangkat Super Admin"})
                return
        }</span>

        // Get role IDs
        <span class="cov0" title="0">var userRoleID, orgRoleID, adminRoleID int
        config.DB.Get(&amp;userRoleID, `SELECT id FROM roles WHERE name = 'USER'`)
        config.DB.Get(&amp;orgRoleID, `SELECT id FROM roles WHERE name = 'ORGANIZATION'`)
        config.DB.Get(&amp;adminRoleID, `SELECT id FROM roles WHERE name = 'ADMIN'`)

        if userRoleID == 0 </span><span class="cov0" title="0">{
                userRoleID = 1
        }</span>
        <span class="cov0" title="0">if orgRoleID == 0 </span><span class="cov0" title="0">{
                orgRoleID = 2
        }</span>
        <span class="cov0" title="0">if adminRoleID == 0 </span><span class="cov0" title="0">{
                adminRoleID = 3
        }</span>

        // Delete all existing roles for this user
        <span class="cov0" title="0">config.DB.Exec(`DELETE FROM user_roles WHERE user_id = ?`, targetID)

        // Set new role
        var newRoleID int
        var newAdminLevel int = 0

        switch req.Role </span>{
        case "ADMIN":<span class="cov0" title="0">
                newRoleID = adminRoleID
                newAdminLevel = req.AdminLevel
                if newAdminLevel == 0 </span><span class="cov0" title="0">{
                        newAdminLevel = 2 // default to regular admin
                }</span>
        case "ORGANIZATION":<span class="cov0" title="0">
                newRoleID = orgRoleID</span>
        default:<span class="cov0" title="0">
                newRoleID = userRoleID</span>
        }

        // Insert new role
        <span class="cov0" title="0">_, err := config.DB.Exec(`INSERT INTO user_roles (user_id, role_id) VALUES (?, ?)`, targetID, newRoleID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to set role"})
                return
        }</span>

        // Update admin_level
        <span class="cov0" title="0">config.DB.Exec(`UPDATE users SET admin_level = ? WHERE id = ?`, newAdminLevel, targetID)

        // If setting as organization, create org profile if not exists
        if req.Role == "ORGANIZATION" </span><span class="cov0" title="0">{
                var existingOrgID int64
                err := config.DB.Get(&amp;existingOrgID, `SELECT id FROM organizations WHERE owner_user_id = ?`, targetID)
                if err != nil </span><span class="cov0" title="0">{
                        // Create new org profile
                        config.DB.Exec(`INSERT INTO organizations (owner_user_id, name, status) VALUES (?, '', 'APPROVED')`, targetID)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Role berhasil diubah",
                "role":    req.Role,
        })</span>
}

// ================================
// ADMIN: TOGGLE ADMIN ROLE (LEGACY - keep for backward compatibility)
// ================================
func ToggleAdminRole(c *gin.Context) <span class="cov0" title="0">{
        // Redirect to SetUserRole
        c.JSON(http.StatusBadRequest, gin.H{"error": "Gunakan endpoint /set-role dengan body {role, admin_level}"})
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package controllers

import (
        "net/http"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
)

// =============================
// GET MY CERTIFICATES
// =============================
func GetMyCertificates(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        type CertificateRow struct {
                ID              int64   `db:"id" json:"id"`
                EventID         int64   `db:"event_id" json:"event_id"`
                EventTitle      string  `db:"event_title" json:"event_title"`
                Score           float64 `db:"score" json:"score"`
                CertificateCode string  `db:"certificate_code" json:"certificate_code"`
                EarnedAt        string  `db:"earned_at" json:"earned_at"`
        }

        var certificates []CertificateRow
        err := config.DB.Select(&amp;certificates, `
                SELECT uc.id, uc.event_id, e.title as event_title, 
                       uc.total_score_percent as score, 
                       uc.certificate_code,
                       uc.issued_at as earned_at
                FROM user_certificates uc
                JOIN events e ON uc.event_id = e.id
                WHERE uc.user_id = ?
                ORDER BY uc.issued_at DESC
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                println("Error fetching certificates:", err.Error())
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch certificates"})
                return
        }</span>

        <span class="cov0" title="0">if certificates == nil </span><span class="cov0" title="0">{
                certificates = []CertificateRow{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"certificates": certificates})</span>
}

// =============================
// GET MY PAYMENTS
// =============================
func GetMyPayments(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        type PaymentRow struct {
                ID           int64   `db:"id" json:"id"`
                SessionID    int64   `db:"session_id" json:"session_id"`
                SessionTitle string  `db:"session_title" json:"session_title"`
                EventID      int64   `db:"event_id" json:"event_id"`
                EventTitle   string  `db:"event_title" json:"event_title"`
                Amount       float64 `db:"amount" json:"amount"`
                Status       string  `db:"status" json:"status"`
                OrderID      *string `db:"order_id" json:"order_id"`
                SnapToken    *string `db:"snap_token" json:"snap_token"`
                CreatedAt    string  `db:"created_at" json:"created_at"`
        }

        var payments []PaymentRow
        err := config.DB.Select(&amp;payments, `
                SELECT p.id, p.session_id, s.title as session_title, 
                       e.id as event_id, e.title as event_title,
                       p.price_paid as amount, p.status, p.order_id, p.snap_token,
                       p.purchased_at as created_at
                FROM purchases p
                JOIN sessions s ON p.session_id = s.id
                JOIN events e ON s.event_id = e.id
                WHERE p.user_id = ?
                ORDER BY p.purchased_at DESC
        `, userID)

        if err != nil </span><span class="cov0" title="0">{
                println("Error fetching payments:", err.Error())
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch payments"})
                return
        }</span>

        <span class="cov0" title="0">if payments == nil </span><span class="cov0" title="0">{
                payments = []PaymentRow{}
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"payments": payments})</span>
}

// =============================
// CANCEL PAYMENT
// =============================
func CancelPayment(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        paymentID := c.Param("id")

        // Check if payment exists and belongs to user
        var status string
        err := config.DB.Get(&amp;status, `
                SELECT status FROM purchases WHERE id = ? AND user_id = ?
        `, paymentID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Payment not found"})
                return
        }</span>

        <span class="cov0" title="0">if status != "PENDING" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Only pending payments can be cancelled"})
                return
        }</span>

        // Update status to CANCELLED
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                UPDATE purchases SET status = 'CANCELLED' WHERE id = ? AND user_id = ?
        `, paymentID, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to cancel payment"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Payment cancelled successfully"})</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package controllers

import (
        "net/http"

        "github.com/gin-gonic/gin"
        "golang.org/x/crypto/bcrypt"

        "BACKEND/config"
)


// =======================================
// USER: CHANGE PASSWORD
// =======================================
type ChangePasswordRequest struct {
        OldPassword string `json:"old_password"`
        NewPassword string `json:"new_password"`
}

func ChangePassword(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        var req ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
                return
        }</span>

        // Ambil user dari DB
        <span class="cov0" title="0">var passwordHash string
        err := config.DB.Get(&amp;passwordHash,
                "SELECT password_hash FROM users WHERE id = ?", userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
                return
        }</span>

        // Cek password lama
        <span class="cov0" title="0">if bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(req.OldPassword)) != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Wrong old password"})
                return
        }</span>

        // Hash password baru
        <span class="cov0" title="0">newHash, _ := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)

        // Simpan password baru
        _, err = config.DB.Exec(`
                UPDATE users SET password_hash = ? WHERE id = ?
        `, string(newHash), userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update password"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Password updated successfully"})</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "path/filepath"
        "time"

        "github.com/gin-gonic/gin"

        "BACKEND/config"
)


// =======================================
// USER: UPLOAD PROFILE IMAGE
// =======================================
func UploadProfileImage(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Ambil file dari form-data
        file, err := c.FormFile("profile_img")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Profile image is required"})
                return
        }</span>

        // Validasi ekstensi file
        <span class="cov0" title="0">ext := filepath.Ext(file.Filename)
        if ext != ".jpg" &amp;&amp; ext != ".jpeg" &amp;&amp; ext != ".png" &amp;&amp; ext != ".webp" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Only JPG, JPEG, PNG, WEBP allowed"})
                return
        }</span>

        // Nama file unik
        <span class="cov0" title="0">filename := fmt.Sprintf("user_%d_%d%s", userID, time.Now().Unix(), ext)

        // Path tujuan (folder relatif dari root project backend)
        uploadPath := "uploads/profile/" + filename

        // Simpan file ke disk
        if err := c.SaveUploadedFile(file, uploadPath); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to upload image"})
                return
        }</span>

        // Simpan path ke database
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                UPDATE users SET profile_img = ? WHERE id = ?
        `, uploadPath, userID)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save image URL"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Profile image uploaded successfully",
                "url":     uploadPath,
        })</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package controllers

import (
        "net/http"
        "os"
        "path/filepath"
        "strconv"

        "github.com/gin-gonic/gin"
)

func StreamVideo(c *gin.Context) <span class="cov0" title="0">{

        fileName := c.Param("filename")
        fullPath := filepath.Join("uploads/sessions/videos/", fileName)

        file, err := os.Open(fullPath)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(404, gin.H{"error": "Video not found"})
                return
        }</span>

        <span class="cov0" title="0">stat, _ := file.Stat()

        c.Header("Content-Type", "video/mp4")
        c.Header("Accept-Ranges", "bytes")
        c.Header("Content-Length", strconv.FormatInt(stat.Size(), 10))

        http.ServeContent(c.Writer, c.Request, fileName, stat.ModTime(), file)</span>
        
}</pre>
		
		<pre class="file" id="file32" style="display: none">package controllers

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "BACKEND/config"

        "github.com/gin-gonic/gin"
)

// ===============================================
// WITHDRAWAL REQUEST CONTROLLER
// Centralized withdrawal system - all go to admin
// ===============================================

// RequestOrgWithdrawal - Organization requests withdrawal
// POST /organization/withdrawal-request
func RequestOrgWithdrawal(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get organization owned by user
        var org struct {
                ID   int64  `db:"id"`
                Name string `db:"name"`
        }
        err := config.DB.Get(&amp;org, "SELECT id, name FROM organizations WHERE owner_user_id = ?", userID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ORG-WITHDRAW] Organization not found for user %d: %v\n", userID, err)
                c.JSON(http.StatusNotFound, gin.H{"error": "Organisasi tidak ditemukan"})
                return
        }</span>

        // Get balance from organization_balances table
        <span class="cov0" title="0">var balance float64
        config.DB.Get(&amp;balance, `
                SELECT COALESCE(balance, 0) FROM organization_balances WHERE organization_id = ?
        `, org.ID)

        fmt.Printf("[ORG-WITHDRAW] orgID=%d, name=%s, balance=%.0f\n", org.ID, org.Name, balance)

        var input struct {
                Amount          float64 `json:"amount" binding:"required"`
                BankName        string  `json:"bank_name" binding:"required"`
                BankAccount     string  `json:"bank_account" binding:"required"`
                BankAccountName string  `json:"bank_account_name" binding:"required"`
                Notes           string  `json:"notes"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Lengkapi semua data yang diperlukan"})
                return
        }</span>

        // Validate amount
        <span class="cov0" title="0">if input.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Jumlah penarikan harus lebih dari 0"})
                return
        }</span>
        <span class="cov0" title="0">if input.Amount &gt; balance </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Saldo tidak cukup. Saldo Anda: Rp %.0f", balance)})
                return
        }</span>

        // Check if already has an active (PENDING or APPROVED) request this month
        <span class="cov0" title="0">var activeCount int
        config.DB.Get(&amp;activeCount, `
                SELECT COUNT(*) FROM withdrawal_requests 
                WHERE requester_type = 'ORGANIZATION' 
                AND requester_id = ? 
                AND status IN ('PENDING', 'APPROVED')
                AND MONTH(created_at) = MONTH(NOW()) 
                AND YEAR(created_at) = YEAR(NOW())
        `, org.ID)
        if activeCount &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah memiliki permintaan penarikan aktif bulan ini. Tunggu hingga diproses atau bulan depan."})
                return
        }</span>

        // Check total attempts this month (max 7, including rejected)
        <span class="cov0" title="0">var totalAttempts int
        config.DB.Get(&amp;totalAttempts, `
                SELECT COUNT(*) FROM withdrawal_requests 
                WHERE requester_type = 'ORGANIZATION' 
                AND requester_id = ? 
                AND MONTH(created_at) = MONTH(NOW()) 
                AND YEAR(created_at) = YEAR(NOW())
        `, org.ID)
        if totalAttempts &gt;= 7 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah mencapai batas maksimal 7 percobaan penarikan bulan ini."})
                return
        }</span>

        // Insert withdrawal request
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                INSERT INTO withdrawal_requests (requester_type, requester_id, amount, bank_name, bank_account, bank_account_name, notes)
                VALUES ('ORGANIZATION', ?, ?, ?, ?, ?, ?)
        `, org.ID, input.Amount, input.BankName, input.BankAccount, input.BankAccountName, input.Notes)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mengajukan penarikan: " + err.Error()})
                return
        }</span>

        // Notify admins
        <span class="cov0" title="0">var adminIDs []int64
        config.DB.Select(&amp;adminIDs, `
                SELECT u.id FROM users u 
                JOIN user_roles ur ON u.id = ur.user_id 
                JOIN roles r ON ur.role_id = r.id 
                WHERE r.name IN ('ADMIN', 'SUPERADMIN')
        `)
        for _, adminID := range adminIDs </span><span class="cov0" title="0">{
                CreateNotification(
                        adminID,
                        "withdrawal_request",
                        "💰 Permintaan Penarikan Baru",
                        fmt.Sprintf("Organisasi \"%s\" mengajukan penarikan Rp %.0f", org.Name, input.Amount),
                )
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Permintaan penarikan berhasil diajukan. Menunggu persetujuan admin."})</span>
}

// RequestAffiliateWithdrawal - Affiliate requests withdrawal
// POST /affiliate/withdrawal-request
func RequestAffiliateWithdrawal(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")

        // Get affiliate balance from affiliate_balances table (same as GetAffiliateBalance)
        var balanceData struct {
                TotalEarned    float64 `db:"total_earned"`
                TotalWithdrawn float64 `db:"total_withdrawn"`
        }
        err := config.DB.Get(&amp;balanceData, `
                SELECT COALESCE(total_earned, 0) as total_earned, 
                       COALESCE(total_withdrawn, 0) as total_withdrawn
                FROM affiliate_balances WHERE user_id = ?
        `, userID)

        // Calculate available balance
        var availableBalance float64
        if err != nil </span><span class="cov0" title="0">{
                // No balance record yet - calculate from ledger
                config.DB.Get(&amp;availableBalance, `
                        SELECT COALESCE(SUM(al.affiliate_amount), 0)
                        FROM affiliate_ledgers al
                        JOIN affiliate_submissions asub ON al.affiliate_submission_id = asub.id
                        WHERE asub.user_id = ?
                `, userID)
        }</span> else<span class="cov0" title="0"> {
                availableBalance = balanceData.TotalEarned - balanceData.TotalWithdrawn
        }</span>

        <span class="cov0" title="0">fmt.Printf("[AFFILIATE-WITHDRAW] userID=%d, available_balance=%.0f\n", userID, availableBalance)

        var input struct {
                Amount          float64 `json:"amount" binding:"required"`
                BankName        string  `json:"bank_name" binding:"required"`
                BankAccount     string  `json:"bank_account" binding:"required"`
                BankAccountName string  `json:"bank_account_name" binding:"required"`
                Notes           string  `json:"notes"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Lengkapi semua data yang diperlukan"})
                return
        }</span>

        // Validate amount
        <span class="cov0" title="0">if input.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Jumlah penarikan harus lebih dari 0"})
                return
        }</span>
        <span class="cov0" title="0">if input.Amount &gt; availableBalance </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Saldo tidak cukup. Saldo Anda: Rp %.0f", availableBalance)})
                return
        }</span>

        // Check if already has an active (PENDING or APPROVED) request this month
        <span class="cov0" title="0">var activeCount int
        config.DB.Get(&amp;activeCount, `
                SELECT COUNT(*) FROM withdrawal_requests 
                WHERE requester_type = 'AFFILIATE' 
                AND requester_id = ? 
                AND status IN ('PENDING', 'APPROVED')
                AND MONTH(created_at) = MONTH(NOW()) 
                AND YEAR(created_at) = YEAR(NOW())
        `, userID)
        if activeCount &gt; 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah memiliki permintaan penarikan aktif bulan ini. Tunggu hingga diproses atau bulan depan."})
                return
        }</span>

        // Check total attempts this month (max 7, including rejected)
        <span class="cov0" title="0">var totalAttempts int
        config.DB.Get(&amp;totalAttempts, `
                SELECT COUNT(*) FROM withdrawal_requests 
                WHERE requester_type = 'AFFILIATE' 
                AND requester_id = ? 
                AND MONTH(created_at) = MONTH(NOW()) 
                AND YEAR(created_at) = YEAR(NOW())
        `, userID)
        if totalAttempts &gt;= 7 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Anda sudah mencapai batas maksimal 7 percobaan penarikan bulan ini."})
                return
        }</span>

        // Insert withdrawal request
        <span class="cov0" title="0">_, err = config.DB.Exec(`
                INSERT INTO withdrawal_requests (requester_type, requester_id, amount, bank_name, bank_account, bank_account_name, notes)
                VALUES ('AFFILIATE', ?, ?, ?, ?, ?, ?)
        `, userID, input.Amount, input.BankName, input.BankAccount, input.BankAccountName, input.Notes)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal mengajukan penarikan: " + err.Error()})
                return
        }</span>

        // Notify admins
        <span class="cov0" title="0">var userName string
        config.DB.Get(&amp;userName, "SELECT name FROM users WHERE id = ?", userID)
        var adminIDs []int64
        config.DB.Select(&amp;adminIDs, `
                SELECT u.id FROM users u 
                JOIN user_roles ur ON u.id = ur.user_id 
                JOIN roles r ON ur.role_id = r.id 
                WHERE r.name IN ('ADMIN', 'SUPERADMIN')
        `)
        for _, adminID := range adminIDs </span><span class="cov0" title="0">{
                CreateNotification(
                        adminID,
                        "withdrawal_request",
                        "💰 Permintaan Penarikan Affiliate",
                        fmt.Sprintf("Affiliate \"%s\" mengajukan penarikan Rp %.0f", userName, input.Amount),
                )
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Permintaan penarikan berhasil diajukan. Menunggu persetujuan admin."})</span>
}

// GetMyWithdrawalRequests - Get user's withdrawal requests
// GET /user/withdrawal-requests (for both org and affiliate)
func GetMyWithdrawalRequests(c *gin.Context) <span class="cov0" title="0">{
        userID := c.GetInt64("user_id")
        requesterType := c.Query("type") // "ORGANIZATION" or "AFFILIATE"

        var requests []struct {
                ID              int64      `db:"id" json:"id"`
                RequesterType   string     `db:"requester_type" json:"requester_type"`
                Amount          float64    `db:"amount" json:"amount"`
                BankName        string     `db:"bank_name" json:"bank_name"`
                BankAccount     string     `db:"bank_account" json:"bank_account"`
                BankAccountName string     `db:"bank_account_name" json:"bank_account_name"`
                Notes           *string    `db:"notes" json:"notes"`
                Status          string     `db:"status" json:"status"`
                AdminNotes      *string    `db:"admin_notes" json:"admin_notes"`
                CreatedAt       time.Time  `db:"created_at" json:"created_at"`
                ProcessedAt     *time.Time `db:"processed_at" json:"processed_at"`
        }

        if requesterType == "ORGANIZATION" </span><span class="cov0" title="0">{
                var orgID int64
                config.DB.Get(&amp;orgID, "SELECT id FROM organizations WHERE owner_user_id = ?", userID)
                config.DB.Select(&amp;requests, `
                        SELECT id, requester_type, amount, bank_name, bank_account, bank_account_name, notes, status, admin_notes, created_at, processed_at
                        FROM withdrawal_requests
                        WHERE requester_type = 'ORGANIZATION' AND requester_id = ?
                        ORDER BY created_at DESC
                `, orgID)
        }</span> else<span class="cov0" title="0"> {
                config.DB.Select(&amp;requests, `
                        SELECT id, requester_type, amount, bank_name, bank_account, bank_account_name, notes, status, admin_notes, created_at, processed_at
                        FROM withdrawal_requests
                        WHERE requester_type = 'AFFILIATE' AND requester_id = ?
                        ORDER BY created_at DESC
                `, userID)
        }</span>

        <span class="cov0" title="0">if requests == nil </span><span class="cov0" title="0">{
                requests = make([]struct {
                        ID              int64      `db:"id" json:"id"`
                        RequesterType   string     `db:"requester_type" json:"requester_type"`
                        Amount          float64    `db:"amount" json:"amount"`
                        BankName        string     `db:"bank_name" json:"bank_name"`
                        BankAccount     string     `db:"bank_account" json:"bank_account"`
                        BankAccountName string     `db:"bank_account_name" json:"bank_account_name"`
                        Notes           *string    `db:"notes" json:"notes"`
                        Status          string     `db:"status" json:"status"`
                        AdminNotes      *string    `db:"admin_notes" json:"admin_notes"`
                        CreatedAt       time.Time  `db:"created_at" json:"created_at"`
                        ProcessedAt     *time.Time `db:"processed_at" json:"processed_at"`
                }, 0)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, requests)</span>
}

// ===============================================
// ADMIN - MANAGE WITHDRAWAL REQUESTS
// ===============================================

// GetAllWithdrawalRequests - Admin gets all withdrawal requests
// GET /admin/withdrawal-requests
func GetAllWithdrawalRequests(c *gin.Context) <span class="cov0" title="0">{
        statusFilter := c.DefaultQuery("status", "")

        var requests []struct {
                ID              int64      `db:"id" json:"id"`
                RequesterType   string     `db:"requester_type" json:"requester_type"`
                RequesterID     int64      `db:"requester_id" json:"requester_id"`
                RequesterName   string     `db:"requester_name" json:"requester_name"`
                Amount          float64    `db:"amount" json:"amount"`
                BankName        string     `db:"bank_name" json:"bank_name"`
                BankAccount     string     `db:"bank_account" json:"bank_account"`
                BankAccountName string     `db:"bank_account_name" json:"bank_account_name"`
                Notes           *string    `db:"notes" json:"notes"`
                Status          string     `db:"status" json:"status"`
                AdminNotes      *string    `db:"admin_notes" json:"admin_notes"`
                CreatedAt       time.Time  `db:"created_at" json:"created_at"`
                ProcessedAt     *time.Time `db:"processed_at" json:"processed_at"`
        }

        query := `
                SELECT wr.id, wr.requester_type, wr.requester_id,
                        CASE 
                                WHEN wr.requester_type = 'ORGANIZATION' THEN (SELECT name FROM organizations WHERE id = wr.requester_id)
                                ELSE (SELECT name FROM users WHERE id = wr.requester_id)
                        END as requester_name,
                        wr.amount, wr.bank_name, wr.bank_account, wr.bank_account_name, 
                        wr.notes, wr.status, wr.admin_notes, wr.created_at, wr.processed_at
                FROM withdrawal_requests wr
        `
        if statusFilter != "" </span><span class="cov0" title="0">{
                query += " WHERE wr.status = ?"
                query += " ORDER BY wr.created_at DESC"
                config.DB.Select(&amp;requests, query, statusFilter)
        }</span> else<span class="cov0" title="0"> {
                query += " ORDER BY wr.status = 'PENDING' DESC, wr.created_at DESC"
                config.DB.Select(&amp;requests, query)
        }</span>

        <span class="cov0" title="0">if requests == nil </span><span class="cov0" title="0">{
                requests = make([]struct {
                        ID              int64      `db:"id" json:"id"`
                        RequesterType   string     `db:"requester_type" json:"requester_type"`
                        RequesterID     int64      `db:"requester_id" json:"requester_id"`
                        RequesterName   string     `db:"requester_name" json:"requester_name"`
                        Amount          float64    `db:"amount" json:"amount"`
                        BankName        string     `db:"bank_name" json:"bank_name"`
                        BankAccount     string     `db:"bank_account" json:"bank_account"`
                        BankAccountName string     `db:"bank_account_name" json:"bank_account_name"`
                        Notes           *string    `db:"notes" json:"notes"`
                        Status          string     `db:"status" json:"status"`
                        AdminNotes      *string    `db:"admin_notes" json:"admin_notes"`
                        CreatedAt       time.Time  `db:"created_at" json:"created_at"`
                        ProcessedAt     *time.Time `db:"processed_at" json:"processed_at"`
                }, 0)
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, requests)</span>
}

// ApproveWithdrawalRequest - Admin approves withdrawal
// PUT /admin/withdrawal-requests/:id/approve
func ApproveWithdrawalRequest(c *gin.Context) <span class="cov0" title="0">{
        adminID := c.GetInt64("user_id")
        requestID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        var input struct {
                AdminNotes string `json:"admin_notes"`
        }
        c.ShouldBindJSON(&amp;input)

        // Get request
        var request struct {
                ID            int64   `db:"id"`
                RequesterType string  `db:"requester_type"`
                RequesterID   int64   `db:"requester_id"`
                Amount        float64 `db:"amount"`
                Status        string  `db:"status"`
        }
        err := config.DB.Get(&amp;request, "SELECT id, requester_type, requester_id, amount, status FROM withdrawal_requests WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Request tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if request.Status != "PENDING" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Request sudah diproses sebelumnya"})
                return
        }</span>

        <span class="cov0" title="0">tx, _ := config.DB.Beginx()

        // Deduct balance
        if request.RequesterType == "ORGANIZATION" </span><span class="cov0" title="0">{
                // Update organization_balances table
                _, err = tx.Exec(`
                        UPDATE organization_balances 
                        SET balance = balance - ?, total_withdrawn = total_withdrawn + ?
                        WHERE organization_id = ?
                `, request.Amount, request.Amount, request.RequesterID)
        }</span> else<span class="cov0" title="0"> {
                // Update affiliate_balances table
                _, err = tx.Exec(`
                        UPDATE affiliate_balances 
                        SET total_withdrawn = total_withdrawn + ?
                        WHERE user_id = ?
                `, request.Amount, request.RequesterID)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update saldo"})
                return
        }</span>

        // Update request status
        <span class="cov0" title="0">_, err = tx.Exec(`
                UPDATE withdrawal_requests 
                SET status = 'APPROVED', admin_notes = ?, processed_at = NOW(), processed_by = ?
                WHERE id = ?
        `, input.AdminNotes, adminID, requestID)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Gagal update status"})
                return
        }</span>

        <span class="cov0" title="0">tx.Commit()

        // Notify requester
        var notifyUserID int64
        if request.RequesterType == "ORGANIZATION" </span><span class="cov0" title="0">{
                config.DB.Get(&amp;notifyUserID, "SELECT owner_user_id FROM organizations WHERE id = ?", request.RequesterID)
        }</span> else<span class="cov0" title="0"> {
                notifyUserID = request.RequesterID
        }</span>
        <span class="cov0" title="0">CreateNotification(
                notifyUserID,
                "withdrawal_approved",
                "✅ Penarikan Disetujui",
                fmt.Sprintf("Penarikan sebesar Rp %.0f telah disetujui dan sedang diproses.", request.Amount),
        )

        c.JSON(http.StatusOK, gin.H{"message": "Penarikan disetujui"})</span>
}

// RejectWithdrawalRequest - Admin rejects withdrawal
// PUT /admin/withdrawal-requests/:id/reject
func RejectWithdrawalRequest(c *gin.Context) <span class="cov0" title="0">{
        adminID := c.GetInt64("user_id")
        requestID, _ := strconv.ParseInt(c.Param("id"), 10, 64)

        var input struct {
                AdminNotes string `json:"admin_notes" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Berikan alasan penolakan"})
                return
        }</span>

        <span class="cov0" title="0">var request struct {
                RequesterType string  `db:"requester_type"`
                RequesterID   int64   `db:"requester_id"`
                Amount        float64 `db:"amount"`
                Status        string  `db:"status"`
        }
        err := config.DB.Get(&amp;request, "SELECT requester_type, requester_id, amount, status FROM withdrawal_requests WHERE id = ?", requestID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "Request tidak ditemukan"})
                return
        }</span>

        <span class="cov0" title="0">if request.Status != "PENDING" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Request sudah diproses sebelumnya"})
                return
        }</span>

        <span class="cov0" title="0">config.DB.Exec(`
                UPDATE withdrawal_requests 
                SET status = 'REJECTED', admin_notes = ?, processed_at = NOW(), processed_by = ?
                WHERE id = ?
        `, input.AdminNotes, adminID, requestID)

        // Notify requester
        var notifyUserID int64
        if request.RequesterType == "ORGANIZATION" </span><span class="cov0" title="0">{
                config.DB.Get(&amp;notifyUserID, "SELECT owner_user_id FROM organizations WHERE id = ?", request.RequesterID)
        }</span> else<span class="cov0" title="0"> {
                notifyUserID = request.RequesterID
        }</span>
        <span class="cov0" title="0">CreateNotification(
                notifyUserID,
                "withdrawal_rejected",
                "❌ Penarikan Ditolak",
                fmt.Sprintf("Penarikan sebesar Rp %.0f ditolak. Alasan: %s", request.Amount, input.AdminNotes),
        )

        c.JSON(http.StatusOK, gin.H{"message": "Penarikan ditolak"})</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
